
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../05_controller__ui_logic_coordinator__/" rel="prev"/>
<link href="../07_connection__network_stream_handling__/" rel="next"/>
<link href="../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.12" name="generator"/>
<title>Chapter 6: TransportMessage (Network Data Framing) - dat110 notes</title>
<link href="../assets/stylesheets/main.2afb09e1.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#chapter-6-transportmessage-network-data-framing">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="dat110 notes" class="md-header__button md-logo" data-md-component="logo" href=".." title="dat110 notes">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            dat110 notes
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Chapter 6: TransportMessage (Network Data Framing)
            
          </span>
</div>
</div>
</div>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="Search" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="Search" class="md-search__options">
<button aria-label="Clear" class="md-search__icon md-icon" tabindex="-1" title="Clear" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Initializing search
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="dat110 notes" class="md-nav__button md-logo" data-md-component="logo" href=".." title="dat110 notes">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>
</a>
    dat110 notes
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    Tutorial: dat110-project2-javafx-chatapp
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../01_message_hierarchy__communication_protocol__/">
<span class="md-ellipsis">
    Chapter 1: Message Hierarchy (Communication Protocol)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../02_client__network_interaction_logic__/">
<span class="md-ellipsis">
    Chapter 2: Client (Network Interaction Logic)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../03_chapp__application_entry_point__/">
<span class="md-ellipsis">
    Chapter 3: Chapp (Application Entry Point)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../04_ui_areas__commandarea___messagearea__/">
<span class="md-ellipsis">
    Chapter 4: UI Areas (CommandArea &amp; MessageArea)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../05_controller__ui_logic_coordinator__/">
<span class="md-ellipsis">
    Chapter 5: Controller (UI Logic Coordinator)
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    Chapter 6: TransportMessage (Network Data Framing)
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
<span class="md-ellipsis">
    Chapter 6: TransportMessage (Network Data Framing)
    
  </span>
</a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#the-problem-finding-message-boundaries-in-a-stream">
<span class="md-ellipsis">
      The Problem: Finding Message Boundaries in a Stream
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-solution-data-framing">
<span class="md-ellipsis">
      The Solution: Data Framing
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#our-standard-envelope-transportmessagejava">
<span class="md-ellipsis">
      Our Standard Envelope: TransportMessage.java
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fixed-packet-size-messageconfigsegmentsize">
<span class="md-ellipsis">
      Fixed Packet Size: MessageConfig.SEGMENTSIZE
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#packing-the-envelope-encapsulate">
<span class="md-ellipsis">
      Packing the Envelope: encapsulate()
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#opening-the-envelope-decapsulate">
<span class="md-ellipsis">
      Opening the Envelope: decapsulate()
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-it-fits-together">
<span class="md-ellipsis">
      How It Fits Together
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conclusion">
<span class="md-ellipsis">
      Conclusion
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../07_connection__network_stream_handling__/">
<span class="md-ellipsis">
    Chapter 7: Connection (Network Stream Handling)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../08_messageutils__serialization_deserialization__/">
<span class="md-ellipsis">
    Chapter 8: MessageUtils (Serialization/Deserialization)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../test/">
<span class="md-ellipsis">
    Test
    
  </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#the-problem-finding-message-boundaries-in-a-stream">
<span class="md-ellipsis">
      The Problem: Finding Message Boundaries in a Stream
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-solution-data-framing">
<span class="md-ellipsis">
      The Solution: Data Framing
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#our-standard-envelope-transportmessagejava">
<span class="md-ellipsis">
      Our Standard Envelope: TransportMessage.java
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fixed-packet-size-messageconfigsegmentsize">
<span class="md-ellipsis">
      Fixed Packet Size: MessageConfig.SEGMENTSIZE
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#packing-the-envelope-encapsulate">
<span class="md-ellipsis">
      Packing the Envelope: encapsulate()
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#opening-the-envelope-decapsulate">
<span class="md-ellipsis">
      Opening the Envelope: decapsulate()
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-it-fits-together">
<span class="md-ellipsis">
      How It Fits Together
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conclusion">
<span class="md-ellipsis">
      Conclusion
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="chapter-6-transportmessage-network-data-framing">Chapter 6: TransportMessage (Network Data Framing)</h1>
<p>In the <a href="../05_controller__ui_logic_coordinator__/">previous chapter</a>, we saw how the <code>Controller</code> acts as the application's director, taking requests from the UI (like sending a message) and telling the <code>Client</code> (<a href="../02_client__network_interaction_logic__/">Chapter 2</a>) what to do. The <code>Client</code> then prepares to send a message object (like a <code>PublishMsg</code> from <a href="../01_message_hierarchy__communication_protocol__/">Chapter 1</a>) over the network.</p>
<p>But how does that message object actually travel across the internet? Computers connected via a network send data as streams of raw bytes (ones and zeroes). If our <code>Client</code> just dumped all the bytes for <code>ConnectMsg</code>, then <code>PublishMsg</code>, then another <code>PublishMsg</code> into the stream, how would the <code>Server</code> know where one message ends and the next one starts?</p>
<h2 id="the-problem-finding-message-boundaries-in-a-stream">The Problem: Finding Message Boundaries in a Stream</h2>
<p>Imagine you're receiving a very long letter, but instead of arriving in an envelope, it arrives as one continuous ticker tape of letters with no spaces or punctuation. It would be impossible to read!</p>
<pre><code>HELLOWORLDHOWAREYOUIMFINEGOODBYE
</code></pre>
<p>Network communication is similar. Data arrives as a continuous stream of bytes. The receiver needs a way to figure out: "Okay, <em>these</em> specific bytes make up the first message, and <em>these next</em> bytes make up the second message." Without clear boundaries, the data is just a jumbled mess.</p>
<h2 id="the-solution-data-framing">The Solution: Data Framing</h2>
<p>To solve this, we use <strong>Data Framing</strong>. Think of it like putting each message into its own standard-sized envelope or small shipping box before sending it. This "frame" not only holds the message content (the "payload") but also adds some extra information, like a label on the outside.</p>
<p>In our chat application, the most important piece of information we add is the <strong>length of the payload</strong>.</p>
<p><strong>Analogy: The Standard Envelope</strong></p>
<p>Imagine you have messages of different lengths (a short note, a long letter).
1.  You get a standard-sized envelope (maybe it can hold up to 100 characters).
2.  You write your message (the payload). Let's say it's "Hi Bob!" (7 characters).
3.  You put the message inside the envelope.
4.  Crucially, on the <em>outside</em> of the envelope, you write: "Payload Length: 7".
5.  You send the envelope.</p>
<p>When your friend receives the standard-sized envelope, they don't need to guess where your message ends. They look at the label ("Payload Length: 7"), open the envelope, and read exactly the first 7 characters. They know those 7 characters constitute the complete message. Anything else in the envelope is just padding, and the <em>next</em> envelope they receive will contain the <em>next</em> message.</p>
<h2 id="our-standard-envelope-transportmessagejava">Our Standard Envelope: <code>TransportMessage.java</code></h2>
<p>In our project, the <code>TransportMessage</code> class acts as this standard envelope or frame. Its main job is to hold the raw data bytes of the <em>actual</em> message we want to send (like the bytes representing a <code>ConnectMsg</code> or <code>PublishMsg</code>) and provide methods to wrap (frame) and unwrap (unframe) this data.</p>
<pre><code class="language-java">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java

public class TransportMessage {

    // The actual message content (raw bytes)
    private byte[] payload;

    // Constructor: Creates a TransportMessage holding the payload
    public TransportMessage(byte[] payload) {
        // We need to make sure the payload isn't too big for our 'envelope'
        if (payload == null || (payload.length + 1 &gt; MessageConfig.SEGMENTSIZE)) {
            // (+1 because we need space for the length byte itself)
            throw new RuntimeException("Payload too large for segment!");
        }
        this.payload = payload;
    }

    // Method to get the payload data back out
    public byte[] getData() {
        return this.payload;
    }

    // ... (encapsulate and decapsulate methods coming next) ...
}
</code></pre>
<ul>
<li><strong><code>private byte[] payload;</code></strong>: This is where the raw data of the original message (e.g., the serialized <code>PublishMsg</code>) is stored. How we get these bytes from a <code>PublishMsg</code> object is the job of <a href="../08_messageutils__serialization_deserialization__/">Chapter 8: MessageUtils (Serialization/Deserialization)</a>. For now, just know that <code>payload</code> holds the core message content as bytes.</li>
<li><strong><code>TransportMessage(byte[] payload)</code></strong>: The constructor takes these payload bytes and stores them. It also checks if the payload, plus the one extra byte we need for the length, will fit into our standard network packet size (<code>MessageConfig.SEGMENTSIZE</code>).</li>
</ul>
<h2 id="fixed-packet-size-messageconfigsegmentsize">Fixed Packet Size: <code>MessageConfig.SEGMENTSIZE</code></h2>
<p>Our network communication uses fixed-size packets, like using only one size of shipping box. This size is defined in <code>MessageConfig.java</code>.</p>
<pre><code class="language-java">// File: src/main/java/no/hvl/dat110/messagetransport/MessageConfig.java

public class MessageConfig {

    // All our network 'envelopes' will be exactly 128 bytes long
    public static final int SEGMENTSIZE = 128;

    // Other network config (ignore for now)
    public static final int MESSAGINGPORT = 8080;
    public static final String MESSAGINGHOST = "localhost";
}
</code></pre>
<ul>
<li><strong><code>SEGMENTSIZE = 128</code></strong>: This means every chunk of data sent or received over the network using our <code>TransportMessage</code> framing will be exactly 128 bytes.</li>
</ul>
<h2 id="packing-the-envelope-encapsulate">Packing the Envelope: <code>encapsulate()</code></h2>
<p>How do we take our <code>payload</code> and put it into the standard 128-byte frame, adding the length information? This process is called <strong>encapsulation</strong>.</p>
<p>The <code>encapsulate()</code> method in <code>TransportMessage</code> does this:</p>
<ol>
<li>Creates a new, empty byte array of exactly <code>SEGMENTSIZE</code> (128 bytes).</li>
<li>Calculates the length of the <code>payload</code>.</li>
<li>Writes this length value into the <em>very first byte</em> (index 0) of the 128-byte array.</li>
<li>Copies the actual <code>payload</code> bytes into the array, starting right <em>after</em> the length byte (at index 1).</li>
<li>Returns the filled 128-byte array. The rest of the array (after the payload) is just padding and doesn't matter.</li>
</ol>
<pre><code class="language-java">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java

public byte[] encapsulate() {

    byte[] encoded; // This will be our 128-byte framed message

    // Create the empty 128-byte array
    encoded = new byte[MessageConfig.SEGMENTSIZE];

    // --- The Framing Magic ---
    // 1. Put the length of the payload into the first byte
    encoded[0] = (byte) (payload.length);

    // 2. Copy the payload bytes starting from the second byte (index 1)
    for (int i = 0; i &lt; payload.length; i++) {
        encoded[i + 1] = payload[i];
    }
    // --- End of Framing ---

    // Return the fully prepared 128-byte segment
    return encoded;
}
</code></pre>
<ul>
<li><code>encoded = new byte[MessageConfig.SEGMENTSIZE];</code>: Makes the 128-byte "envelope".</li>
<li><code>encoded[0] = (byte) (payload.length);</code>: Writes the payload length into the first byte. We cast to <code>byte</code> because the length must fit in a single byte (0-255), which is why <code>SEGMENTSIZE</code> (128) limits the maximum payload size (to 127 bytes + 1 length byte).</li>
<li><code>encoded[i + 1] = payload[i];</code>: Copies the payload bytes one by one into the <code>encoded</code> array, starting at index 1.</li>
</ul>
<p><strong>Visual Example:</strong>
If our payload is <code>[72, 101, 108, 108, 111]</code> (bytes for "Hello"), its length is 5. <code>encapsulate()</code> produces a 128-byte array like this:</p>
<pre><code>Byte Index:   0    1    2    3    4    5    6   ...   127
Value:      [ 5 | 72 |101 |108 |108 |111 | 0 | ... |  0 ]
             \-/ \---------------------/ \-------------/
            Length    Actual Payload       Padding (unused)
</code></pre>
<p>This 128-byte <code>encoded</code> array is what gets sent over the network by the <a href="../07_connection__network_stream_handling__/">Connection</a>.</p>
<h2 id="opening-the-envelope-decapsulate">Opening the Envelope: <code>decapsulate()</code></h2>
<p>When the receiver gets a 128-byte chunk of data from the network, how does it extract the original <code>payload</code>? This is called <strong>decapsulation</strong>.</p>
<p>The <code>decapsulate()</code> method does the reverse of <code>encapsulate()</code>:</p>
<ol>
<li>Takes the received 128-byte array (<code>received</code>) as input.</li>
<li>Reads the <em>first byte</em> (index 0) to find out the <code>length</code> of the original payload.</li>
<li>Uses this <code>length</code> to know exactly which bytes in the <code>received</code> array constitute the payload (from index 1 up to index <code>length</code>).</li>
<li>Copies <em>only</em> these payload bytes into the <code>TransportMessage</code> object's own <code>payload</code> field.</li>
</ol>
<pre><code class="language-java">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java

import java.util.Arrays; // Needed for Arrays.copyOfRange

public void decapsulate(byte[] received) { // 'received' is the 128-byte array from network

    // --- The Un-Framing Magic ---
    // 1. Read the payload length from the first byte
    int len = received[0];

    // 2. Extract the payload bytes from the received array
    //    Starts at index 1, and copies 'len' bytes.
    payload = Arrays.copyOfRange(received, 1, len + 1);
    // --- End of Un-Framing ---

    // Now, 'this.payload' holds the original message bytes again!
}
</code></pre>
<ul>
<li><code>int len = received[0];</code>: Gets the length stored in the first byte.</li>
<li><code>payload = Arrays.copyOfRange(received, 1, len + 1);</code>: This is a handy Java utility. It copies a portion of the <code>received</code> array.<ul>
<li><code>1</code>: Start copying from index 1 (where the payload begins).</li>
<li><code>len + 1</code>: Copy up to (but <em>not including</em>) this index. Since we start at 1 and want <code>len</code> bytes, the end index is <code>1 + len</code>.</li>
</ul>
</li>
<li>After this, the <code>payload</code> field of the <code>TransportMessage</code> object holds the extracted data.</li>
</ul>
<h2 id="how-it-fits-together">How It Fits Together</h2>
<p>Here's a simplified view of how <code>TransportMessage</code> is used when sending a message:</p>
<div class="mermaid">sequenceDiagram
    participant Ctrl as Controller
    participant Cl as Client
    participant MU as MessageUtils
    participant TM as TransportMessage
    participant Conn as Connection
    participant Net as Network

    Note over Ctrl, Cl: User wants to publish "Hello" to "general"
    Ctrl-&gt;&gt;Cl: client.publish("general", "Hello")
    Cl-&gt;&gt;Cl: Create PublishMsg(user, "general", "Hello")
    Cl-&gt;&gt;MU: MessageUtils.toTransportMessage(publishMsg)
    MU-&gt;&gt;MU: Serialize PublishMsg into byte[] payload (e.g., [72, 101, ...])
    MU-&gt;&gt;TM: new TransportMessage(payload)
    TM--&gt;&gt;MU: TransportMessage object created (holds payload)
    MU--&gt;&gt;Cl: Return TransportMessage object
    Cl-&gt;&gt;Conn: connection.send(transportMessage)
    Conn-&gt;&gt;TM: transportMessage.encapsulate()
    TM-&gt;&gt;TM: Create 128-byte array: [length | payload | padding]
    TM--&gt;&gt;Conn: Return 128-byte encoded array
    Conn-&gt;&gt;Net: Send 128 bytes over TCP stream

</div>
<ol>
<li>The <code>Client</code> gets a <code>Message</code> object (like <code>PublishMsg</code>).</li>
<li>It asks <code>MessageUtils</code> (<a href="../08_messageutils__serialization_deserialization__/">Chapter 8</a>) to convert this object into a <code>TransportMessage</code>.</li>
<li><code>MessageUtils</code> first turns the <code>PublishMsg</code> into its raw byte <code>payload</code>.</li>
<li><code>MessageUtils</code> creates a <code>TransportMessage</code> containing this <code>payload</code>.</li>
<li>The <code>Client</code> tells the <code>Connection</code> (<a href="../07_connection__network_stream_handling__/">Chapter 7</a>) to send this <code>TransportMessage</code>.</li>
<li>The <code>Connection</code> calls <code>transportMessage.encapsulate()</code> to get the framed 128-byte array.</li>
<li>The <code>Connection</code> sends these 128 bytes over the network.</li>
</ol>
<p>Receiving works in reverse, with the <code>Connection</code> reading 128 bytes, creating an empty <code>TransportMessage</code>, calling <code>decapsulate()</code> on it, and then passing the <code>TransportMessage</code> (now containing the extracted payload) to <code>MessageUtils</code> to turn it back into a <code>PublishMsg</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We've learned that sending raw data over a network stream is problematic because the receiver doesn't know where messages start and end. <strong>Data Framing</strong> solves this by wrapping the message data (payload) in a structure that includes metadata, like the payload's length.</p>
<p>The <code>TransportMessage</code> class implements this framing in our project:
*   It holds the raw message <code>payload</code> (as bytes).
*   It uses a fixed <code>SEGMENTSIZE</code> (128 bytes) for all network transmissions.
*   The <code>encapsulate()</code> method creates the 128-byte frame by writing the <code>payload</code> length in the first byte, followed by the <code>payload</code> itself.
*   The <code>decapsulate()</code> method extracts the original <code>payload</code> from a received 128-byte frame by reading the length from the first byte.</p>
<p>This framing ensures that the receiver can reliably reconstruct messages even when they arrive as part of a continuous byte stream.</p>
<p>Now that we understand how a single message is packaged into a <code>TransportMessage</code> frame, how are these frames actually sent and received over the network connection itself? In the next chapter, we'll explore <a href="../07_connection__network_stream_handling__/">Chapter 7: Connection (Network Stream Handling)</a> to see how the application manages the input and output streams for network communication.</p>
<hr/>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
<script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>