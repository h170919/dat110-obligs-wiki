
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../05_controller__ui_logic_coordinator__/">
      
      
        <link rel="next" href="../07_connection__network_stream_handling__/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Chapter 6: TransportMessage (Network Data Framing) - dat110 notes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-6-transportmessage-network-data-framing" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="dat110 notes" class="md-header__button md-logo" aria-label="dat110 notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            dat110 notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 6: TransportMessage (Network Data Framing)
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="dat110 notes" class="md-nav__button md-logo" aria-label="dat110 notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    dat110 notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tutorial: dat110-project2-javafx-chatapp
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01_message_hierarchy__communication_protocol__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 1: Message Hierarchy (Communication Protocol)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02_client__network_interaction_logic__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 2: Client (Network Interaction Logic)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03_chapp__application_entry_point__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 3: Chapp (Application Entry Point)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04_ui_areas__commandarea___messagearea__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 4: UI Areas (CommandArea &amp; MessageArea)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05_controller__ui_logic_coordinator__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 5: Controller (UI Logic Coordinator)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Chapter 6: TransportMessage (Network Data Framing)
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Chapter 6: TransportMessage (Network Data Framing)
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#the-problem-finding-message-boundaries-in-a-stream" class="md-nav__link">
    <span class="md-ellipsis">
      The Problem: Finding Message Boundaries in a Stream
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-solution-data-framing" class="md-nav__link">
    <span class="md-ellipsis">
      The Solution: Data Framing
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#our-standard-envelope-transportmessagejava" class="md-nav__link">
    <span class="md-ellipsis">
      Our Standard Envelope: TransportMessage.java
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fixed-packet-size-messageconfigsegmentsize" class="md-nav__link">
    <span class="md-ellipsis">
      Fixed Packet Size: MessageConfig.SEGMENTSIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#packing-the-envelope-encapsulate" class="md-nav__link">
    <span class="md-ellipsis">
      Packing the Envelope: encapsulate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opening-the-envelope-decapsulate" class="md-nav__link">
    <span class="md-ellipsis">
      Opening the Envelope: decapsulate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-it-fits-together" class="md-nav__link">
    <span class="md-ellipsis">
      How It Fits Together
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07_connection__network_stream_handling__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 7: Connection (Network Stream Handling)
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../08_messageutils__serialization_deserialization__/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 8: MessageUtils (Serialization/Deserialization)
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#the-problem-finding-message-boundaries-in-a-stream" class="md-nav__link">
    <span class="md-ellipsis">
      The Problem: Finding Message Boundaries in a Stream
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-solution-data-framing" class="md-nav__link">
    <span class="md-ellipsis">
      The Solution: Data Framing
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#our-standard-envelope-transportmessagejava" class="md-nav__link">
    <span class="md-ellipsis">
      Our Standard Envelope: TransportMessage.java
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fixed-packet-size-messageconfigsegmentsize" class="md-nav__link">
    <span class="md-ellipsis">
      Fixed Packet Size: MessageConfig.SEGMENTSIZE
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#packing-the-envelope-encapsulate" class="md-nav__link">
    <span class="md-ellipsis">
      Packing the Envelope: encapsulate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opening-the-envelope-decapsulate" class="md-nav__link">
    <span class="md-ellipsis">
      Opening the Envelope: decapsulate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-it-fits-together" class="md-nav__link">
    <span class="md-ellipsis">
      How It Fits Together
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="chapter-6-transportmessage-network-data-framing">Chapter 6: TransportMessage (Network Data Framing)</h1>
<p>In the <a href="../05_controller__ui_logic_coordinator__/">previous chapter</a>, we saw how the <code>Controller</code> acts as the application's director, taking requests from the UI (like sending a message) and telling the <code>Client</code> (<a href="../02_client__network_interaction_logic__/">Chapter 2</a>) what to do. The <code>Client</code> then prepares to send a message object (like a <code>PublishMsg</code> from <a href="../01_message_hierarchy__communication_protocol__/">Chapter 1</a>) over the network.</p>
<p>But how does that message object actually travel across the internet? Computers connected via a network send data as streams of raw bytes (ones and zeroes). If our <code>Client</code> just dumped all the bytes for <code>ConnectMsg</code>, then <code>PublishMsg</code>, then another <code>PublishMsg</code> into the stream, how would the <code>Server</code> know where one message ends and the next one starts?</p>
<h2 id="the-problem-finding-message-boundaries-in-a-stream">The Problem: Finding Message Boundaries in a Stream</h2>
<p>Imagine you're receiving a very long letter, but instead of arriving in an envelope, it arrives as one continuous ticker tape of letters with no spaces or punctuation. It would be impossible to read!</p>
<div class="highlight"><pre><span></span><code>HELLOWORLDHOWAREYOUIMFINEGOODBYE
</code></pre></div>
<p>Network communication is similar. Data arrives as a continuous stream of bytes. The receiver needs a way to figure out: "Okay, <em>these</em> specific bytes make up the first message, and <em>these next</em> bytes make up the second message." Without clear boundaries, the data is just a jumbled mess.</p>
<h2 id="the-solution-data-framing">The Solution: Data Framing</h2>
<p>To solve this, we use <strong>Data Framing</strong>. Think of it like putting each message into its own standard-sized envelope or small shipping box before sending it. This "frame" not only holds the message content (the "payload") but also adds some extra information, like a label on the outside.</p>
<p>In our chat application, the most important piece of information we add is the <strong>length of the payload</strong>.</p>
<p><strong>Analogy: The Standard Envelope</strong></p>
<p>Imagine you have messages of different lengths (a short note, a long letter).
1.  You get a standard-sized envelope (maybe it can hold up to 100 characters).
2.  You write your message (the payload). Let's say it's "Hi Bob!" (7 characters).
3.  You put the message inside the envelope.
4.  Crucially, on the <em>outside</em> of the envelope, you write: "Payload Length: 7".
5.  You send the envelope.</p>
<p>When your friend receives the standard-sized envelope, they don't need to guess where your message ends. They look at the label ("Payload Length: 7"), open the envelope, and read exactly the first 7 characters. They know those 7 characters constitute the complete message. Anything else in the envelope is just padding, and the <em>next</em> envelope they receive will contain the <em>next</em> message.</p>
<h2 id="our-standard-envelope-transportmessagejava">Our Standard Envelope: <code>TransportMessage.java</code></h2>
<p>In our project, the <code>TransportMessage</code> class acts as this standard envelope or frame. Its main job is to hold the raw data bytes of the <em>actual</em> message we want to send (like the bytes representing a <code>ConnectMsg</code> or <code>PublishMsg</code>) and provide methods to wrap (frame) and unwrap (unframe) this data.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TransportMessage</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// The actual message content (raw bytes)</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">payload</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Constructor: Creates a TransportMessage holding the payload</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">TransportMessage</span><span class="p">(</span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// We need to make sure the payload isn&#39;t too big for our &#39;envelope&#39;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MessageConfig</span><span class="p">.</span><span class="na">SEGMENTSIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// (+1 because we need space for the length byte itself)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;Payload too large for segment!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">payload</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Method to get the payload data back out</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="nf">getData</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">payload</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// ... (encapsulate and decapsulate methods coming next) ...</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong><code>private byte[] payload;</code></strong>: This is where the raw data of the original message (e.g., the serialized <code>PublishMsg</code>) is stored. How we get these bytes from a <code>PublishMsg</code> object is the job of <a href="../08_messageutils__serialization_deserialization__/">Chapter 8: MessageUtils (Serialization/Deserialization)</a>. For now, just know that <code>payload</code> holds the core message content as bytes.</li>
<li><strong><code>TransportMessage(byte[] payload)</code></strong>: The constructor takes these payload bytes and stores them. It also checks if the payload, plus the one extra byte we need for the length, will fit into our standard network packet size (<code>MessageConfig.SEGMENTSIZE</code>).</li>
</ul>
<h2 id="fixed-packet-size-messageconfigsegmentsize">Fixed Packet Size: <code>MessageConfig.SEGMENTSIZE</code></h2>
<p>Our network communication uses fixed-size packets, like using only one size of shipping box. This size is defined in <code>MessageConfig.java</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// File: src/main/java/no/hvl/dat110/messagetransport/MessageConfig.java</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MessageConfig</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// All our network &#39;envelopes&#39; will be exactly 128 bytes long</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">SEGMENTSIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Other network config (ignore for now)</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MESSAGINGPORT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8080</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">MESSAGINGHOST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;localhost&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong><code>SEGMENTSIZE = 128</code></strong>: This means every chunk of data sent or received over the network using our <code>TransportMessage</code> framing will be exactly 128 bytes.</li>
</ul>
<h2 id="packing-the-envelope-encapsulate">Packing the Envelope: <code>encapsulate()</code></h2>
<p>How do we take our <code>payload</code> and put it into the standard 128-byte frame, adding the length information? This process is called <strong>encapsulation</strong>.</p>
<p>The <code>encapsulate()</code> method in <code>TransportMessage</code> does this:</p>
<ol>
<li>Creates a new, empty byte array of exactly <code>SEGMENTSIZE</code> (128 bytes).</li>
<li>Calculates the length of the <code>payload</code>.</li>
<li>Writes this length value into the <em>very first byte</em> (index 0) of the 128-byte array.</li>
<li>Copies the actual <code>payload</code> bytes into the array, starting right <em>after</em> the length byte (at index 1).</li>
<li>Returns the filled 128-byte array. The rest of the array (after the payload) is just padding and doesn't matter.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java</span>

<span class="kd">public</span><span class="w"> </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="nf">encapsulate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">encoded</span><span class="p">;</span><span class="w"> </span><span class="c1">// This will be our 128-byte framed message</span>

<span class="w">    </span><span class="c1">// Create the empty 128-byte array</span>
<span class="w">    </span><span class="n">encoded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">byte</span><span class="o">[</span><span class="n">MessageConfig</span><span class="p">.</span><span class="na">SEGMENTSIZE</span><span class="o">]</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// --- The Framing Magic ---</span>
<span class="w">    </span><span class="c1">// 1. Put the length of the payload into the first byte</span>
<span class="w">    </span><span class="n">encoded</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="na">length</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 2. Copy the payload bytes starting from the second byte (index 1)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">payload</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">encoded</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">payload</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// --- End of Framing ---</span>

<span class="w">    </span><span class="c1">// Return the fully prepared 128-byte segment</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">encoded</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><code>encoded = new byte[MessageConfig.SEGMENTSIZE];</code>: Makes the 128-byte "envelope".</li>
<li><code>encoded[0] = (byte) (payload.length);</code>: Writes the payload length into the first byte. We cast to <code>byte</code> because the length must fit in a single byte (0-255), which is why <code>SEGMENTSIZE</code> (128) limits the maximum payload size (to 127 bytes + 1 length byte).</li>
<li><code>encoded[i + 1] = payload[i];</code>: Copies the payload bytes one by one into the <code>encoded</code> array, starting at index 1.</li>
</ul>
<p><strong>Visual Example:</strong>
If our payload is <code>[72, 101, 108, 108, 111]</code> (bytes for "Hello"), its length is 5. <code>encapsulate()</code> produces a 128-byte array like this:</p>
<div class="highlight"><pre><span></span><code>Byte Index:   0    1    2    3    4    5    6   ...   127
Value:      [ 5 | 72 |101 |108 |108 |111 | 0 | ... |  0 ]
             \-/ \---------------------/ \-------------/
            Length    Actual Payload       Padding (unused)
</code></pre></div>
<p>This 128-byte <code>encoded</code> array is what gets sent over the network by the <a href="../07_connection__network_stream_handling__/">Connection</a>.</p>
<h2 id="opening-the-envelope-decapsulate">Opening the Envelope: <code>decapsulate()</code></h2>
<p>When the receiver gets a 128-byte chunk of data from the network, how does it extract the original <code>payload</code>? This is called <strong>decapsulation</strong>.</p>
<p>The <code>decapsulate()</code> method does the reverse of <code>encapsulate()</code>:</p>
<ol>
<li>Takes the received 128-byte array (<code>received</code>) as input.</li>
<li>Reads the <em>first byte</em> (index 0) to find out the <code>length</code> of the original payload.</li>
<li>Uses this <code>length</code> to know exactly which bytes in the <code>received</code> array constitute the payload (from index 1 up to index <code>length</code>).</li>
<li>Copies <em>only</em> these payload bytes into the <code>TransportMessage</code> object's own <code>payload</code> field.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Arrays</span><span class="p">;</span><span class="w"> </span><span class="c1">// Needed for Arrays.copyOfRange</span>

<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">decapsulate</span><span class="p">(</span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">received</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// &#39;received&#39; is the 128-byte array from network</span>

<span class="w">    </span><span class="c1">// --- The Un-Framing Magic ---</span>
<span class="w">    </span><span class="c1">// 1. Read the payload length from the first byte</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">received</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 2. Extract the payload bytes from the received array</span>
<span class="w">    </span><span class="c1">//    Starts at index 1, and copies &#39;len&#39; bytes.</span>
<span class="w">    </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">copyOfRange</span><span class="p">(</span><span class="n">received</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// --- End of Un-Framing ---</span>

<span class="w">    </span><span class="c1">// Now, &#39;this.payload&#39; holds the original message bytes again!</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><code>int len = received[0];</code>: Gets the length stored in the first byte.</li>
<li><code>payload = Arrays.copyOfRange(received, 1, len + 1);</code>: This is a handy Java utility. It copies a portion of the <code>received</code> array.<ul>
<li><code>1</code>: Start copying from index 1 (where the payload begins).</li>
<li><code>len + 1</code>: Copy up to (but <em>not including</em>) this index. Since we start at 1 and want <code>len</code> bytes, the end index is <code>1 + len</code>.</li>
</ul>
</li>
<li>After this, the <code>payload</code> field of the <code>TransportMessage</code> object holds the extracted data.</li>
</ul>
<h2 id="how-it-fits-together">How It Fits Together</h2>
<p>Here's a simplified view of how <code>TransportMessage</code> is used when sending a message:</p>
<div class="highlight"><pre><span></span><code>sequenceDiagram
    participant Ctrl as Controller
    participant Cl as Client
    participant MU as MessageUtils
    participant TM as TransportMessage
    participant Conn as Connection
    participant Net as Network

    Note over Ctrl, Cl: User wants to publish &quot;Hello&quot; to &quot;general&quot;
    Ctrl-&gt;&gt;Cl: client.publish(&quot;general&quot;, &quot;Hello&quot;)
    Cl-&gt;&gt;Cl: Create PublishMsg(user, &quot;general&quot;, &quot;Hello&quot;)
    Cl-&gt;&gt;MU: MessageUtils.toTransportMessage(publishMsg)
    MU-&gt;&gt;MU: Serialize PublishMsg into byte[] payload (e.g., [72, 101, ...])
    MU-&gt;&gt;TM: new TransportMessage(payload)
    TM--&gt;&gt;MU: TransportMessage object created (holds payload)
    MU--&gt;&gt;Cl: Return TransportMessage object
    Cl-&gt;&gt;Conn: connection.send(transportMessage)
    Conn-&gt;&gt;TM: transportMessage.encapsulate()
    TM-&gt;&gt;TM: Create 128-byte array: [length | payload | padding]
    TM--&gt;&gt;Conn: Return 128-byte encoded array
    Conn-&gt;&gt;Net: Send 128 bytes over TCP stream
</code></pre></div>
<ol>
<li>The <code>Client</code> gets a <code>Message</code> object (like <code>PublishMsg</code>).</li>
<li>It asks <code>MessageUtils</code> (<a href="../08_messageutils__serialization_deserialization__/">Chapter 8</a>) to convert this object into a <code>TransportMessage</code>.</li>
<li><code>MessageUtils</code> first turns the <code>PublishMsg</code> into its raw byte <code>payload</code>.</li>
<li><code>MessageUtils</code> creates a <code>TransportMessage</code> containing this <code>payload</code>.</li>
<li>The <code>Client</code> tells the <code>Connection</code> (<a href="../07_connection__network_stream_handling__/">Chapter 7</a>) to send this <code>TransportMessage</code>.</li>
<li>The <code>Connection</code> calls <code>transportMessage.encapsulate()</code> to get the framed 128-byte array.</li>
<li>The <code>Connection</code> sends these 128 bytes over the network.</li>
</ol>
<p>Receiving works in reverse, with the <code>Connection</code> reading 128 bytes, creating an empty <code>TransportMessage</code>, calling <code>decapsulate()</code> on it, and then passing the <code>TransportMessage</code> (now containing the extracted payload) to <code>MessageUtils</code> to turn it back into a <code>PublishMsg</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We've learned that sending raw data over a network stream is problematic because the receiver doesn't know where messages start and end. <strong>Data Framing</strong> solves this by wrapping the message data (payload) in a structure that includes metadata, like the payload's length.</p>
<p>The <code>TransportMessage</code> class implements this framing in our project:
*   It holds the raw message <code>payload</code> (as bytes).
*   It uses a fixed <code>SEGMENTSIZE</code> (128 bytes) for all network transmissions.
*   The <code>encapsulate()</code> method creates the 128-byte frame by writing the <code>payload</code> length in the first byte, followed by the <code>payload</code> itself.
*   The <code>decapsulate()</code> method extracts the original <code>payload</code> from a received 128-byte frame by reading the length from the first byte.</p>
<p>This framing ensures that the receiver can reliably reconstruct messages even when they arrive as part of a continuous byte stream.</p>
<p>Now that we understand how a single message is packaged into a <code>TransportMessage</code> frame, how are these frames actually sent and received over the network connection itself? In the next chapter, we'll explore <a href="../07_connection__network_stream_handling__/">Chapter 7: Connection (Network Stream Handling)</a> to see how the application manages the input and output streams for network communication.</p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>