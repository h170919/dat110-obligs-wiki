{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li>DAT110 - Project 1: Socket Programming and RPC middleware</li> <li>DAT110 - Project 2: JavaFX-chatapp</li> <li>DAT110 - Project 3: DHT</li> </ul>"},{"location":"oblig1/01_rpc_client_stub_/","title":"Chapter 1: RPC Client Stub","text":"<p>Welcome to the first chapter of our tutorial for <code>dat110-project1-gruppe69</code>! We're going to build a small system where different parts talk to each other over a network. Let's start with a common problem: How can one program ask another program, possibly running on a different computer, to do something for it?</p> <p>Imagine you have a Controller application that needs to know the current temperature. This temperature reading comes from a Sensor application, which might be running on a separate device. How does the Controller ask the Sensor for the temperature? It sounds complicated, involving networks and sending data back and forth.</p> <p>This is where the RPC Client Stub comes in. RPC stands for Remote Procedure Call. The RPC Client Stub makes this network communication look like a simple, normal function call within your Controller program.</p>"},{"location":"oblig1/01_rpc_client_stub_/#what-is-an-rpc-client-stub","title":"What is an RPC Client Stub?","text":"<p>Think of an RPC Client Stub like a helpful local travel agent. You want to book a flight to another country (call a function on another computer). Instead of figuring out international phone lines, different time zones, and booking systems yourself (dealing with network details), you just talk to your local travel agent (the stub).</p> <p>You tell the agent, \"I want to fly to London on this date.\" (You call a method like <code>sensor.read()</code>). The agent takes your request, handles all the complex booking details with the airline (sends the request over the network), waits for confirmation (waits for the response), and then gives you your ticket (returns the result, like the temperature).</p> <p>So, the RPC Client Stub is:</p> <ol> <li>A Local Object: It lives inside your client application (e.g., the Controller).</li> <li>A Proxy/Stand-in: It pretends to be the remote service (e.g., the Sensor).</li> <li>A Network Hider: It takes care of packaging your request (marshalling), sending it over the network using the underlying RPC Client, receiving the response, and unpacking it (unmarshalling) for you.</li> </ol> <p>This makes your life as a programmer much easier!</p>"},{"location":"oblig1/01_rpc_client_stub_/#using-the-stub-making-remote-calls-look-local","title":"Using the Stub: Making Remote Calls Look Local","text":"<p>Let's look at how the Controller application uses a stub to get the temperature from the Sensor.</p> <pre><code>// Inside Controller.java (Simplified)\n\npublic class Controller {\n    public static void main(String[] args) {\n        // ... setup code ...\n\n        // Assume 'sensorclient' is an RPCClient connected to the Sensor server\n        RPCClient sensorclient = new RPCClient(Common.SENSORHOST, Common.SENSORPORT);\n        sensorclient.connect();\n\n        // Create the stub, giving it the RPCClient to use for communication\n        SensorStub sensor = new SensorStub(sensorclient);\n\n        // Now, call the 'read' method ON THE STUB as if it were local!\n        int currentTemperature = sensor.read();\n\n        System.out.println(\"Controller received temperature: \" + currentTemperature);\n\n        // ... cleanup code ...\n    }\n}\n</code></pre> <p>In this code: *   We create a <code>SensorStub</code> called <code>sensor</code>. *   We call <code>sensor.read()</code>. This looks exactly like calling a method on a normal Java object. *   The <code>SensorStub</code> handles all the networking behind the scenes. *   We get the temperature back as an integer, just like a regular method call.</p>"},{"location":"oblig1/01_rpc_client_stub_/#how-the-stub-works-under-the-hood","title":"How the Stub Works (Under the Hood)","text":"<p>So, what actually happens inside the <code>sensor.read()</code> call? Let's peek inside the <code>SensorStub.java</code> file.</p> <p>First, all client stubs in our project extend a base class called <code>RPCLocalStub</code>. This base class simply holds a reference to the RPC Client which is responsible for the actual network communication.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCLocalStub.java\npackage no.hvl.dat110.rpc;\n\n// Base class for all client-side stubs\npublic abstract class RPCLocalStub {\n\n    protected RPCClient rpcclient; // Holds the client that handles network calls\n\n    public RPCLocalStub(RPCClient rpcclient) {\n        this.rpcclient = rpcclient; // Store the RPCClient when stub is created\n    }\n}\n</code></pre> <p>Now, let's look at the <code>SensorStub</code> itself and its <code>read()</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/system/controller/SensorStub.java\npackage no.hvl.dat110.system.controller;\n\nimport no.hvl.dat110.rpc.*; // Import necessary RPC classes\n\npublic class SensorStub extends RPCLocalStub { // Extends the base stub class\n\n    // Constructor: receives the RPCClient and passes it to the base class\n    public SensorStub(RPCClient rpcclient) {\n        super(rpcclient);\n    }\n\n    // The method our Controller calls\n    public int read() {\n\n        // 1. Marshall parameters: 'read' takes no arguments (void).\n        // We still need to marshal this lack of arguments.\n        byte[] request = RPCUtils.marshallVoid();\n\n        // 2. Make the remote call: Tell the RPCClient to call the method\n        // identified by READ_RPCID, sending the marshalled 'void' parameter.\n        // The rpcclient handles sending/receiving over the network.\n        byte[] response = rpcclient.call((byte)Common.READ_RPCID, request);\n\n        // 3. Unmarshall the return value: The response byte array contains\n        // the marshalled integer (temperature). We need to convert it back.\n        int temp = RPCUtils.unmarshallInteger(response);\n\n        // 4. Return the result to the Controller\n        return temp;\n    }\n}\n</code></pre> <p>Let's break down the <code>read()</code> method step-by-step:</p> <ol> <li>Marshall Parameters: The <code>read()</code> method on the remote Sensor doesn't need any input data. However, the RPC system needs something to send. <code>RPCUtils.marshallVoid()</code> creates a standardized empty byte array representing \"no parameters\". We'll learn more about marshalling in RPC Data Marshalling/Unmarshalling.</li> <li>Invoke <code>rpcclient.call()</code>: This is the core step where the stub delegates the network communication. It calls the <code>call</code> method on the <code>rpcclient</code> object (which was passed into the stub's constructor).<ul> <li><code>Common.READ_RPCID</code>: This is a unique number (like an ID) that tells the server which method we want to run (in this case, the <code>read</code> method).</li> <li><code>request</code>: This is the marshalled data (the empty bytes for <code>void</code>) to send.</li> <li>The <code>rpcclient.call()</code> method (covered in RPC Client) handles sending the request ID and the data over the network and waits until it receives a response back from the server. It returns the raw bytes of the response.</li> </ul> </li> <li>Unmarshall Return Value: The server executed the <code>read</code> method, got the temperature (an integer), marshalled it into bytes, and sent it back. The <code>response</code> variable now holds these bytes. <code>RPCUtils.unmarshallInteger(response)</code> converts these bytes back into a Java <code>int</code>. Again, see RPC Data Marshalling/Unmarshalling for details.</li> <li>Return Result: The final integer <code>temp</code> is returned to the code that called <code>sensor.read()</code> (our <code>Controller</code>).</li> </ol> <p>Here's a simplified diagram showing the flow: <pre><code>sequenceDiagram\n    participant C as Controller\n    participant SS as SensorStub\n    participant RC as RPCClient\n    participant N as Network\n    participant RS as \"Remote Sensor (Server Side)\"\n\n    C-&gt;&gt;SS: read()\n    Note over SS: Prepare request (Marshall void)\n    SS-&gt;&gt;RC: call(READ_RPCID, requestBytes)\n    Note over RC: Handle network sending\n    RC-&gt;&gt;N: Send Request (ID + data)\n    N-&gt;&gt;RS: Receive Request\n    Note over RS: Find and run real read() method\n    RS-&gt;&gt;N: Send Response (Marshalled temperature)\n    Note over RC: Handle network receiving\n    N-&gt;&gt;RC: Receive Response\n    RC--&gt;&gt;SS: return responseBytes\n    Note over SS: Unpack response (Unmarshall integer)\n    SS--&gt;&gt;C: return temperature</code></pre></p>"},{"location":"oblig1/01_rpc_client_stub_/#conclusion","title":"Conclusion","text":"<p>The RPC Client Stub is a powerful abstraction. It acts as a local representative for a remote service, allowing your application code (like the <code>Controller</code>) to call methods on remote objects (like the <code>Sensor</code>) as if they were right there in the same program. It hides the complexities of marshalling data, network communication, and unmarshalling results.</p> <p>You've now seen how the client side initiates a remote call using a stub. But how does the server side receive this request and actually run the code? That's where the server-side counterpart comes in. In the next chapter, we'll look at the basic structure needed on the server to handle these incoming requests.</p> <p>Next up: RPC Server Implementation (Skeleton)</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/","title":"Chapter 2: RPC Server Implementation (Skeleton)","text":"<p>In the previous chapter, we saw how the RPC Client Stub acts like a local travel agent, making a request to a remote service (like getting the temperature from a Sensor) look like a simple local function call (<code>sensor.read()</code>).</p> <p>But what happens on the other side? When the request travels across the network and arrives at the Sensor application (the RPC Server), who actually handles it? How does the server know what to do and how to perform the requested action?</p> <p>That's where the RPC Server Implementation (Skeleton) comes in.</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#what-is-an-rpc-server-implementation-skeleton","title":"What is an RPC Server Implementation (Skeleton)?","text":"<p>Think back to our travel agent analogy from Chapter 1. You (the Controller) told your local agent (the Client Stub) you wanted the temperature. The agent sent the request over the network. Now, the request arrives at the \"remote travel agency\" (the RPC Server).</p> <p>The agency manager (the RPC Server) receives the request, which says \"Execute action #1\" (the <code>READ_RPCID</code>). The manager doesn't handle temperature readings directly. Instead, they look up who specializes in action #1 and forward the request to that specific department.</p> <p>This specialist department is the RPC Server Implementation (Skeleton). In our case, it's the <code>SensorImpl</code> object.</p> <p>So, the RPC Server Implementation (Skeleton) is:</p> <ol> <li>A Server-Side Object: It lives inside the server application (e.g., the Sensor application).</li> <li>A Specialist: It contains the actual code to perform a specific remote procedure (e.g., the real <code>read()</code> method that gets the temperature).</li> <li>An Action Handler: It knows how to unpack the request details (unmarshalling), run the correct code, and package the result (marshalling) to send back.</li> </ol> <p>It's the component that bridges the gap between a generic network request and the specific application logic that needs to run.</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#the-invoke-method-where-the-magic-happens","title":"The <code>invoke</code> Method: Where the Magic Happens","text":"<p>Every \"specialist department\" (Skeleton) needs a standard way for the manager (RPC Server) to give it work. In our project, this standard way is a method called <code>invoke</code>.</p> <p>Every Skeleton class (like <code>SensorImpl</code>) must:</p> <ol> <li>Extend <code>RPCRemoteImpl</code>: This is a base class that provides some common setup. We'll see it briefly later.</li> <li>Implement the <code>invoke</code> method: This method is the entry point for the RPC Server. When the server receives a request matching this skeleton's ID (like <code>READ_RPCID</code>), it calls this <code>invoke</code> method.</li> </ol> <p>What does the <code>invoke</code> method do?</p> <ol> <li>Receives Raw Data: It gets the parameters sent by the client stub as a chunk of raw bytes (<code>byte[]</code>).</li> <li>Unmarshalls Parameters: It uses helper functions (from RPC Data Marshalling/Unmarshalling) to convert these bytes back into meaningful data (like knowing the client wants to call <code>read</code> which takes no arguments).</li> <li>Calls the Real Method: It calls the actual application logic method within the same class (e.g., it calls the <code>read()</code> method inside <code>SensorImpl</code>).</li> <li>Gets the Result: It receives the return value from the real method (e.g., the integer temperature).</li> <li>Marshalls Return Value: It uses helper functions again to convert the return value back into raw bytes.</li> <li>Returns Raw Data: It gives the marshalled bytes back to the RPC Server, which will send them back over the network to the client.</li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#example-handling-the-read-request-in-sensorimpl","title":"Example: Handling the <code>read()</code> Request in <code>SensorImpl</code>","text":"<p>Let's look at how <code>SensorImpl.java</code> acts as the skeleton for the Sensor's <code>read</code> method.</p> <p>First, the base class <code>RPCRemoteImpl</code>: All skeletons extend this. Its main job in the constructor is to tell the main RPC Server \"Hey, I exist, and I handle requests with this specific ID.\"</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCRemoteImpl.java\npackage no.hvl.dat110.rpc;\n\npublic abstract class RPCRemoteImpl {\n\n    // Constructor called by subclasses (like SensorImpl)\n    public RPCRemoteImpl(byte rpcid, RPCServer rpcserver) {\n        // Register this implementation with the server,\n        // associating it with the given rpcid\n        rpcserver.register(rpcid, this);\n    }\n\n    // The method subclasses MUST implement to handle requests\n    public abstract byte[] invoke(byte[] params);\n}\n</code></pre> This code tells us that any class extending <code>RPCRemoteImpl</code> needs to provide its own <code>invoke</code> method. The constructor ensures the RPC Server knows which skeleton handles which ID.</p> <p>Now, the <code>SensorImpl</code> itself:</p> <pre><code>// File: src/main/java/no/hvl/dat110/system/sensor/SensorImpl.java\npackage no.hvl.dat110.system.sensor;\n\nimport no.hvl.dat110.rpc.*; // Import necessary RPC classes\n\npublic class SensorImpl extends RPCRemoteImpl { // Extends the base class\n\n    // Constructor: tells the base class its ID (READ_RPCID)\n    // and which RPCServer it belongs to.\n    public SensorImpl(byte rpcid, RPCServer rpcserver) {\n        super(rpcid, rpcserver); // Calls the RPCRemoteImpl constructor\n    }\n\n    // The ACTUAL application logic for reading the sensor\n    public int read() {\n        // Simulate getting a temperature reading\n        int temp = (int) Math.ceil(20 * Math.sin(System.currentTimeMillis() / 1000.0));\n        System.out.println(\"Sensor read temperature: \" + temp);\n        return temp;\n    }\n\n    // The invoke method called by the RPCServer for READ_RPCID\n    @Override\n    public byte[] invoke(byte[] param) {\n        // 1. Unmarshall Parameters: 'read' expects no arguments (void).\n        RPCUtils.unmarshallVoid(param); // Check param is correctly 'void'\n\n        // 2. Call the Real Method: Execute the actual sensor reading logic.\n        int temperature = read();\n\n        // 3. Marshall Return Value: Convert the integer result into bytes.\n        byte[] returnval = RPCUtils.marshallInteger(temperature);\n\n        // 4. Return marshalled bytes to the RPC Server\n        return returnval;\n    }\n}\n</code></pre> <p>Let's break down <code>SensorImpl</code>:</p> <ol> <li><code>extends RPCRemoteImpl</code>: Marks this as a server-side implementation skeleton.</li> <li>Constructor: When a <code>SensorImpl</code> object is created, it registers itself with the main RPC Server using the RPC ID provided (e.g., <code>Common.READ_RPCID</code>).</li> <li><code>read()</code> method: This is the actual Java method that performs the sensor reading. This is the core application logic. It returns a simple integer.</li> <li><code>invoke(byte[] param)</code> method: This is the method the RPC Server calls when a request with <code>Common.READ_RPCID</code> arrives.<ul> <li>It first unmarshalls the <code>param</code> byte array. Since <code>read()</code> takes no arguments, <code>RPCUtils.unmarshallVoid</code> just checks that the received parameters represent \"nothing\".</li> <li>It then calls the local <code>read()</code> method within the same <code>SensorImpl</code> object to get the actual temperature.</li> <li>It takes the integer <code>temperature</code> returned by <code>read()</code>.</li> <li>It marshalls this integer into a byte array using <code>RPCUtils.marshallInteger</code>. (More on this in RPC Data Marshalling/Unmarshalling).</li> <li>Finally, it returns the marshalled byte array. The RPC Server will take these bytes and send them back as the response.</li> </ul> </li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#how-the-rpc-server-uses-the-skeleton","title":"How the RPC Server Uses the Skeleton","text":"<p>Imagine the RPC Server receives a network message. It unpacks it and finds it's an RPC request with ID <code>1</code> (let's say <code>Common.READ_RPCID</code> is 1) and some parameter bytes.</p> <pre><code>sequenceDiagram\n    participant ClientStub as Client Stub\n    participant Network\n    participant RpcServer as RPC Server\n    participant Skeleton as SensorImpl (Skeleton)\n    participant AppLogic as SensorImpl.read()\n\n    ClientStub-&gt;&gt;Network: Send Request (ID=1, void_bytes)\n    Network-&gt;&gt;RpcServer: Receive Request (ID=1, void_bytes)\n    Note over RpcServer: Look up ID=1 -&gt; finds SensorImpl\n    RpcServer-&gt;&gt;Skeleton: invoke(void_bytes)\n    Note over Skeleton: Unmarshall void_bytes\n    Skeleton-&gt;&gt;AppLogic: Call real read() method\n    AppLogic--&gt;&gt;Skeleton: return temperature (e.g., 17)\n    Note over Skeleton: Marshall integer 17 -&gt; temp_bytes\n    Skeleton--&gt;&gt;RpcServer: return temp_bytes\n    RpcServer-&gt;&gt;Network: Send Response (temp_bytes)\n    Network-&gt;&gt;ClientStub: Receive Response (temp_bytes)</code></pre> <p>The RPC Server maintains a registry (a map) where it stored the <code>SensorImpl</code> object when it was created, associating it with <code>READ_RPCID</code>.</p> <ol> <li>The server sees the ID <code>1</code>.</li> <li>It looks in its registry and finds the <code>SensorImpl</code> object associated with ID <code>1</code>.</li> <li>It calls the <code>invoke</code> method on that specific <code>SensorImpl</code> object, passing the parameter bytes (<code>void_bytes</code>).</li> <li>The <code>SensorImpl.invoke</code> method does its work (unmarshall, call <code>read</code>, marshall result) and returns the result bytes (<code>temp_bytes</code>).</li> <li>The server takes these <code>temp_bytes</code> and sends them back over the network.</li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#conclusion","title":"Conclusion","text":"<p>The RPC Server Implementation (Skeleton), like <code>SensorImpl</code>, is the server-side specialist that handles a specific remote procedure call. It extends <code>RPCRemoteImpl</code> and implements the crucial <code>invoke</code> method. Inside <code>invoke</code>, it acts as a bridge: unmarshalling incoming request parameters, calling the actual application logic (like the real <code>read()</code> method), and marshalling the result to be sent back. It ensures that when a request arrives at the server, the correct piece of code is executed.</p> <p>We've now seen the client-side stub that initiates the call and the server-side skeleton that executes the call. But how does the message actually get from the stub to the server? We need components that manage the network connection and the sending/receiving of these requests and replies.</p> <p>Next up, we'll look at the client-side component responsible for managing this network communication: the RPC Client.</p>"},{"location":"oblig1/03_rpc_client_/","title":"Chapter 3: RPC Client","text":"<p>In the previous chapters, we met the RPC Client Stub (like <code>SensorStub</code>), which acts as a local stand-in for a remote service, making remote function calls look easy like <code>sensor.read()</code>. We also saw the RPC Server Implementation (Skeleton) (like <code>SensorImpl</code>), which contains the actual code on the server that performs the requested action.</p> <p>But there's a missing piece! How does the request from the Stub actually travel across the network to reach the server, and how does the response get back? The Stub itself doesn't handle the nitty-gritty network details. It delegates this task to another component: the RPC Client.</p>"},{"location":"oblig1/03_rpc_client_/#whats-the-problem-sending-the-message","title":"What's the Problem? Sending the Message!","text":"<p>Imagine our <code>SensorStub</code> wants to call the <code>read</code> method on the remote Sensor server. The Stub knows what to call (the <code>read</code> method, identified by <code>READ_RPCID</code>) and it prepares the \"no parameters\" message (<code>RPCUtils.marshallVoid()</code>). But how does it:</p> <ol> <li>Find the right server computer on the network?</li> <li>Establish a reliable communication channel?</li> <li>Send the request data (<code>READ_RPCID</code> + marshalled parameters)?</li> <li>Wait patiently for the server to process the request and send back a result?</li> <li>Receive the result data?</li> </ol> <p>This sounds like a lot of work involving network addresses, ports, sending/receiving bytes, and handling potential network issues. The Stub shouldn't worry about this; it just wants to make the call look simple.</p>"},{"location":"oblig1/03_rpc_client_/#the-rpc-client-your-personal-network-courier","title":"The RPC Client: Your Personal Network Courier","text":"<p>This is where the RPC Client comes in. Think of it as a dedicated network courier service that the RPC Client Stub uses.</p> <ul> <li>The Stub (Customer): Decides what needs to be done remotely (e.g., \"get temperature\"). It prepares the order form (marshalled request: RPC ID + parameters).</li> <li>The RPC Client (Courier Service): Takes the order form from the Stub. It knows the address of the remote shop (RPC Server). It handles establishing the delivery route (network connection), sends the order form (request), waits for the shop to prepare the item, picks up the packaged item (marshalled response), and delivers it back to the Stub.</li> <li>The Network (Roads/Mail System): The underlying infrastructure used by the courier.</li> <li>The RPC Server (Remote Shop): Receives the order, processes it, and gives the result back to the courier.</li> </ul> <p>So, the RPC Client is:</p> <ol> <li>A Connection Manager: It's responsible for connecting to a specific RPC Server at a known network address and port.</li> <li>A Request/Reply Handler: It provides a <code>call</code> method that takes the details from the Stub, sends them over the network, waits for the response, and returns it.</li> <li>A Messaging Layer User: It doesn't handle raw network sockets directly. Instead, it relies on the lower-level Messaging Connection to do the actual sending and receiving of byte sequences.</li> </ol>"},{"location":"oblig1/03_rpc_client_/#how-the-stub-uses-the-rpc-client","title":"How the Stub Uses the RPC Client","text":"<p>Remember this line from <code>SensorStub.java</code>?</p> <pre><code>// Inside SensorStub.read()\n// ... marshall parameters ...\nbyte[] response = rpcclient.call((byte)Common.READ_RPCID, request);\n// ... unmarshall response ...\n</code></pre> <p>Here's what's happening:</p> <ol> <li>The <code>SensorStub</code> has an instance of <code>RPCClient</code> (named <code>rpcclient</code>) that was given to it when it was created. This <code>rpcclient</code> object is already configured to talk to the Sensor server.</li> <li>The stub calls the <code>call</code> method on its <code>rpcclient</code> object.</li> <li>It passes two things to <code>call</code>:<ul> <li><code>Common.READ_RPCID</code>: The unique number identifying the remote <code>read</code> method.</li> <li><code>request</code>: The marshalled parameters (in this case, the bytes representing \"no parameters\").</li> </ul> </li> <li>The stub then waits. The <code>rpcclient.call()</code> method will not return until it gets a response back from the server.</li> <li>When <code>rpcclient.call()</code> finally returns, it gives back the raw byte array (<code>response</code>) containing the marshalled result (the temperature) sent by the server.</li> </ol> <p>The <code>RPCClient</code> object handles all the communication steps in between.</p>"},{"location":"oblig1/03_rpc_client_/#inside-the-rpc-client-connecting-and-calling","title":"Inside the RPC Client: Connecting and Calling","text":"<p>Let's peek inside <code>RPCClient.java</code> to see how it works.</p> <p>1. Connecting to the Server (<code>connect</code>)</p> <p>Before the Stub can make any calls, the <code>RPCClient</code> needs to establish a connection to the RPC Server. This usually happens once when the client application starts up.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCClient.java (Simplified)\npackage no.hvl.dat110.rpc;\n\nimport no.hvl.dat110.messaging.*;\n\npublic class RPCClient {\n\n    // Holds the connection details and methods for sending/receiving messages\n    private MessagingClient msgclient;\n    private MessageConnection connection;\n\n    // Constructor: remembers server address and port\n    public RPCClient(String server, int port) {\n        // Creates a client object from the messaging layer\n        msgclient = new MessagingClient(server, port);\n    }\n\n    // Establishes the actual network connection\n    public void connect() {\n        // Use the messaging client to connect and store the connection\n        connection = msgclient.connect();\n        // Now we have an active link to the server!\n    }\n\n    // ... call method is next ...\n\n    // Closes the network connection\n    public void disconnect() {\n        // Close the underlying messaging connection\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}\n</code></pre> <ul> <li>The constructor just stores the server's address (<code>server</code>, <code>port</code>) by creating a <code>MessagingClient</code> (from the Messaging Connection layer).</li> <li>The <code>connect()</code> method is the important part here. It calls <code>msgclient.connect()</code>. This tells the underlying messaging layer to actually create a network connection (like a TCP socket connection) to the specified server and port.</li> <li>The established connection is stored in the <code>connection</code> variable. This <code>connection</code> object is what we'll use to send and receive messages.</li> </ul> <p>2. Making the Remote Call (<code>call</code>)</p> <p>This is the core method used by the Stubs. It orchestrates the request-reply interaction.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCClient.java (Simplified call method)\n\npublic class RPCClient {\n    // ... constructor, connect, disconnect, connection variable ...\n\n    public byte[] call(byte rpcid, byte[] params) {\n\n        // 1. Package the request: Combine RPC ID and parameters into\n        //    a single byte array using a standard format.\n        //    (See RPC Data Marshalling/Unmarshalling chapter for details)\n        byte[] requestData = RPCUtils.encapsulate(rpcid, params);\n\n        // 2. Create a Message object (from the messaging layer)\n        Message requestMessage = new Message(requestData);\n\n        // 3. Send the message over the established connection\n        connection.send(requestMessage);\n\n        // 4. Wait to receive the reply message from the server\n        Message replyMessage = connection.receive();\n\n        // 5. Unpack the reply: Extract the actual result bytes\n        //    from the received message format.\n        //    (See RPC Data Marshalling/Unmarshalling chapter for details)\n        byte[] returnval = RPCUtils.decapsulate(replyMessage.getData());\n\n        // 6. Return the marshalled result bytes to the Stub\n        return returnval;\n    }\n}\n</code></pre> <p>Let's break down the <code>call</code> method:</p> <ol> <li>Encapsulate Request: It takes the <code>rpcid</code> (e.g., <code>READ_RPCID</code>) and the marshalled <code>params</code> (e.g., the \"void\" bytes) and combines them into a single byte array (<code>requestData</code>) using <code>RPCUtils.encapsulate</code>. This follows a specific format that the server will understand (we'll cover this format in RPC Data Marshalling/Unmarshalling).</li> <li>Create Message: It wraps the <code>requestData</code> into a <code>Message</code> object. This is required by the underlying Messaging Connection layer.</li> <li>Send Message: It uses the <code>connection.send()</code> method (from the messaging layer) to transmit the <code>requestMessage</code> over the network to the server.</li> <li>Receive Reply: It calls <code>connection.receive()</code>. This method blocks \u2013 it waits until data arrives back from the server on the same connection. When data arrives, <code>receive()</code> returns it as a <code>Message</code> object (<code>replyMessage</code>).</li> <li>Decapsulate Reply: It extracts the payload data from the <code>replyMessage</code> using <code>replyMessage.getData()</code> and then uses <code>RPCUtils.decapsulate</code> to remove the RPC protocol framing, leaving just the marshalled return value (<code>returnval</code>) sent by the server. (Again, see RPC Data Marshalling/Unmarshalling).</li> <li>Return Result: It returns the <code>returnval</code> (the raw bytes of the result) back to the calling code (the <code>SensorStub</code>).</li> </ol>"},{"location":"oblig1/03_rpc_client_/#the-flow-from-stub-to-server-and-back","title":"The Flow: From Stub to Server and Back","text":"<p>Here's a diagram showing the RPC Client's role in the communication:</p> <pre><code>sequenceDiagram\n    participant Stub as SensorStub\n    participant RPC_Client as RPCClient\n    participant MsgConn as \"Messaging Connection\"\n    participant Network\n    participant RPC_Server as \"RPC Server (High Level)\"\n\n    Stub-&gt;&gt;RPC_Client: call(READ_RPCID, void_params)\n    Note over RPC_Client: Encapsulate(READ_RPCID, void_params) \u2192 request_bytes\n    RPC_Client-&gt;&gt;MsgConn: send(new Message(request_bytes))\n    Note over MsgConn: Send request_bytes over TCP socket\n    MsgConn-&gt;&gt;Network: Send request data\n    Network-&gt;&gt;RPC_Server: Request arrives\n    Note over RPC_Server: Server processes request (unpacks, calls SensorImpl.invoke, gets result)\n    Note over RPC_Server: Server encapsulates result \u2192 reply_bytes\n    RPC_Server-&gt;&gt;Network: Send reply data (reply_bytes)\n    Network-&gt;&gt;MsgConn: Receive reply data\n    Note over MsgConn: Receive reply_bytes via TCP socket\n    MsgConn--&gt;&gt;RPC_Client: return new Message(reply_bytes)\n    Note over RPC_Client: Decapsulate(reply_bytes) \u2192 result_bytes (temp)\n    RPC_Client--&gt;&gt;Stub: return result_bytes</code></pre> <p>This shows the <code>RPCClient</code> acting as the middleman between the high-level <code>Stub</code> and the lower-level <code>Messaging Connection</code>. It packages the request, sends it, waits for the reply, and unpacks it.</p>"},{"location":"oblig1/03_rpc_client_/#conclusion","title":"Conclusion","text":"<p>The RPC Client is the engine that powers the client-side of our RPC system. It manages the network connection to a specific server and implements the core <code>call</code> method used by stubs. This <code>call</code> method handles the full cycle: packaging the request (encapsulation), sending it using the underlying Messaging Connection, waiting for the reply, and unpacking the result (decapsulation). It effectively hides the complexities of network communication from the RPC Client Stub, allowing the stub to focus on providing a simple, local-like interface for remote procedures.</p> <p>Now that we understand how the client side sends requests and receives replies, we need to look at the server component that listens for these incoming connections and dispatches the requests to the correct RPC Server Implementation (Skeleton).</p> <p>Next up: RPC Server</p>"},{"location":"oblig1/04_rpc_server_/","title":"Chapter 4: RPC Server","text":"<p>In the previous chapter, we saw how the RPC Client acts like a courier, taking a request from the RPC Client Stub (like \"get temperature\"), sending it across the network, and bringing back the response.</p> <p>But who is on the other side receiving these requests? When the <code>RPCClient</code> sends a message to the Sensor application's address, who is listening? And once the message arrives, how does the Sensor application know which piece of code (like the <code>read()</code> method in <code>SensorImpl</code>) should handle it?</p> <p>This is the job of the RPC Server.</p>"},{"location":"oblig1/04_rpc_server_/#whats-the-problem-receiving-and-directing-traffic","title":"What's the Problem? Receiving and Directing Traffic","text":"<p>Imagine our Sensor application. It has the <code>SensorImpl</code> object, which knows how to actually read the temperature (as discussed in RPC Server Implementation (Skeleton)). However, <code>SensorImpl</code> itself doesn't know anything about network connections or listening for incoming messages.</p> <p>We need a central component within the Sensor application that acts like a receptionist or a shop manager:</p> <ol> <li>Listens: Constantly waits for new clients (like the Controller's <code>RPCClient</code>) to connect.</li> <li>Receives Orders: Accepts incoming request messages sent by clients.</li> <li>Understands the Order: Looks at the request message to figure out which specific action the client wants (e.g., \"execute action #1\", which corresponds to <code>READ_RPCID</code>).</li> <li>Delegates: Finds the correct specialist (the <code>SensorImpl</code> object registered for <code>READ_RPCID</code>) to handle the request.</li> <li>Forwards Request: Gives the request details (parameters) to the specialist's <code>invoke</code> method.</li> <li>Collects Result: Gets the result (the temperature bytes) back from the specialist.</li> <li>Sends Back Reply: Packages the result into a reply message and sends it back to the client who made the request.</li> </ol> <p>This central receptionist is the RPC Server.</p>"},{"location":"oblig1/04_rpc_server_/#the-rpc-server-the-shop-manager","title":"The RPC Server: The Shop Manager","text":"<p>Think of the RPC Server like the manager of our remote Sensor \"shop\".</p> <ul> <li>The Shop Entrance: The RPC Server opens the shop doors (starts listening on a specific network port using the underlying Messaging Connection layer).</li> <li>Receiving Customers: When a customer (an <code>RPCClient</code>) arrives, the manager establishes a connection.</li> <li>Taking Orders: The customer hands over an order form (an RPC request message containing an ID like <code>READ_RPCID</code> and any parameters).</li> <li>Finding the Right Department: The manager looks at the order ID (<code>READ_RPCID</code>) and knows that the \"Temperature Reading Department\" (<code>SensorImpl</code> object) handles this.</li> <li>Dispatching: The manager takes the order details (parameters) to the <code>SensorImpl</code> department and asks it to process the order (calls its <code>invoke</code> method).</li> <li>Getting the Product: The <code>SensorImpl</code> department finishes its work and gives the packaged product (marshalled temperature bytes) back to the manager.</li> <li>Returning to Customer: The manager sends the product (the reply message) back to the waiting customer (<code>RPCClient</code>).</li> </ul> <p>The RPC Server orchestrates the entire process on the server side, ensuring requests are received, routed correctly, executed, and the results are returned.</p>"},{"location":"oblig1/04_rpc_server_/#how-the-rpc-server-works","title":"How the RPC Server Works","text":"<p>The <code>RPCServer</code> relies heavily on the lower-level Messaging Connection layer to handle the actual network communication (listening for connections, sending/receiving bytes). Its main job is to manage the RPC logic on top of that.</p> <p>1. Registration: Knowing Who Does What</p> <p>Before the server can handle any requests, it needs to know which \"specialist department\" (RPC Server Implementation (Skeleton)) handles which task (RPC ID). This happens through a <code>register</code> method.</p> <p>When the Sensor application starts, it creates the <code>SensorImpl</code> object. The <code>SensorImpl</code> constructor calls the <code>RPCServer</code>'s <code>register</code> method.</p> <pre><code>// Inside SensorDevice.java (Simplified Startup)\npublic static void main(String[] args) {\n    // Create the main RPC Server listening on the Sensor port\n    RPCServer sensorserver = new RPCServer(Common.SENSORPORT);\n\n    // Create the SensorImpl specialist. Its constructor will register it.\n    // It tells the server: \"I handle requests with ID = READ_RPCID\"\n    SensorImpl sensor = new SensorImpl((byte)Common.READ_RPCID, sensorserver);\n\n    // Start the server's main loop\n    sensorserver.run();\n    // ... stop server ...\n}\n</code></pre> <p>Let's look at the <code>RPCServer</code>'s <code>register</code> method and how it stores this information:</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCServer.java (Partial)\npackage no.hvl.dat110.rpc;\n\nimport java.util.HashMap;\nimport no.hvl.dat110.messaging.*; // Import messaging classes\n\npublic class RPCServer {\n\n    private MessagingServer msgserver; // From the Messaging Layer\n    private MessageConnection connection; // Represents a client connection\n\n    // A map to store the registered specialists (Skeletons)\n    // Key: RPC ID (byte), Value: The Skeleton object (RPCRemoteImpl)\n    private HashMap&lt;Byte, RPCRemoteImpl&gt; services;\n\n    // Constructor: Creates the underlying messaging server and the map\n    public RPCServer(int port) {\n        this.msgserver = new MessagingServer(port); // Setup listener\n        this.services = new HashMap&lt;Byte, RPCRemoteImpl&gt;(); // Prepare the registry\n    }\n\n    // Called by Skeletons (like SensorImpl) to register themselves\n    public void register(byte rpcid, RPCRemoteImpl impl) {\n        System.out.println(\"Registering service: RPC ID = \" + rpcid);\n        services.put(rpcid, impl); // Store: ID -&gt; Specialist Object\n    }\n\n    // ... run method is next ...\n    // ... stop method ...\n}\n</code></pre> <ul> <li>The <code>RPCServer</code> keeps a <code>HashMap</code> called <code>services</code>. Think of this map as the manager's directory.</li> <li>The <code>register</code> method takes the <code>rpcid</code> (like <code>Common.READ_RPCID</code>) and the actual specialist object (<code>impl</code>, which is the <code>SensorImpl</code> instance) and puts them into the <code>services</code> map. Now, the server knows that requests for <code>READ_RPCID</code> should go to that specific <code>SensorImpl</code> object.</li> </ul> <p>2. Running the Server: The Main Loop</p> <p>The <code>run()</code> method is where the RPC Server starts its main job of listening and processing requests.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCServer.java (Simplified run method)\npublic class RPCServer {\n    // ... constructor, register, services map, msgserver ...\n\n    public void run() {\n        // Special case: Register the built-in \"stop\" service (RPC ID 0)\n        RPCRemoteImpl rpcstop = new RPCServerStopImpl(RPCCommon.RPIDSTOP, this);\n\n        System.out.println(\"RPC SERVER starting to listen...\");\n\n        // 1. Wait for a client to connect (using the messaging layer)\n        connection = msgserver.accept(); // Blocks until a client connects\n        System.out.println(\"RPC SERVER accepted connection\");\n\n        boolean stop = false; // Flag to control the loop\n        while (!stop) {\n            Message requestmsg = null;\n            byte rpcid = 0;\n\n            try {\n                // 2. Receive a request message from the connected client\n                requestmsg = connection.receive(); // Blocks until message arrives\n\n                // 3. Extract the RPC ID (the first byte of the message data)\n                byte[] requestData = requestmsg.getData();\n                rpcid = requestData[0]; // Peek at the first byte for the ID\n\n                // 4. Decapsulate: Get the parameters (remove the ID byte)\n                // (Details in RPC Data Marshalling/Unmarshalling chapter)\n                byte[] params = RPCUtils.decapsulate(requestData);\n\n                // 5. Lookup: Find the specialist for this RPC ID\n                RPCRemoteImpl specialist = services.get(rpcid);\n\n                // 6. Invoke: Ask the specialist to handle the request\n                byte[] result = specialist.invoke(params); // The specialist does the real work!\n\n                // 7. Encapsulate: Package the result with the RPC ID\n                // (Details in RPC Data Marshalling/Unmarshalling chapter)\n                byte[] replyData = RPCUtils.encapsulate(rpcid, result);\n\n                // 8. Send Reply: Send the result back to the client\n                Message replymsg = new Message(replyData);\n                connection.send(replymsg);\n\n            } catch (Exception e) {\n                System.err.println(\"RPC Server Error: \" + e.getMessage());\n                e.printStackTrace();\n                stop = true; // Stop on error\n            }\n\n            // Check if the received RPC ID was the special \"stop\" command\n            if (rpcid == RPCCommon.RPIDSTOP) {\n                System.out.println(\"RPC SERVER received stop command.\");\n                stop = true;\n            }\n        }\n    }\n    // ... stop method ...\n}\n</code></pre> <p>Let's break down the <code>run()</code> loop:</p> <ol> <li>Accept Connection: <code>msgserver.accept()</code> tells the underlying Messaging Connection layer to wait for a client to connect. This call blocks (pauses) until a connection is made. The resulting <code>connection</code> object represents the communication link to that specific client.</li> <li>Receive Request: Inside the <code>while</code> loop, <code>connection.receive()</code> waits for a message to arrive from the connected client. This also blocks. When a message arrives, it's stored in <code>requestmsg</code>.</li> <li>Extract RPC ID: The first byte of the data within the message (<code>requestmsg.getData()</code>) is assumed to be the <code>rpcid</code> identifying the desired remote procedure.</li> <li>Decapsulate Parameters: <code>RPCUtils.decapsulate()</code> takes the raw message data and extracts the actual parameters meant for the remote method, removing the <code>rpcid</code> byte. (We'll cover <code>decapsulate</code> in the RPC Data Marshalling/Unmarshalling chapter).</li> <li>Lookup Specialist: <code>services.get(rpcid)</code> uses the extracted <code>rpcid</code> to look up the corresponding specialist object (e.g., the <code>SensorImpl</code> instance) in the <code>services</code> map we filled during registration.</li> <li>Invoke Specialist: The crucial step! <code>specialist.invoke(params)</code> calls the <code>invoke</code> method on the found specialist object (e.g., <code>SensorImpl.invoke(...)</code>), passing the extracted parameters. This is where the skeleton unmarshalls the parameters, calls the real application logic (<code>SensorImpl.read()</code>), gets the result, marshalls it, and returns the marshalled result bytes.</li> <li>Encapsulate Reply: <code>RPCUtils.encapsulate()</code> takes the result bytes returned by <code>invoke</code> and packages them back into the standard RPC message format, adding the original <code>rpcid</code> back. (Covered in RPC Data Marshalling/Unmarshalling).</li> <li>Send Reply: A new <code>Message</code> is created with the encapsulated reply data, and <code>connection.send()</code> sends it back to the client over the network.</li> <li>Stop Condition: The loop continues receiving and processing requests until the special <code>RPIDSTOP</code> command (RPC ID 0) is received, which sets the <code>stop</code> flag to <code>true</code> and ends the loop.</li> </ol>"},{"location":"oblig1/04_rpc_server_/#the-big-picture-request-flow","title":"The Big Picture: Request Flow","text":"<p>Here's a diagram showing the RPC Server's role in handling a <code>read()</code> request:</p> <pre><code>sequenceDiagram\n    participant Client as RPC Client (Controller)\n    participant Network\n    participant MsgServer as MessagingServer (Sensor)\n    participant RpcSrv as RPC Server (Sensor)\n    participant Skeleton as SensorImpl (Sensor)\n\n    Client-&gt;&gt;Network: Send Request (ID=READ_RPCID, void_params)\n    Network-&gt;&gt;MsgServer: Data arrives on listening socket\n    MsgServer-&gt;&gt;RpcSrv: accept() returns connection\n    Note over RpcSrv: Starts run() loop\n    MsgServer-&gt;&gt;RpcSrv: receive() returns Message(requestData)\n    Note over RpcSrv: Extracts ID=READ_RPCID\n    Note over RpcSrv: Decapsulates void_params\n    Note over RpcSrv: Looks up ID -&gt; finds SensorImpl\n    RpcSrv-&gt;&gt;Skeleton: invoke(void_params)\n    Note over Skeleton: Unmarshalls, calls read(), Marshalls result\n    Skeleton--&gt;&gt;RpcSrv: return temp_bytes\n    Note over RpcSrv: Encapsulates temp_bytes with ID\n    RpcSrv-&gt;&gt;MsgServer: send(Message(replyData))\n    MsgServer-&gt;&gt;Network: Send reply data\n    Network-&gt;&gt;Client: Receive Reply (temp_bytes)</code></pre> <p>The <code>RPCServer</code> acts as the central dispatcher, taking incoming network messages facilitated by the <code>MessagingServer</code>, understanding the RPC request within, delegating the work to the correct <code>Skeleton</code>, and ensuring the reply gets sent back.</p>"},{"location":"oblig1/04_rpc_server_/#conclusion","title":"Conclusion","text":"<p>The RPC Server is the heart of the server-side RPC mechanism. It listens for incoming client connections using the underlying Messaging Connection layer. For each connected client, it enters a loop where it receives request messages, identifies the target procedure using the RPC ID, looks up the registered RPC Server Implementation (Skeleton), calls its <code>invoke</code> method, and sends the marshalled result back in a reply message. It's the essential coordinator that makes remote procedure calls possible from the server's perspective.</p> <p>We've seen how the RPC Client and Server use <code>encapsulate</code> and <code>decapsulate</code>, and how Stubs and Skeletons use <code>marshall</code> and <code>unmarshall</code>. But what do these functions actually do? How is data like integers, strings, or even \"nothing\" (void) converted into bytes and back again? That's the topic of our next chapter.</p> <p>Next up: RPC Data Marshalling/Unmarshalling</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/","title":"Chapter 5: RPC Data Marshalling/Unmarshalling","text":"<p>In the previous chapter, we saw how the RPC Server acts as the central receptionist on the server side, receiving requests and dispatching them to the correct specialist (like <code>SensorImpl</code>). We noticed that both the RPC Client and RPC Server, as well as the Stubs and Skeletons, frequently use helper functions from <code>RPCUtils</code> like <code>marshallInteger</code>, <code>unmarshallString</code>, <code>encapsulate</code>, and <code>decapsulate</code>.</p> <p>But what do these functions actually do? When the <code>SensorStub</code> wants to send a request to read the temperature, it doesn't need any parameters. It calls <code>RPCUtils.marshallVoid()</code>. When it gets the response, it calls <code>RPCUtils.unmarshallInteger()</code> to get the temperature value. How does Java data like an <code>int</code> or even \"nothing\" (void) get turned into bytes that can be sent over the network, and how are bytes turned back into useful Java data?</p> <p>This process of converting data between its friendly Java form and a network-friendly byte form is called Marshalling and Unmarshalling.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#what-is-marshallingunmarshalling-its-like-packing-boxes","title":"What is Marshalling/Unmarshalling? It's Like Packing Boxes!","text":"<p>Imagine you want to send a fragile vase (your Java data, like an <code>int</code> or a <code>String</code>) through the mail (the network). You can't just slap a stamp on the vase and hope for the best!</p> <ol> <li>Marshalling (Packing): You need to carefully wrap the vase in bubble wrap and put it into a standard-sized cardboard box (a <code>byte[]</code> array). This process of converting your specific item (Java data) into a standardized package (byte array) suitable for shipping is marshalling.</li> <li>Unmarshalling (Unpacking): When the box arrives at its destination, the recipient opens the box and carefully unwraps the bubble wrap to get the original vase back. This process of converting the standardized package (byte array) back into the specific item (Java data) is unmarshalling.</li> </ol> <p>So, in our RPC world: *   Marshalling: Converts Java data types (like <code>int</code>, <code>String</code>, <code>boolean</code>, or even <code>void</code>) into a sequence of bytes (<code>byte[]</code>). *   Unmarshalling: Converts a sequence of bytes (<code>byte[]</code>) back into the original Java data type.</p> <p>This is essential because networks primarily understand how to send and receive streams of raw bytes, not complex Java objects directly.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#marshallingunmarshalling-specific-data-types-rpcutils","title":"Marshalling/Unmarshalling Specific Data Types (<code>RPCUtils</code>)","text":"<p>The <code>RPCUtils.java</code> class provides helper functions to pack (marshall) and unpack (unmarshall) the specific data types we support in our simple RPC system: <code>int</code>, <code>String</code>, <code>boolean</code>, and <code>void</code>.</p> <p>Let's look at a couple of examples:</p> <p>Integers:</p> <p>An integer (<code>int</code>) in Java usually takes up 4 bytes of memory. Marshalling converts this 4-byte representation into a <code>byte[]</code> array of length 4. Unmarshalling does the reverse.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Integer Marshalling)\n\nimport java.nio.ByteBuffer; // Used for easy conversion\n\npublic class RPCUtils {\n\n    // integer to byte array representation\n    public static byte[] marshallInteger(int x) {\n        // Create a buffer that can hold exactly 4 bytes (size of an int)\n        ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);\n        // Put the integer into the buffer\n        buffer.putInt(x);\n        // Get the underlying byte array from the buffer\n        byte[] encoded = buffer.array();\n        return encoded;\n    }\n\n    // byte array representation to integer\n    public static int unmarshallInteger(byte[] data) {\n        // Wrap the incoming byte array into a buffer\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        // Read an integer from the buffer\n        int decoded = buffer.getInt();\n        return decoded;\n    }\n    // ... other marshall/unmarshall methods ...\n}\n</code></pre> *   <code>marshallInteger</code>: Uses Java's <code>ByteBuffer</code> to easily convert the <code>int</code> into a 4-byte array. *   <code>unmarshallInteger</code>: Uses <code>ByteBuffer</code> again to read 4 bytes from the input <code>data</code> array and interpret them as an <code>int</code>.</p> <p>Strings:</p> <p>Strings are sequences of characters. Marshalling converts the string into a byte array using a standard character encoding (like UTF-8). Unmarshalling converts the byte array back into a string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified String Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    // convert String to byte array\n    public static byte[] marshallString(String str) {\n        // Use the built-in String method to get bytes (usually UTF-8)\n        byte[] encoded = str.getBytes();\n        return encoded;\n    }\n\n    // convert byte array to a String\n    public static String unmarshallString(byte[] data) {\n        // Use the String constructor that takes bytes\n        String decoded = new String(data);\n        return decoded;\n    }\n    // ... other methods ...\n}\n</code></pre> *   <code>marshallString</code>: Simply uses the <code>getBytes()</code> method available on all Java strings. *   <code>unmarshallString</code>: Uses the <code>String</code> constructor that accepts a byte array.</p> <p>Void (Nothing):</p> <p>Sometimes, a remote method doesn't need any parameters (like <code>read()</code>) or doesn't return anything (like <code>write()</code>). How do we marshall \"nothing\"? We represent it as an empty byte array (<code>new byte[0]</code>).</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Void Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    public static byte[] marshallVoid() {\n        // Return an array with zero bytes\n        return new byte[0];\n    }\n\n    public static void unmarshallVoid(byte[] data) {\n        // Just check that the received data is indeed empty\n        if (data.length != 0) {\n            throw new IllegalArgumentException(\"Expected void (empty data), but received data.\");\n        }\n        // No value to return!\n    }\n    // ... other methods ...\n}\n</code></pre> *   <code>marshallVoid</code>: Creates and returns a zero-length byte array. *   <code>unmarshallVoid</code>: Doesn't return anything, but it checks if the received byte array is empty, throwing an error if it's not.</p> <p>Booleans:</p> <p>A boolean (<code>true</code> or <code>false</code>) can be represented by a single byte. For example, <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Boolean Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    // convert boolean to a byte array representation\n    public static byte[] marshallBoolean(boolean b) {\n        byte[] encoded = new byte[1];\n        encoded[0] = (b ? (byte)1 : (byte)0); // 1 if true, 0 if false\n        return encoded;\n    }\n\n    // convert byte array to a boolean representation\n    public static boolean unmarshallBoolean(byte[] data) {\n        // True if the byte is not 0\n        return (data[0] != 0);\n    }\n    // ... other methods ...\n}\n</code></pre> <p>These marshalling/unmarshalling functions are used by the RPC Client Stub and the RPC Server Implementation (Skeleton) to prepare parameters and interpret return values.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#rpc-message-structure-encapsulationdecapsulation","title":"RPC Message Structure: Encapsulation/Decapsulation","text":"<p>Okay, so we know how to pack the \"vase\" (our data like an <code>int</code>) into a box (<code>byte[]</code>). But when we send this box over the network, the receiver needs to know what this box is for. Is it the result of a <code>read</code> call? Is it the parameter for a <code>write</code> call?</p> <p>The raw marshalled data (like the 4 bytes for an integer) isn't enough. We need to add a label to the box: the RPC ID. This ID tells the server which remote method the message relates to (e.g., <code>Common.READ_RPCID</code> or <code>Common.WRITE_RPCID</code>).</p> <p>Encapsulation (Adding the Label): Before sending the message, the RPC Client (or the RPC Server sending a reply) needs to combine the RPC ID and the marshalled data (payload) into a single byte array. This is encapsulation. Our format is simple: the first byte is the RPC ID, and the rest of the bytes are the marshalled payload.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Encapsulation)\n\npublic class RPCUtils {\n    // ... marshall/unmarshall methods ...\n\n    public static byte[] encapsulate(byte rpcid, byte[] payload) {\n        // Create a new array large enough for the ID (1 byte) + payload\n        byte[] rpcmsg = new byte[1 + payload.length];\n\n        // Put the RPC ID in the first position\n        rpcmsg[0] = rpcid;\n\n        // Copy the payload bytes into the rest of the array\n        System.arraycopy(payload, 0, rpcmsg, 1, payload.length);\n\n        return rpcmsg;\n    }\n    // ... decapsulate method ...\n}\n</code></pre> *   <code>encapsulate</code>: Creates a new byte array one byte larger than the <code>payload</code>. It puts the <code>rpcid</code> at the beginning and copies the <code>payload</code> bytes immediately after it.</p> <p>Decapsulation (Reading the Label and Opening the Box): When the RPC Server (or RPC Client receiving a reply) receives a message, it needs to perform the reverse: extract the RPC ID and the marshalled payload. This is decapsulation.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Decapsulation)\n\nimport java.util.Arrays; // Used for easy array copying\n\npublic class RPCUtils {\n    // ... marshall/unmarshall/encapsulate methods ...\n\n    public static byte[] decapsulate(byte[] rpcmsg) {\n        // Check if the message is valid (must have at least the ID byte)\n        if (rpcmsg == null || rpcmsg.length &lt; 1) {\n            throw new IllegalArgumentException(\"Invalid RPC message for decapsulation\");\n        }\n\n        // The payload is everything *except* the first byte (the RPC ID)\n        byte[] payload = Arrays.copyOfRange(rpcmsg, 1, rpcmsg.length);\n\n        return payload;\n        // Note: The caller needs to get the RPC ID separately (rpcmsg[0])\n        // before calling decapsulate.\n    }\n}\n</code></pre> *   <code>decapsulate</code>: Takes the full received message (<code>rpcmsg</code>). It extracts and returns a new byte array containing everything from the second byte onwards (the payload). The code that calls <code>decapsulate</code> (like in <code>RPCServer.run()</code> or <code>RPCClient.call()</code>) is responsible for looking at the first byte (<code>rpcmsg[0]</code>) separately to get the RPC ID.</p> <p>Here's what the encapsulated message looks like:</p> <pre><code>[ RPC ID (1 byte) | Marshalled Parameter/Result Bytes (Payload) ]\n</code></pre>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#putting-it-all-together-the-data-flow","title":"Putting It All Together: The Data Flow","text":"<p>Let's trace how data is transformed during a <code>sensor.read()</code> call:</p> <pre><code>sequenceDiagram\n    participant Stub as SensorStub\n    participant RPCClient\n    participant Network\n    participant RPCServer\n    participant Skeleton as SensorImpl\n\n    Note over Stub: Wants to call read(). No parameters.\n    Stub-&gt;&gt;Stub: Calls RPCUtils.marshallVoid() -&gt; gets empty byte[] (param_bytes)\n    Stub-&gt;&gt;RPCClient: call(READ_RPCID, param_bytes)\n    Note over RPCClient: Needs to send message.\n    RPCClient-&gt;&gt;RPCClient: Calls RPCUtils.encapsulate(READ_RPCID, param_bytes) -&gt; gets [READ_RPCID] (msg_bytes)\n    RPCClient-&gt;&gt;Network: Sends msg_bytes\n    Network-&gt;&gt;RPCServer: Receives msg_bytes ([READ_RPCID])\n    Note over RPCServer: Needs to process message.\n    RPCServer-&gt;&gt;RPCServer: Extracts ID = msg_bytes[0] (READ_RPCID)\n    RPCServer-&gt;&gt;RPCServer: Calls RPCUtils.decapsulate(msg_bytes) -&gt; gets empty byte[] (param_bytes')\n    RPCServer-&gt;&gt;Skeleton: invoke(param_bytes')\n    Note over Skeleton: Needs parameters.\n    Skeleton-&gt;&gt;Skeleton: Calls RPCUtils.unmarshallVoid(param_bytes') -&gt; Checks it's empty. OK.\n    Skeleton-&gt;&gt;Skeleton: Calls internal read() -&gt; gets temperature (e.g., 17)\n    Note over Skeleton: Needs to return result.\n    Skeleton-&gt;&gt;Skeleton: Calls RPCUtils.marshallInteger(17) -&gt; gets 4 bytes for 17 (result_bytes)\n    Skeleton--&gt;&gt;RPCServer: Returns result_bytes\n    Note over RPCServer: Needs to send reply.\n    RPCServer-&gt;&gt;RPCServer: Calls RPCUtils.encapsulate(READ_RPCID, result_bytes) -&gt; gets [READ_RPCID | 4 bytes for 17] (reply_bytes)\n    RPCServer-&gt;&gt;Network: Sends reply_bytes\n    Network-&gt;&gt;RPCClient: Receives reply_bytes\n    Note over RPCClient: Needs to process reply.\n    RPCClient-&gt;&gt;RPCClient: Calls RPCUtils.decapsulate(reply_bytes) -&gt; gets 4 bytes for 17 (result_bytes')\n    RPCClient--&gt;&gt;Stub: Returns result_bytes'\n    Note over Stub: Needs result value.\n    Stub-&gt;&gt;Stub: Calls RPCUtils.unmarshallInteger(result_bytes') -&gt; gets 17\n    Stub--&gt;&gt;Controller: Returns 17</code></pre> <p>This diagram shows the journey: 1.  Stub marshalls parameters. 2.  RPCClient encapsulates the ID and marshalled parameters. 3.  RPCServer decapsulates the received message to get the ID and marshalled parameters. 4.  Skeleton unmarshalls the parameters to use them. 5.  Skeleton marshalls the result. 6.  RPCServer encapsulates the ID and marshalled result for the reply. 7.  RPCClient decapsulates the reply to get the marshalled result. 8.  Stub unmarshalls the result to return it to the caller.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#conclusion","title":"Conclusion","text":"<p>Marshalling/Unmarshalling is the crucial process of converting Java data into byte arrays for network travel and back again, like packing and unpacking a box. Encapsulation/Decapsulation is the process of adding (and removing) the necessary RPC ID label to this box so the receiver knows what the message is for.</p> <p>The <code>RPCUtils</code> class provides the tools for both: *   <code>marshallX</code>/<code>unmarshallX</code> methods for packing/unpacking specific data types (used by Stubs and Skeletons). *   <code>encapsulate</code>/<code>decapsulate</code> methods for adding/removing the RPC ID label to the packed data (used by RPC Client and RPC Server).</p> <p>Without these steps, our RPC components wouldn't be able to exchange meaningful information over the network.</p> <p>Now that we understand how data is prepared for sending, how is it actually sent and received as a reliable message? That's the job of the layer below RPC: the Messaging Layer.</p> <p>Next up: Messaging Connection</p>"},{"location":"oblig1/06_messaging_connection_/","title":"Chapter 6: Messaging Connection","text":"<p>Welcome to Chapter 6! In the previous chapter, we learned how to pack our Java data (like integers or strings) into boxes of bytes (<code>byte[]</code>) using marshalling, and how to label those boxes with an RPC ID using encapsulation. We have our neatly packaged request (like \"get temperature\") ready to go!</p> <p>But how does this box of bytes actually get from our program (the client) to the other program (the server) across the unpredictable network? How do we make sure the whole box arrives, and not just parts of it? And how does the receiver know when one box ends and the next one begins if we send multiple boxes?</p> <p>Dealing directly with raw network connections (called sockets) involves managing streams of bytes, handling potential errors, and figuring out message boundaries. This can be quite tricky, especially for beginners. We need a simpler, more reliable way to just \"send this message\" and \"receive the next message\".</p>"},{"location":"oblig1/06_messaging_connection_/#the-problem-sending-bytes-reliably","title":"The Problem: Sending Bytes Reliably","text":"<p>Imagine you have your packed box (<code>byte[]</code>) containing the RPC request. You want to send it to the server. Sending it over the network is like sending raw data down a pipe.</p> <ul> <li>How does the receiver know exactly how many bytes belong to this specific box? If you send two boxes back-to-back, the receiver might just see a continuous stream of bytes.</li> <li>What if the network is slow or temporarily interrupted? How do you ensure the complete message is sent and received?</li> </ul> <p>We need a layer that handles these details for us.</p>"},{"location":"oblig1/06_messaging_connection_/#introducing-the-messaging-connection-your-reliable-network-postman","title":"Introducing the Messaging Connection: Your Reliable Network Postman","text":"<p>This is where the Messaging Connection layer comes in. Think of it as a super reliable postal service designed specifically for sending our pre-packaged <code>Message</code> objects.</p> <ul> <li>You (RPC Client/Server): Prepare your message (the <code>byte[]</code> from marshalling/encapsulation) and put it inside a standard envelope \u2013 the <code>Message</code> object.</li> <li>Messaging Connection (Postal Service): You give this <code>Message</code> envelope to the <code>MessageConnection</code>. It takes care of:<ul> <li>Knowing the recipient's address (established via TCP socket).</li> <li>Adding special markings (framing information, covered in the next chapter) so the receiver knows exactly how big the message is.</li> <li>Using a reliable delivery method (TCP) to ensure the bytes arrive in order.</li> <li>Delivering one whole message at a time.</li> <li>Receiving one whole message at a time.</li> </ul> </li> </ul> <p>So, the Messaging Connection:</p> <ol> <li>Represents the Channel: It's the established communication link (a TCP socket) between a client and a server.</li> <li>Abstracts Streams: It hides the raw <code>InputStream</code> and <code>OutputStream</code> of the socket.</li> <li>Deals in Messages: It provides methods to <code>send</code> and <code>receive</code> complete <code>Message</code> objects, not just loose bytes.</li> </ol> <p>This makes network communication much cleaner for the layers above it (like the RPC Client and RPC Server).</p>"},{"location":"oblig1/06_messaging_connection_/#key-components-of-the-messaging-layer","title":"Key Components of the Messaging Layer","text":"<p>This \"postal service\" has a few key parts working together:</p> <ol> <li> <p><code>Message</code> Class: The standard envelope. It's a simple object that holds the data (<code>byte[]</code>) you want to send.</p> <p><pre><code>// Simplified representation\npackage no.hvl.dat110.messaging;\n\npublic class Message {\n    private byte[] data; // The payload (your packed bytes)\n\n    public Message(byte[] data) {\n        this.data = data;\n    }\n\n    public byte[] getData() {\n        return data;\n    }\n}\n</code></pre> This class just acts as a wrapper around the byte array we want to transmit.</p> </li> <li> <p><code>MessageConnection</code> Class: Represents an active, established connection between two points. Once connected, you use this object to send and receive <code>Message</code> envelopes. It's like having a direct phone line open.</p> <p><pre><code>// Simplified representation\npackage no.hvl.dat110.messaging;\n\nimport java.net.Socket;\n// ... other imports ...\n\npublic class MessageConnection {\n    private Socket socket; // The underlying network connection\n    // ... Input/Output streams needed for sending/receiving ...\n\n    public MessageConnection(Socket socket) {\n        this.socket = socket;\n        // ... setup input/output streams from socket ...\n    }\n\n    public void send(Message message) {\n        // ... magic happens here to send the message reliably ...\n        // (Uses MessageUtils.encapsulate)\n    }\n\n    public Message receive() {\n        // ... magic happens here to receive one complete message ...\n        // (Uses MessageUtils.decapsulate)\n        Message receivedMessage = null;\n        // ... read from socket, figure out message boundaries ...\n        return receivedMessage;\n    }\n\n    public void close() {\n        // ... close streams and the socket ...\n    }\n}\n</code></pre> The <code>send</code> and <code>receive</code> methods are the core here. They handle the details of transmitting <code>Message</code> objects over the underlying <code>socket</code>.</p> </li> <li> <p><code>MessagingClient</code> Class: Used by the client application (like the <code>Controller</code>) to initiate a connection to a server. It's like dialing the server's phone number.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessagingClient.java (Simplified)\npackage no.hvl.dat110.messaging;\n\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class MessagingClient {\n    private String server;\n    private int port;\n\n    public MessagingClient(String server, int port) {\n        this.server = server;\n        this.port = port;\n    }\n\n    // Connect to the server and return the established connection\n    public MessageConnection connect() {\n        try {\n            // Create a TCP socket connection to the server address/port\n            Socket clientSocket = new Socket(server, port);\n            // Wrap the socket in our MessageConnection object\n            return new MessageConnection(clientSocket);\n        } catch (IOException e) {\n            System.err.println(\"Error connecting to server: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre> Its main job is the <code>connect()</code> method, which creates the network <code>Socket</code> and returns the usable <code>MessageConnection</code>.</p> </li> <li> <p><code>MessagingServer</code> Class: Used by the server application (like the <code>Sensor</code>) to listen for incoming connection attempts from clients. It's like the operator waiting for the phone to ring.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessagingServer.java (Simplified)\npackage no.hvl.dat110.messaging;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class MessagingServer {\n    private ServerSocket welcomeSocket; // Listens for connections\n\n    public MessagingServer(int port) {\n        try {\n            // Create a socket that listens on the specified port\n            this.welcomeSocket = new ServerSocket(port);\n        } catch (IOException e) {\n             System.err.println(\"Error starting server: \" + e.getMessage());\n             throw new RuntimeException(e);\n        }\n    }\n\n    // Wait for a client to connect, then return the connection\n    public MessageConnection accept() {\n        try {\n            System.out.println(\"MessagingServer waiting for connection...\");\n            // Wait here until a client tries to connect\n            Socket connectionSocket = welcomeSocket.accept();\n            System.out.println(\"MessagingServer accepted connection.\");\n            // Wrap the new client socket in a MessageConnection\n            return new MessageConnection(connectionSocket);\n        } catch (IOException e) {\n            System.err.println(\"Error accepting connection: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void stop() { /* ... close welcomeSocket ... */ }\n}\n</code></pre> Its main job is the <code>accept()</code> method, which blocks (waits) until a client connects, then returns a <code>MessageConnection</code> representing the link to that specific client.</p> </li> </ol>"},{"location":"oblig1/06_messaging_connection_/#how-the-rpc-layer-uses-the-messaging-layer","title":"How the RPC Layer Uses the Messaging Layer","text":"<p>Remember the RPC Client's <code>call</code> method?</p> <p><pre><code>// Inside RPCClient.call() (Simplified)\npublic byte[] call(byte rpcid, byte[] params) {\n    byte[] requestData = RPCUtils.encapsulate(rpcid, params);\n    Message requestMessage = new Message(requestData); // Create the envelope\n\n    // Use the Messaging Layer to send\n    connection.send(requestMessage); // Hand off to the \"postman\"\n\n    // Use the Messaging Layer to receive\n    Message replyMessage = connection.receive(); // Wait for the return mail\n\n    byte[] returnval = RPCUtils.decapsulate(replyMessage.getData());\n    return returnval;\n}\n</code></pre> And the RPC Server's <code>run</code> loop?</p> <p><pre><code>// Inside RPCServer.run() (Simplified loop)\npublic void run() {\n    connection = msgserver.accept(); // Wait for a client connection\n\n    while (!stop) {\n        // Use Messaging Layer to receive request\n        Message requestmsg = connection.receive();\n\n        // ... process request (decapsulate, lookup, invoke) ...\n        byte[] result = specialist.invoke(params);\n        byte[] replyData = RPCUtils.encapsulate(rpcid, result);\n        Message replymsg = new Message(replyData); // Create reply envelope\n\n        // Use Messaging Layer to send reply\n        connection.send(replymsg);\n\n        // ... check for stop condition ...\n    }\n}\n</code></pre> Notice how the RPC layer only deals with <code>Message</code> objects and the <code>send</code>/<code>receive</code> methods of the <code>MessageConnection</code>. It doesn't worry about sockets or byte streams directly. The <code>MessagingClient</code> and <code>MessagingServer</code> handle the initial setup (<code>connect</code>/<code>accept</code>).</p>"},{"location":"oblig1/06_messaging_connection_/#under-the-hood-sockets-and-message-boundaries","title":"Under the Hood: Sockets and Message Boundaries","text":"<p>So how does <code>MessageConnection</code> actually achieve this \"send one message, receive one message\" magic?</p> <ol> <li>TCP Sockets: Underneath, <code>MessageConnection</code> uses standard Java <code>Socket</code> objects. TCP (Transmission Control Protocol) provides a reliable, ordered stream of bytes between the client and server. This means bytes sent arrive in the same order, and TCP handles retransmitting lost data. However, TCP itself doesn't know about message boundaries \u2013 it just sees a stream.</li> <li>Input/Output Streams: The <code>MessageConnection</code> gets the <code>InputStream</code> and <code>OutputStream</code> from the <code>Socket</code>. It typically wraps these in <code>DataInputStream</code> and <code>DataOutputStream</code> which provide helpful methods for reading and writing primitive Java types and byte arrays.</li> <li>Framing (The Secret Sauce!): This is the crucial part. Before writing the <code>Message</code>'s payload bytes to the <code>OutputStream</code>, the <code>send</code> method uses a helper function (from <code>MessageUtils</code>, covered in the next chapter) to add framing information. The simplest form of framing is adding the length of the payload before the payload itself.</li> <li>Sending: The <code>send</code> method writes the framing information (e.g., the length) followed by the actual payload bytes to the <code>DataOutputStream</code>.</li> <li>Receiving: The <code>receive</code> method uses another helper function (from <code>MessageUtils</code>) that first reads the framing information (e.g., the length) from the <code>DataInputStream</code>. Once it knows the length, it reads exactly that many bytes from the stream \u2013 this is the payload.</li> <li>Reconstructing the Message: It takes the received payload bytes and puts them into a new <code>Message</code> object, which is then returned.</li> </ol> <p>This process of adding and reading the length (or other boundary markers) is called the Message Framing Protocol.</p> <p>Here's a diagram showing the flow when <code>RPCClient</code> sends a message via <code>MessageConnection</code>:</p> <pre><code>sequenceDiagram\n    participant RPC_Client as RPC Client\n    participant MsgConn as MessageConnection\n    participant MsgUtils as MessageUtils\n    participant Stream as DataOutputStream\n    participant Network\n\n    RPC_Client-&gt;&gt;MsgConn: send(myMessage)\n    Note over MsgConn: Get payload bytes from myMessage\n    MsgConn-&gt;&gt;MsgUtils: encapsulate(payload_bytes)\n    Note over MsgUtils: Add framing (e.g., length) to payload\n    MsgUtils--&gt;&gt;MsgConn: return framed_bytes (length + payload)\n    MsgConn-&gt;&gt;Stream: write(framed_bytes)\n    Stream-&gt;&gt;Network: Send framed_bytes over TCP socket</code></pre> <p>And when the <code>RPCServer</code> receives it:</p> <pre><code>sequenceDiagram\n    participant Network\n    participant Stream as DataInputStream\n    participant MsgUtils as MessageUtils\n    participant MsgConn as MessageConnection\n    participant RPC_Server as RPC Server\n\n    Network-&gt;&gt;Stream: Receive framed_bytes (length + payload)\n    RPC_Server-&gt;&gt;MsgConn: receive()\n    MsgConn-&gt;&gt;MsgUtils: decapsulate(Stream)\n    Note over MsgUtils: Read length from Stream\n    Note over MsgUtils: Read 'length' bytes of payload from Stream\n    MsgUtils--&gt;&gt;MsgConn: return received_payload_bytes\n    MsgConn-&gt;&gt;MsgConn: Create newMessage(received_payload_bytes)\n    MsgConn--&gt;&gt;RPC_Server: return newMessage</code></pre> <p>The <code>MessageUtils.encapsulate</code> and <code>MessageUtils.decapsulate</code> methods (which implement the framing protocol) are the key to making <code>MessageConnection.send</code> and <code>MessageConnection.receive</code> work with whole messages.</p>"},{"location":"oblig1/06_messaging_connection_/#conclusion","title":"Conclusion","text":"<p>The Messaging Connection layer provides a vital abstraction over raw network sockets. It establishes a connection (<code>MessagingClient</code>, <code>MessagingServer</code>) and allows the sending and receiving of discrete <code>Message</code> objects (<code>MessageConnection.send</code>, <code>MessageConnection.receive</code>).</p> <p>It hides the complexity of byte streams and error handling by leveraging TCP and, crucially, by implementing a framing protocol (via helper functions) to define message boundaries. This allows the higher-level RPC components to communicate reliably without getting bogged down in networking details. They simply work with <code>Message</code> objects.</p> <p>But how exactly does this framing work? How do we add the length information and read it back correctly? That's the topic of our final chapter.</p> <p>Next up: Message Framing Protocol</p>"},{"location":"oblig1/07_message_framing_protocol_/","title":"Chapter 7: Message Framing Protocol","text":"<p>Welcome to the final chapter! In the previous chapter, we explored the Messaging Connection layer. We saw how it acts like a reliable postal service, providing <code>send</code> and <code>receive</code> methods to exchange <code>Message</code> objects between a client and server. We briefly mentioned that there's some \"magic\" happening inside <code>send</code> and <code>receive</code> to make sure whole messages are sent and received correctly, even though the underlying network connection (TCP) just sees a continuous stream of bytes.</p> <p>It's time to reveal that magic! It's called the Message Framing Protocol.</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-problem-just-a-stream-of-bytes","title":"The Problem: Just a Stream of Bytes","text":"<p>Imagine you're reading a very long scroll of text that has no punctuation or spaces between words. It would be incredibly difficult to figure out where one word ends and the next begins, let alone understand the sentences!</p> <p>TCP network connections are a bit like that scroll. They provide a reliable stream of bytes from the sender to the receiver. If the sender sends \"HELLO\" (5 bytes) and then immediately sends \"WORLD\" (5 bytes), the receiver might just get a stream like \"HELLOWORLD\" (10 bytes). The receiver doesn't automatically know that this was originally two separate messages.</p> <p>Our Messaging Connection needs to send and receive distinct <code>Message</code> objects. If the RPC Client sends a request message, and then maybe another one later, the RPC Server needs to be able to receive the first message completely, process it, and then receive the second message completely. How can we add structure to this byte stream?</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-solution-message-framing-protocol-standard-envelopes","title":"The Solution: Message Framing Protocol - Standard Envelopes!","text":"<p>The solution is to agree on a set of rules \u2013 a protocol \u2013 for how messages are packaged, or framed, before being sent over the stream. This ensures the receiver can identify the boundaries of each message.</p> <p>Think of it like agreeing to always send letters using standard-sized envelopes. Even if you put multiple envelopes into the mailbag one after another, the recipient can easily pick out one envelope, open it, read the letter inside, and then pick out the next envelope.</p> <p>Our Message Framing Protocol defines the \"standard envelope\" for our system.</p> <p>Our Specific Protocol:</p> <p>In this project (<code>dat110-project1-gruppe69</code>), we use a simple framing protocol:</p> <ol> <li>Fixed-Size Segments: All data is sent in fixed-size chunks called segments. Each segment is exactly 128 bytes long.</li> <li>Length Header: The very first byte of each 128-byte segment is special. It acts as a header and tells the receiver the length of the actual payload data contained within that segment. This length can be anywhere from 0 to 127 bytes.</li> <li>Payload: The actual message data (the bytes from the <code>Message</code> object) follows the length byte.</li> <li>Padding: Since the segment must be 128 bytes, but the payload might be shorter (e.g., only 10 bytes), the remaining bytes in the segment after the payload are just padding. They are sent but ignored by the receiver.</li> </ol> <p>Here's what our 128-byte \"envelope\" (segment) looks like:</p> <pre><code>graph LR\n  A[\"Segment (128 bytes total)\"] --&gt; B[\"Byte 1: Length L\"]\n  A --&gt; C[\"Bytes 2 to L+1: Payload Data\"]\n  A --&gt; D[\"Bytes L+2 to 128: Padding\"]\n  subgraph \"Fixed Size Frame\"\n    direction LR\n    B --- C --- D\n  end\n  style A fill:#f9f,stroke:#333,stroke-width:2px</code></pre> <ul> <li>The first byte tells us <code>L</code>, the length of the real data.</li> <li>The next <code>L</code> bytes are the actual payload we care about.</li> <li>The rest of the 128 bytes are just filler (padding).</li> </ul>"},{"location":"oblig1/07_message_framing_protocol_/#implementing-the-framing-messageutils","title":"Implementing the Framing: <code>MessageUtils</code>","text":"<p>The rules of our protocol are implemented in the helper methods of the <code>MessageUtils.java</code> class, specifically <code>encapsulate</code> and <code>decapsulate</code>. These are the methods used internally by <code>MessageConnection</code>'s <code>send</code> and <code>receive</code>.</p> <p>1. Packing the Envelope (<code>encapsulate</code>)</p> <p>When <code>MessageConnection.send(message)</code> is called, it needs to take the <code>message</code>'s data and put it into our standard 128-byte envelope format. It uses <code>MessageUtils.encapsulate</code> for this.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessageUtils.java (Encapsulate)\n\npublic class MessageUtils {\n\n    public static final int SEGMENTSIZE = 128; // Our fixed envelope size\n\n    // Takes the message payload and puts it into a 128-byte segment\n    public static byte[] encapsulate(Message message) {\n        byte[] data = message.getData(); // Get the raw payload bytes (0-127 bytes)\n        byte[] segment = new byte[SEGMENTSIZE]; // Create the 128-byte empty envelope\n\n        // Rule 1: Put the length of the payload in the first byte\n        segment[0] = (byte) data.length;\n\n        // Rule 2: Copy the payload data into the segment, starting from byte 1\n        System.arraycopy(data, 0, segment, 1, data.length);\n\n        // Rule 3: The rest of 'segment' is padding (already 0s)\n        return segment; // Return the filled 128-byte envelope\n    }\n\n    // ... decapsulate method ...\n}\n</code></pre> <p>Let's break it down: *   It gets the payload <code>data</code> from the <code>Message</code> object. Remember from <code>Message.java</code>, this <code>data</code> is guaranteed to be 127 bytes or less. *   It creates a brand new byte array called <code>segment</code> that is exactly 128 bytes long. *   <code>segment[0] = (byte) data.length;</code> This crucial step writes the length of the payload into the very first byte of the segment. *   <code>System.arraycopy(...)</code> copies the actual payload <code>data</code> into the <code>segment</code>, but it starts copying at index 1 (the second byte), leaving the first byte for the length. *   The method returns the 128-byte <code>segment</code>. This is what <code>MessageConnection</code> actually writes to the network stream.</p> <p>2. Unpacking the Envelope (<code>decapsulate</code>)</p> <p>When <code>MessageConnection.receive()</code> is called, it first reads exactly 128 bytes from the network stream (because it knows all messages arrive in 128-byte segments). It then needs to extract the actual payload from this 128-byte segment. It uses <code>MessageUtils.decapsulate</code> for this.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessageUtils.java (Decapsulate)\n\nimport java.util.Arrays; // Used for array copying\n\npublic class MessageUtils {\n    // ... SEGMENTSIZE constant and encapsulate method ...\n\n    // Takes a 128-byte segment and extracts the original payload data\n    public static Message decapsulate(byte[] segment) {\n\n        // Basic checks for valid segment\n        if (segment == null || segment.length != SEGMENTSIZE) {\n           throw new IllegalArgumentException(\"Invalid segment received\");\n        }\n\n        // Rule 1: Read the payload length from the first byte\n        // (&amp; 0xFF ensures we treat the byte as unsigned, 0-255)\n        int length = segment[0] &amp; 0xFF;\n\n        // Sanity check: Length shouldn't exceed allowed payload size\n        if (length &gt; SEGMENTSIZE - 1) { // Max payload is 127\n             throw new IllegalArgumentException(\"Segment length field is too large\");\n        }\n\n        // Rule 2: Extract the payload data\n        // Create a new array of the correct size ('length')\n        byte[] data = new byte[length];\n        // Copy 'length' bytes from the segment, starting from byte 1\n        System.arraycopy(segment, 1, data, 0, length);\n\n        // Rule 3: The padding is ignored!\n\n        // Create and return a new Message containing only the extracted data\n        return new Message(data);\n    }\n}\n</code></pre> <p>Here's how it works: *   It receives the 128-byte <code>segment</code> that was read from the network. *   <code>int length = segment[0] &amp; 0xFF;</code> reads the first byte to figure out how long the actual payload is. (The <code>&amp; 0xFF</code> is a technical detail to handle Java's byte representation correctly). *   It creates a new byte array called <code>data</code> that is exactly <code>length</code> bytes long \u2013 just big enough for the payload. *   <code>System.arraycopy(...)</code> copies <code>length</code> bytes from the received <code>segment</code> (starting at index 1) into the new <code>data</code> array. *   Finally, it creates a new <code>Message</code> object using only the extracted <code>data</code> and returns it. This <code>Message</code> now contains only the original payload sent by the sender, with the framing and padding removed.</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-whole-picture","title":"The Whole Picture","text":"<p>So, the Messaging Connection layer uses this framing protocol like this:</p> <ol> <li> <p>Sender (<code>MessageConnection.send</code>):</p> <ul> <li>Gets the <code>Message</code> object (containing payload from, say, RPC Data Marshalling/Unmarshalling).</li> <li>Calls <code>MessageUtils.encapsulate</code> to wrap the payload in a 128-byte segment with the length header.</li> <li>Writes the entire 128-byte segment to the TCP output stream.</li> </ul> </li> <li> <p>Receiver (<code>MessageConnection.receive</code>):</p> <ul> <li>Reads exactly 128 bytes from the TCP input stream (because it expects a segment).</li> <li>Calls <code>MessageUtils.decapsulate</code> on the received 128-byte segment.</li> <li><code>decapsulate</code> reads the length header, extracts the payload bytes, and ignores the padding.</li> <li><code>decapsulate</code> returns a new <code>Message</code> object containing only the original payload.</li> <li><code>receive</code> returns this payload-only <code>Message</code> object to the caller (e.g., the RPC Server).</li> </ul> </li> </ol> <p>This ensures that even though TCP is just a stream, the <code>MessageConnection</code> layer can reliably send and receive distinct messages because the Message Framing Protocol provides the necessary structure.</p>"},{"location":"oblig1/07_message_framing_protocol_/#conclusion","title":"Conclusion","text":"<p>The Message Framing Protocol is a fundamental concept in network programming. It defines the rules for how to structure data sent over a stream-based connection so that the receiver can distinguish individual messages. In our project, we use a simple fixed-size segment protocol: every message travels inside a 128-byte \"envelope,\" where the first byte declares the length of the actual content inside (0-127 bytes), and the rest is potential padding.</p> <p>The <code>MessageUtils.encapsulate</code> and <code>MessageUtils.decapsulate</code> methods implement this protocol, allowing our Messaging Connection layer to provide a clean <code>send(Message)</code> and <code>receive()</code> interface to the higher RPC layers.</p> <p>With this final piece, we've explored the entire stack, from the high-level convenience of RPC Stubs down to the details of packaging bytes for reliable network transmission. Congratulations on completing the tutorial for <code>dat110-project1-gruppe69</code>!</p>"},{"location":"oblig1/oblig1_index/","title":"Project 1 Overview","text":"<p>This project implements a simple Remote Procedure Call (RPC) system for an IoT application (Sensor, Controller, Display). It builds the RPC functionality on top of a custom messaging layer, which itself uses standard TCP sockets for network communication. The goal is to allow different parts of the application (like the Controller calling the Sensor) to communicate over the network as if they were just making local method calls, hiding the underlying network details through layered abstractions.</p> <p>Source Repository: https://github.com/selabhvl/dat110-project1-rpc-startcode </p> <pre><code>flowchart TD\n    A0[\"Messaging Connection\n\"]\n    A1[\"Message Framing Protocol\n\"]\n    A2[\"RPC Client\n\"]\n    A3[\"RPC Server\n\"]\n    A4[\"RPC Data Marshalling/Unmarshalling\n\"]\n    A5[\"RPC Client Stub\n\"]\n    A6[\"RPC Server Implementation (Skeleton)\n\"]\n    A5 -- \"Uses to make remote call\" --&gt; A2\n    A2 -- \"Uses for network send/receive\" --&gt; A0\n    A3 -- \"Uses for network receive/send\" --&gt; A0\n    A0 -- \"Uses for message structure\" --&gt; A1\n    A5 -- \"Uses to marshal/unmarshal data\" --&gt; A4\n    A6 -- \"Uses to unmarshal/marshal data\" --&gt; A4\n    A3 -- \"Dispatches call to\" --&gt; A6</code></pre>"},{"location":"oblig1/oblig1_index/#chapters","title":"Chapters","text":"<ol> <li>RPC Client Stub </li> <li>RPC Server Implementation (Skeleton) </li> <li>RPC Client </li> <li>RPC Server </li> <li>RPC Data Marshalling/Unmarshalling </li> <li>Messaging Connection </li> <li>Message Framing Protocol </li> </ol>"},{"location":"oblig2/00_index/","title":"Tutorial: dat110-oblig2","text":"<p>This project implements a publish-subscribe messaging system. Clients can connect to a central Broker, subscribe to topics, and publish messages to those topics. The Broker then routes the messages to all subscribed clients.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Message\n\"]\n    A1[\"MessageType\n\"]\n    A2[\"MessageUtils\n\"]\n    A3[\"Storage\n\"]\n    A4[\"ClientSession\n\"]\n    A5[\"Dispatcher\n\"]\n    A6[\"Broker\n\"]\n    A7[\"Stopable\n\"]\n    A8[\"Connection\n\"]\n    A9[\"Client\n\"]\n    A9 -- \"Sends/Receives\" --&gt; A0\n    A0 -- \"Contains\" --&gt; A1\n    A2 -- \"Serializes/Deserializes\" --&gt; A0\n    A5 -- \"Handles\" --&gt; A0\n    A6 -- \"Uses\" --&gt; A5\n    A5 -- \"Manages\" --&gt; A3\n    A3 -- \"Stores\" --&gt; A4\n    A4 -- \"Wraps\" --&gt; A8\n    A6 -- \"Accepts\" --&gt; A8\n    A6 -- \"Extends\" --&gt; A7\n    A5 -- \"Extends\" --&gt; A7\n    A8 -- \"Uses\" --&gt; A2\n    A9 -- \"Uses\" --&gt; A2</code></pre>"},{"location":"oblig2/00_index/#chapters","title":"Chapters","text":"<ol> <li>Client </li> <li>Broker </li> <li>Message </li> <li>MessageType </li> <li>MessageUtils </li> <li>Connection </li> <li>Dispatcher </li> <li>Storage </li> <li>ClientSession </li> <li>Stopable </li> </ol>"},{"location":"oblig2/01_client_/","title":"Chapter 1: Client","text":"<p>Welcome to the first chapter of the <code>dat110-oblig2</code> tutorial! In this chapter, we'll be diving into the concept of a <code>Client</code>. Think of this <code>Client</code> as the foundation for building applications that can talk to a central messaging system.</p> <p>Why do we need a Client?</p> <p>Imagine you're building a smart home system. You have a temperature sensor, a light switch, and a display screen. Each of these devices needs to communicate with a central \"brain\" (which we'll call the broker). The <code>Client</code> class provides a way for each of these devices to connect to the broker, send and receive messages, and generally participate in the smart home network.</p> <p>Without a <code>Client</code> class, each device would have to handle the complex details of network communication and message formatting on its own. This would be messy and repetitive. The <code>Client</code> class encapsulates all of that complexity, making it easier to build different types of devices.</p> <p>Key Concepts</p> <p>The <code>Client</code> class handles several key tasks:</p> <ol> <li>Connecting to the Broker: Establishes a connection with the central messaging system.</li> <li>Subscribing to Topics:  Tells the broker that the client is interested in receiving messages about specific topics (e.g., \"temperature\").</li> <li>Publishing Messages: Sends messages to the broker about specific topics (e.g., the temperature sensor publishes the current temperature).</li> <li>Disconnecting:  Closes the connection to the broker.</li> </ol> <p>Using the Client: A Simple Example</p> <p>Let's say we want to create a simple temperature sensor client that publishes the temperature to the \"temperature\" topic.  Here's how we might use the <code>Client</code> class:</p> <pre><code>Client sensor = new Client(\"sensor1\", \"localhost\", 8080);\n\nif (sensor.connect()) {\n    System.out.println(\"Connected to the broker!\");\n\n    sensor.publish(\"temperature\", \"25 degrees Celsius\");\n\n    sensor.disconnect();\n    System.out.println(\"Disconnected from the broker.\");\n} else {\n    System.out.println(\"Failed to connect!\");\n}\n</code></pre> <p>Explanation:</p> <ul> <li>We create a <code>Client</code> object, giving it a name (\"sensor1\"), the broker's address (\"localhost\"), and the port number (8080).</li> <li>We call <code>connect()</code> to establish a connection with the broker.  If the connection is successful, we print a message.</li> <li>We call <code>publish()</code> to send a message to the \"temperature\" topic. The message contains the current temperature.</li> <li>Finally, we call <code>disconnect()</code> to close the connection.</li> </ul> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>Client</code> class when we call <code>connect()</code>.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant MessagingClient\n    participant Connection\n    participant Broker\n\n    Client-&gt;&gt;MessagingClient: connect()\n    MessagingClient-&gt;&gt;Connection: connect() // Establishes TCP connection\n    activate Connection\n    Connection--&gt;&gt;MessagingClient: Connection object\n    deactivate Connection\n    MessagingClient--&gt;&gt;Client: Connection object\n    Client-&gt;&gt;Client: Create ConnectMsg\n    Client-&gt;&gt;Connection: send(ConnectMsg)\n    activate Connection\n    Connection-&gt;&gt;Broker: Send TCP message\n    deactivate Connection</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The <code>Client</code> calls the <code>connect()</code> method of the <code>MessagingClient</code>.</li> <li>The <code>MessagingClient</code> establishes a TCP connection to the Broker, and creates a <code>Connection</code> object. We will learn more about the Connection in its own chapter.</li> <li>The <code>Client</code> then creates a <code>ConnectMsg</code>, which is a special message that tells the broker that a new client is connecting. We will learn about Message later.</li> <li>The <code>Client</code> uses the <code>Connection</code> object to send the <code>ConnectMsg</code> to the broker.</li> </ol> <p>Relevant Code Snippets</p> <p>Here's a simplified version of the <code>connect()</code> method in <code>src/main/java/no/hvl/dat110/client/Client.java</code>:</p> <pre><code>public class Client extends Thread {\n\n    private MessagingClient client;\n    private Connection connection;\n    private String user;\n\n    public Client(String user, String server, int port) {\n        client = new MessagingClient(server, port);\n        this.user = user;\n    }\n\n    public boolean connect() {\n        connection = client.connect(); // Establish connection\n        ConnectMsg msg = new ConnectMsg(user); // Create connect message\n\n        if (connection != null) {\n            send(msg); // Send message\n            return true;\n        }\n        return false;\n    }\n\n    private void send(Message msg) {\n        connection.send(MessageUtils.toTransportMessage(msg));\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>connect()</code> method first calls <code>client.connect()</code> to establish a Connection.</li> <li>It then creates a <code>ConnectMsg</code> object, which contains the client's username.  This message tells the broker that a new client is connecting. We will dive deeper into Message in its own chapter.</li> <li>The <code>send()</code> method (which we've simplified here) sends the <code>ConnectMsg</code> to the broker through the <code>Connection</code> object.  We use the MessageUtils to transform the <code>Message</code> object to make it understandable for transport.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Client</code> class and how it simplifies the process of connecting to a message broker, publishing messages, and subscribing to topics.  The <code>Client</code> class is a fundamental building block for creating distributed applications.</p> <p>In the next chapter, we'll explore the other side of the connection: the Broker, which is the central messaging system that all clients connect to.</p>"},{"location":"oblig2/02_broker_/","title":"Chapter 2: Broker","text":"<p>Welcome back! In the Client chapter, we learned how to create clients that can connect to a central messaging system. Now, let's explore the other side of the connection: the <code>Broker</code>.</p> <p>Why do we need a Broker?</p> <p>Imagine a bustling coffee shop. Clients are like customers ordering drinks. The broker is like the barista, the central point of contact who receives orders, prepares them, and hands them out. Without the barista (broker), there would be chaos! Everyone would be trying to make their own drinks, leading to inefficiency and mess.</p> <p>In our messaging system, the <code>Broker</code> class is responsible for:</p> <ol> <li>Accepting connections from clients: Like the coffee shop door, it welcomes new customers (clients).</li> <li>Receiving messages: It takes orders (messages) from the clients.</li> <li>Distributing messages: It ensures the messages reach the right recipients (other clients or services).</li> </ol> <p>Key Concepts</p> <p>The <code>Broker</code> class handles several key tasks:</p> <ol> <li>Listening for Connections: Continuously waits for new clients to connect.</li> <li>Accepting Connections:  Welcomes new clients when they try to connect.</li> <li>Handing off Connections:  Passes the responsibility of handling the client's messages to the Dispatcher.</li> </ol> <p>Using the Broker: A Simple Example</p> <p>Let's imagine a scenario where two clients, \"sensor1\" and \"display1\", want to communicate through the broker. \"sensor1\" publishes temperature data, and \"display1\" wants to receive it.</p> <ol> <li>The Broker starts listening: The <code>Broker</code> starts running and listens for incoming connections on a specific port (e.g., 8080).</li> <li>\"sensor1\" connects:  The <code>Client</code> for \"sensor1\" connects to the broker.</li> <li>The Broker accepts the connection: The <code>Broker</code> accepts the connection from \"sensor1\".</li> <li>\"display1\" connects: The <code>Client</code> for \"display1\" connects to the broker.</li> <li>The Broker accepts the connection: The <code>Broker</code> accepts the connection from \"display1\".</li> <li>\"sensor1\" publishes a message: \"sensor1\" sends a message with the temperature data to the broker.</li> <li>The Broker routes the message:  The broker, with the help of the Dispatcher, figures out that \"display1\" is interested in temperature data and sends the message to it.</li> <li>\"display1\" receives the message: The <code>Client</code> for \"display1\" receives the temperature data and displays it.</li> </ol> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>Broker</code> class when a client connects.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Broker\n    participant MessagingServer\n    participant Connection\n    participant Dispatcher\n\n    Broker-&gt;&gt;MessagingServer: accept()\n    activate MessagingServer\n    MessagingServer--&gt;&gt;Connection: Connection\n    deactivate MessagingServer\n    Client-&gt;&gt;Broker: connect()\n    activate Broker\n    Broker-&gt;&gt;Dispatcher: onConnect(ConnectMsg, Connection)\n    activate Dispatcher\n    Dispatcher--&gt;&gt;Broker: \n    deactivate Dispatcher\n    deactivate Broker\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The <code>Broker</code> calls the <code>accept()</code> method of the <code>MessagingServer</code>. This method waits for a new client to connect.</li> <li>When a <code>Client</code> connects, the <code>MessagingServer</code> creates a <code>Connection</code> object. We will learn more about the Connection in its own chapter.</li> <li>The <code>Broker</code> then receives the connection and extracts the initial Message, which should be a <code>ConnectMsg</code>.</li> <li>The <code>Broker</code> calls the <code>onConnect()</code> method of the Dispatcher, passing the <code>ConnectMsg</code> and the <code>Connection</code> object.  The Dispatcher then takes over the responsibility of handling messages from this client.</li> </ol> <p>Relevant Code Snippets</p> <p>Here's a simplified version of the <code>doProcess()</code> and <code>waitConnect()</code> method in <code>src/main/java/no/hvl/dat110/broker/Broker.java</code>:</p> <pre><code>public class Broker extends Stopable {\n\n    private MessagingServer server;\n    private Dispatcher dispatcher;\n\n    public Broker(Dispatcher dispatcher, int port) {\n        super(\"Broker\");\n        server = new MessagingServer(port);\n        this.dispatcher = dispatcher;\n    }\n\n    @Override\n    public void doProcess() {\n        Connection connection = server.accept(); // Accept new connection\n        waitConnect(connection);\n    }\n\n    private void waitConnect(Connection connection) {\n        Message msg = MessageUtils.receive(connection); // Receive the first message\n\n        if (msg.getType() == MessageType.CONNECT) { // Verify it's a CONNECT message\n            ConnectMsg cmsg = (ConnectMsg) msg;\n            dispatcher.onConnect(cmsg, connection); // Hand off to the dispatcher\n        } else {\n            System.out.println(\"Protocol error: first message should be connect\");\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>doProcess()</code> method continuously calls <code>server.accept()</code> to listen for new connections. When a client connects, it gets a <code>Connection</code> object.</li> <li>The <code>waitConnect()</code> method receives the first message from the client using MessageUtils.</li> <li>It checks if the message type is <code>CONNECT</code>. If it is, it casts the message to a <code>ConnectMsg</code> and calls the <code>dispatcher.onConnect()</code> method to hand off the connection handling to the Dispatcher. This is a crucial step! The Dispatcher is responsible for managing the client's session and handling its subsequent messages.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Broker</code> class and how it acts as the central point of contact for clients in our messaging system. It accepts connections, receives messages, and hands off the connections to the Dispatcher for further processing. The <code>Broker</code> is essential for managing the communication between multiple clients.</p> <p>In the next chapter, we'll explore the structure of a Message, the basic unit of communication in our system.</p>"},{"location":"oblig2/03_message_/","title":"Chapter 3: Message","text":"<p>In the previous chapter, Broker, we explored how the broker acts as the central hub for communication. But what exactly are the things being communicated? That's where the <code>Message</code> class comes in!</p> <p>Why do we need Messages?</p> <p>Imagine you're sending a letter to a friend. You need an envelope to put the letter in, right? The <code>Message</code> class is like that envelope. It provides a standard way to package information so that the Client and the Broker can understand each other.</p> <p>Let's say a temperature sensor wants to send the current temperature to the broker. It can't just shout \"25 degrees!\" across the network. It needs to package that information into a <code>Message</code>.</p> <p>Key Concepts</p> <p>The <code>Message</code> class has two main parts:</p> <ol> <li>Type: What kind of message is it? Is it a request to connect, a temperature reading, or something else? We will explore MessageType later.</li> <li>User: Who sent the message? This helps the broker know who's talking.</li> </ol> <p>Think of it like this:</p> <pre><code>Message (Envelope):\n    - Type (Postcard, Email, etc.)\n    - User (Sender's Name)\n    - Content (The actual information) -  Specific to the Message Type (temperature reading, topic name etc.)\n</code></pre> <p>All actual messages inherit from the <code>Message</code> class. This means messages like \"Connect\", \"Publish\", and \"Subscribe\" all have the basic <code>Message</code> properties (type and user), but then add their own specific content.</p> <p>Using the Message: A Simple Example</p> <p>Let's say we want to create a simple \"Connect\" message when a client connects to the broker.  The <code>ConnectMsg</code> is a type of <code>Message</code>.</p> <pre><code>String username = \"sensor1\";\nConnectMsg connectMessage = new ConnectMsg(username);\n\nSystem.out.println(connectMessage.toString());\n</code></pre> <p>Explanation:</p> <ul> <li>We create a <code>ConnectMsg</code> object, passing in the username \"sensor1\".  The <code>ConnectMsg</code> knows that its type is <code>CONNECT</code> (we'll learn about <code>MessageType</code> in the next chapter).</li> <li>The <code>toString()</code> method will print out a textual representation of the message.</li> </ul> <p>Example Output:</p> <pre><code>Message [type=CONNECT, user=sensor1]\n</code></pre> <p>This message tells the broker that a client named \"sensor1\" wants to connect.</p> <p>Different Types of Messages</p> <p>Here are some other examples of message types, and what kind of information they hold in addition to the user and the type:</p> <ul> <li>PublishMsg:  Used to publish data to a topic.  It contains the topic name and the actual message content (the data).</li> <li>SubscribeMsg:  Used to subscribe to a topic. It contains the topic name.</li> <li>UnsubscribeMsg: Used to unsubscribe from a topic. It contains the topic name.</li> <li>CreateTopicMsg: Used to create a topic. It contains the topic name.</li> <li>DeleteTopicMsg: Used to delete a topic. It contains the topic name.</li> <li>DisconnectMsg:  Used to disconnect from the broker. It doesn't need any additional information.</li> </ul> <p>Under the Hood: How it Works</p> <p>When a Client wants to send a message, it first creates a <code>Message</code> object (like a <code>PublishMsg</code> or <code>SubscribeMsg</code>). Then, it uses the Connection to send the message to the Broker.  The Broker receives the message and figures out what to do based on the message's type.</p> <p>Here's a simplified sequence diagram:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Broker\n    participant PublishMsg\n\n    Client-&gt;&gt;PublishMsg: Create PublishMsg (topic, message)\n    Client-&gt;&gt;Broker: Send PublishMsg\n    Broker-&gt;&gt;Broker: Process PublishMsg</code></pre> <p>Here's the breakdown:</p> <ol> <li>The <code>Client</code> creates a <code>PublishMsg</code> object, providing the topic and message content.</li> <li>The <code>Client</code> sends the <code>PublishMsg</code> to the <code>Broker</code>.</li> <li>The <code>Broker</code> receives the message and figures out what to do with it (e.g., forward it to subscribers).</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the base <code>Message</code> class first:</p> <pre><code>package no.hvl.dat110.messages;\n\npublic abstract class Message {\n\n    private MessageType type;\n    private String user;\n\n    public Message(MessageType type, String user) {\n        this.type = type;\n        this.user = user;\n    }\n\n    public MessageType getType() { return this.type; }\n\n    public String getUser() {\n        return user;\n    }\n\n    @Override\n    public String toString() {\n        return \"Message [type=\" + type + \", user=\" + user + \"]\";\n    };\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>Message</code> class has two fields: <code>type</code> (the message type) and <code>user</code> (the username of the sender).</li> <li>The constructor takes the <code>type</code> and <code>user</code> as arguments.</li> <li>There are getter methods to access the <code>type</code> and <code>user</code>.</li> <li>The <code>toString()</code> method provides a simple textual representation of the message.</li> </ul> <p>Now, let's look at an example of a class that inherits from <code>Message</code>, the <code>PublishMsg</code>:</p> <pre><code>package no.hvl.dat110.messages;\n\npublic class PublishMsg extends Message {\n\n    private String topic;\n    private String message;\n\n    public PublishMsg(String user, String topic, String message) {\n        super(MessageType.PUBLISH, user);\n        this.topic = topic;\n        this.message = message;\n    }\n\n    public String getTopic() {\n        return topic;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public String toString() {\n        return \"PublishMsg [topic=\" + topic + \", message=\" + message + \", toString()=\" + super.toString() + \"]\";\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>PublishMsg</code> class extends the <code>Message</code> class, meaning it inherits the <code>type</code> and <code>user</code> fields.</li> <li>It adds two new fields: <code>topic</code> (the name of the topic to publish to) and <code>message</code> (the actual content of the message).</li> <li>The constructor calls the <code>super()</code> constructor to initialize the <code>type</code> and <code>user</code> fields.  It then initializes the <code>topic</code> and <code>message</code> fields.</li> <li>There are getter methods to access the <code>topic</code> and <code>message</code>.</li> <li>The <code>toString()</code> method includes the <code>topic</code> and <code>message</code> in the textual representation of the message.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Message</code> class, the basic building block for communication between clients and the broker. We've seen how different message types inherit from the <code>Message</code> class and add their own specific information. We also reviewed <code>ConnectMsg</code>, <code>PublishMsg</code>.</p> <p>In the next chapter, we'll dive deeper into the MessageType enumeration, which defines all the different types of messages that can be exchanged.</p>"},{"location":"oblig2/04_messagetype_/","title":"Chapter 4: MessageType","text":"<p>In the previous chapter, Message, we learned how messages are structured to carry information between clients and the broker. But how does the broker know what to do with a message? That's where <code>MessageType</code> comes in!</p> <p>Why do we need MessageType?</p> <p>Imagine you're a postal worker. You receive lots of letters and packages. How do you know whether to deliver a letter to a house, send a package overseas, or throw something away as junk mail? You look at the label on the envelope! The <code>MessageType</code> is like that label. It tells the broker what kind of message it's dealing with.</p> <p>For example, if a client wants to connect to the broker, it sends a message with the <code>MessageType</code> set to <code>CONNECT</code>. The broker then knows that it needs to establish a connection with the client. If the client wants to publish data, it sends a message with the <code>MessageType</code> set to <code>PUBLISH</code>. The broker then knows to distribute the data to the appropriate subscribers.</p> <p>Key Concepts</p> <p><code>MessageType</code> is what we call an enumeration (or \"enum\" for short). An enumeration is simply a fixed list of possible values. In our case, the <code>MessageType</code> enum defines all the possible types of messages that can be sent between clients and the broker.</p> <p>Think of it like a set of predefined labels:</p> <ul> <li><code>CONNECT</code>: A client wants to connect to the broker.</li> <li><code>DISCONNECT</code>: A client wants to disconnect from the broker.</li> <li><code>SUBSCRIBE</code>: A client wants to subscribe to a topic.</li> <li><code>UNSUBSCRIBE</code>: A client wants to unsubscribe from a topic.</li> <li><code>PUBLISH</code>: A client wants to publish data to a topic.</li> <li><code>CREATETOPIC</code>: A client wants to create a new topic.</li> <li><code>DELETETOPIC</code>: A client wants to delete an existing topic.</li> <li><code>STATUS</code>: A status message (e.g., from the broker).</li> </ul> <p>Using MessageType: A Simple Example</p> <p>Let's say we're building a temperature sensor client that wants to publish temperature data. When the client sends the temperature, it needs to tell the broker, \"Hey, this is a PUBLISH message!\"</p> <p>Here's how we'd use <code>MessageType</code> in a simplified <code>PublishMsg</code> (remembering from Message that <code>PublishMsg</code> is a type of <code>Message</code>):</p> <pre><code>PublishMsg publishMessage = new PublishMsg(\"sensor1\", \"temperature\", \"25 degrees\");\n\nMessageType messageType = publishMessage.getType();\n\nSystem.out.println(\"Message Type: \" + messageType);\n</code></pre> <p>Explanation:</p> <ul> <li>We create a <code>PublishMsg</code> object, specifying the user, topic, and message content.</li> <li>We call <code>publishMessage.getType()</code> to get the <code>MessageType</code> of the message. Because this is a <code>PublishMsg</code>, the message type will be <code>PUBLISH</code>.</li> <li>The <code>System.out.println()</code> statement will print out: \"Message Type: PUBLISH\".</li> </ul> <p>How it works: Internally</p> <p>Let's see how the Broker uses <code>MessageType</code> to figure out what to do with incoming messages.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Broker\n    participant Dispatcher\n\n    Client-&gt;&gt;Broker: Send Message (MessageType = PUBLISH)\n    Broker-&gt;&gt;Broker: Examine MessageType\n    Broker-&gt;&gt;Dispatcher: Call appropriate method based on MessageType\n    activate Dispatcher\n    Dispatcher--&gt;&gt;Broker: Return\n    deactivate Dispatcher\n</code></pre> <p>Here's a breakdown of the steps:</p> <ol> <li> <p>The Client sends a message to the Broker. This message includes the <code>MessageType</code>.</p> </li> <li> <p>The Broker receives the message and looks at the <code>MessageType</code> field.</p> </li> <li> <p>Based on the <code>MessageType</code> (e.g., <code>PUBLISH</code>), the Broker calls the appropriate method in the Dispatcher to handle the message (e.g., <code>dispatcher.onPublish()</code>).</p> </li> </ol> <p>Relevant Code Snippets</p> <p>Here's the <code>MessageType</code> enum itself:</p> <pre><code>package no.hvl.dat110.messages;\n\npublic enum MessageType {\n\n    CONNECT, DISCONNECT, SUBSCRIBE, UNSUBSCRIBE, PUBLISH, CREATETOPIC, DELETETOPIC, STATUS;\n\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>enum</code> keyword defines an enumeration.</li> <li>The names <code>CONNECT</code>, <code>DISCONNECT</code>, <code>SUBSCRIBE</code>, etc., are the possible values of the <code>MessageType</code> enum.</li> </ul> <p>Here's how the broker might use the <code>MessageType</code> to handle a message (simplified):</p> <pre><code>Message message = MessageUtils.receive(connection);\n\nswitch (message.getType()) {\n    case CONNECT:\n        // Handle CONNECT message\n        System.out.println(\"Received a CONNECT message\");\n        break;\n    case PUBLISH:\n        // Handle PUBLISH message\n        System.out.println(\"Received a PUBLISH message\");\n        break;\n    // ... other cases\n    default:\n        System.out.println(\"Unknown message type\");\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>switch</code> statement checks the <code>MessageType</code> of the received message.</li> <li>Based on the <code>MessageType</code>, the code executes the corresponding block of code. This is a very common pattern for handling different types of messages.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>MessageType</code> enumeration and how it's used to identify the type of a message. We've seen how the broker uses the <code>MessageType</code> to determine how to handle incoming messages.</p> <p>In the next chapter, we'll explore the MessageUtils class, which provides utility methods for working with messages, such as converting them to and from a format suitable for network transmission.</p>"},{"location":"oblig2/05_messageutils_/","title":"Chapter 5: MessageUtils","text":"<p>In the previous chapter, MessageType, we learned how to label our messages so the broker knows what to do with them. Now, how do we actually send these messages across the network? That's where <code>MessageUtils</code> comes in!</p> <p>Imagine you're sending a package overseas. You can't just write the address on the item itself! You need to put it in a box, label it correctly, and maybe even wrap it with tape. <code>MessageUtils</code> is like that packing service for our messages. It takes our nicely structured Message objects and prepares them for transport across the network.</p> <p>Why do we need MessageUtils?</p> <p>The core problem is that Java objects (like our <code>Message</code> objects) can't be directly sent over a network. Networks transmit data as streams of bytes. <code>MessageUtils</code> bridges this gap by:</p> <ol> <li>Converting Messages to JSON: JSON (JavaScript Object Notation) is a text-based format that's easy for computers to read and write. <code>MessageUtils</code> converts our <code>Message</code> objects into JSON strings. Think of it as translating a Java object into a universal language that can be understood by different systems.</li> <li>Converting JSON to Byte Arrays:  The JSON string is then converted into a byte array, which is the format that can actually be sent over the network.</li> <li>Converting Byte Arrays back to Messages: On the receiving end (either the client or the broker), <code>MessageUtils</code> does the reverse: it converts the byte array back into a JSON string, and then back into a <code>Message</code> object.</li> </ol> <p>Essentially, <code>MessageUtils</code> acts as a translator and packer/unpacker, ensuring that our messages can be reliably sent and received over the network. It uses the <code>gson</code> library to handle the JSON conversions.</p> <p>Key Concepts</p> <p>The <code>MessageUtils</code> class provides several important utility methods:</p> <ol> <li><code>toJson(Message msg)</code>: Converts a <code>Message</code> object into a JSON string.</li> <li><code>fromJson(String msg)</code>: Converts a JSON string back into a <code>Message</code> object.</li> <li><code>getBytes(Message msg)</code>: Converts a <code>Message</code> object into a byte array (via JSON).</li> <li><code>fromBytes(byte[] payload)</code>: Converts a byte array back into a <code>Message</code> object (via JSON).</li> <li><code>toTransportMessage(Message msg)</code>: Wraps a <code>Message</code> in a TransportMessage.</li> <li><code>fromTransportMessage(TransportMessage msg)</code>: Unwraps a TransportMessage and returns the <code>Message</code>.</li> <li><code>send(Connection connection, Message message)</code>: Sends a <code>Message</code> through a given Connection.</li> <li><code>receive(Connection connection)</code>: Receives a <code>Message</code> from a given Connection.</li> </ol> <p>Using MessageUtils: A Simple Example</p> <p>Let's say we have a <code>PublishMsg</code> and we want to send it from a client to the broker. Here's how we'd use <code>MessageUtils</code>:</p> <pre><code>PublishMsg publishMessage = new PublishMsg(\"sensor1\", \"temperature\", \"25 degrees\");\n\n// Convert the message to a byte array\nbyte[] messageBytes = MessageUtils.getBytes(publishMessage);\n\n// (Imagine sending messageBytes over the network...)\n\n// Now, on the receiving end (e.g., the broker):\n// Convert the byte array back to a Message\nMessage receivedMessage = MessageUtils.fromBytes(messageBytes);\n\n// Now we can work with the receivedMessage as a normal Message object\nif (receivedMessage instanceof PublishMsg) {\n    PublishMsg receivedPublishMessage = (PublishMsg) receivedMessage;\n    System.out.println(\"Received topic: \" + receivedPublishMessage.getTopic());\n    System.out.println(\"Received message: \" + receivedPublishMessage.getMessage());\n}\n</code></pre> <p>Explanation:</p> <ol> <li>We create a <code>PublishMsg</code> object, just like in the Message chapter.</li> <li>We use <code>MessageUtils.getBytes()</code> to convert the <code>PublishMsg</code> into a byte array. This is the format that can be sent over the network.</li> <li>(Imaginary network transmission happens here.)</li> <li>On the receiving end, we use <code>MessageUtils.fromBytes()</code> to convert the byte array back into a <code>Message</code> object.</li> <li>We check if the received message is actually a <code>PublishMsg</code> (it's good practice to verify the type!).</li> <li>We cast the <code>Message</code> to a <code>PublishMsg</code> so we can access its specific fields (topic and message).</li> <li>We can then access the topic and message content from the <code>PublishMsg</code>.</li> </ol> <p>Example Output:</p> <pre><code>Received topic: temperature\nReceived message: 25 degrees\n</code></pre> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside <code>MessageUtils</code> when we convert a <code>Message</code> to a byte array.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant MessageUtils\n    participant Gson\n\n    Client-&gt;&gt;MessageUtils: getBytes(PublishMsg)\n    MessageUtils-&gt;&gt;MessageUtils: toJson(PublishMsg)\n    MessageUtils-&gt;&gt;Gson: toJson(PublishMsg)\n    activate Gson\n    Gson--&gt;&gt;MessageUtils: JSON String\n    deactivate Gson\n    MessageUtils--&gt;&gt;MessageUtils: Encode JSON String to bytes\n    MessageUtils--&gt;&gt;Client: byte[] (JSON String as bytes)\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The <code>Client</code> calls <code>MessageUtils.getBytes()</code>, passing in a <code>PublishMsg</code> object.</li> <li><code>MessageUtils.getBytes()</code> calls <code>MessageUtils.toJson()</code> to convert the <code>PublishMsg</code> into a JSON string.</li> <li><code>MessageUtils.toJson()</code> uses the <code>Gson</code> library to perform the JSON conversion.</li> <li><code>Gson</code> converts the <code>PublishMsg</code> into a JSON string.</li> <li><code>MessageUtils.toJson()</code> returns the JSON string to <code>MessageUtils.getBytes()</code>.</li> <li><code>MessageUtils.getBytes()</code> converts the JSON string into a byte array.</li> <li><code>MessageUtils.getBytes()</code> returns the byte array to the <code>Client</code>.</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the <code>toJson()</code> and <code>fromJson()</code> methods in <code>src/main/java/no/hvl/dat110/messages/MessageUtils.java</code>:</p> <pre><code>public static String toJson(Message msg) {\n    Gson gson = new Gson();\n    String json = gson.toJson(msg);\n    return json;\n}\n\npublic static Message fromJson(String msg) {\n    JsonObject json = JsonParser.parseString(msg).getAsJsonObject();\n    String typestr = json.get(\"type\").getAsString();\n    MessageType type = MessageType.valueOf(typestr);\n\n    Gson gson = new Gson();\n    Message message = null;\n\n    switch (type) {\n        case CONNECT:\n            message = gson.fromJson(json, ConnectMsg.class);\n            break;\n        // ... other cases\n        default:\n            Logger.log(\"fromJson - unknown message type\");\n            break;\n    }\n\n    return message;\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>toJson()</code>: This method takes a <code>Message</code> object as input and uses <code>Gson</code> to convert it into a JSON string. It simply returns the JSON string.</li> <li><code>fromJson()</code>: This method takes a JSON string as input. First, it parses the JSON string to extract the <code>type</code> field, which indicates the MessageType of the message. Then, based on the <code>MessageType</code>, it uses <code>Gson</code> to convert the JSON string into the appropriate <code>Message</code> object (e.g., <code>ConnectMsg</code>, <code>PublishMsg</code>). This is why we need the <code>MessageType</code> \u2013 to know how to deserialize the JSON.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>MessageUtils</code> class and how it helps us prepare messages for transmission over the network. We've seen how it converts <code>Message</code> objects into JSON strings and byte arrays, and back again.</p> <p>In the next chapter, we'll explore the Connection class, which provides the actual network connection between clients and the broker.</p>"},{"location":"oblig2/06_connection_/","title":"Chapter 6: Connection","text":"<p>In the previous chapter, MessageUtils, we learned how to package our messages into a format suitable for sending over the network. Now, we need a way to actually send those packaged messages! That's where the <code>Connection</code> class comes in.</p> <p>Think of the <code>Connection</code> as a physical pipe connecting two houses. Messages are like water flowing through the pipe. The <code>Connection</code> lets the Client and the Broker send and receive raw data (byte arrays) back and forth. It's a lower-level abstraction than the <code>ClientSession</code> (which we'll cover later in ClientSession), focusing on the actual data transmission.</p> <p>Why do we need a Connection?</p> <p>Imagine you're building a chat application. You need a reliable way to send messages between users. The <code>Connection</code> class provides this reliability by:</p> <ol> <li>Establishing a TCP Connection: The <code>Connection</code> uses TCP (Transmission Control Protocol), a reliable, ordered, and error-checked protocol for sending data over the internet. Think of it like a guaranteed delivery service for your messages.</li> <li>Providing Send and Receive Methods: It gives you simple methods to send and receive data as byte arrays.</li> <li>Handling Low-Level Network Details: It takes care of the complexities of network communication, so you can focus on your application logic.</li> </ol> <p>Key Concepts</p> <p>The <code>Connection</code> class has a few key components:</p> <ol> <li>Socket:  This is the underlying TCP socket that represents the network connection. Think of it as the actual endpoint of the pipe.</li> <li>Input Stream:  This allows you to read data coming into the connection. It's like the receiving end of the pipe.</li> <li>Output Stream: This allows you to write data out of the connection. It's like the sending end of the pipe.</li> </ol> <p>Using the Connection: A Simple Example</p> <p>Let's say a client wants to send a simple \"Hello, Broker!\" message to the broker. Here's how we might use the <code>Connection</code> class:</p> <pre><code>// Assuming we already have a Connection object called \"connection\"\n\nString message = \"Hello, Broker!\";\nbyte[] messageBytes = message.getBytes(); // Convert string to bytes\n\nTransportMessage transportMessage = new TransportMessage(messageBytes);\n\nconnection.send(transportMessage);\n\nSystem.out.println(\"Message sent!\");\n</code></pre> <p>Explanation:</p> <ol> <li>We start with a simple String message.</li> <li>We convert the String into a byte array because that's what the <code>Connection</code> works with.</li> <li>We wrap the byte array in a <code>TransportMessage</code>. The <code>TransportMessage</code> helps with encapsulating data for sending and receiving.</li> <li>We use the <code>connection.send()</code> method to send the <code>TransportMessage</code> (containing the bytes) over the network.</li> </ol> <p>Receiving a Message</p> <pre><code>// Assuming we already have a Connection object called \"connection\"\n\nTransportMessage receivedTransportMessage = connection.receive();\n\nbyte[] receivedBytes = receivedTransportMessage.getPayload();\n\nString receivedMessage = new String(receivedBytes); // Convert bytes to string\n\nSystem.out.println(\"Received message: \" + receivedMessage);\n</code></pre> <p>Explanation:</p> <ol> <li>We use the <code>connection.receive()</code> method to receive a <code>TransportMessage</code> from the network.</li> <li>We extract the byte array from the <code>TransportMessage</code>.</li> <li>We convert the byte array back into a String to read the message.</li> </ol> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>Connection</code> class when we call <code>send()</code>.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Connection\n    participant DataOutputStream\n    participant Socket\n\n    Client-&gt;&gt;Connection: send(TransportMessage)\n    Connection-&gt;&gt;TransportMessage: encapsulate()\n    TransportMessage--&gt;&gt;Connection: byte[]\n    Connection-&gt;&gt;DataOutputStream: write(byte[])\n    activate DataOutputStream\n    DataOutputStream-&gt;&gt;Socket: write(byte[])\n    Socket--&gt;&gt;DataOutputStream: Acknowledge receipt\n    deactivate DataOutputStream\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The <code>Client</code> calls the <code>send()</code> method of the <code>Connection</code>, passing in a <code>TransportMessage</code> containing the data to be sent.</li> <li>The <code>Connection</code> calls <code>encapsulate()</code> on the <code>TransportMessage</code> to get the byte array representation of the data.</li> <li>The <code>Connection</code> uses the <code>DataOutputStream</code> to write the byte array to the underlying <code>Socket</code>.</li> <li>The <code>Socket</code> transmits the data over the network.</li> </ol> <p>Relevant Code Snippets</p> <p>Here's a simplified version of the <code>send()</code> method in <code>src/main/java/no/hvl/dat110/messagetransport/Connection.java</code>:</p> <pre><code>public class Connection {\n\n    private DataOutputStream outStream;\n    private Socket socket;\n\n    public Connection(Socket socket) {\n        try {\n            this.socket = socket;\n            outStream = new DataOutputStream(socket.getOutputStream());\n        } catch (IOException ex) {\n            System.out.println(\"Connection: \" + ex.getMessage());\n        }\n    }\n\n    public void send(TransportMessage message) {\n        try {\n            byte[] sendbuf = message.encapsulate(); // Encapsulate data\n            outStream.write(sendbuf); // Write to the output stream\n        } catch (IOException ex) {\n            System.out.println(\"Connection: \" + ex.getMessage());\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>send()</code> method first calls <code>message.encapsulate()</code> to get the byte array representation of the <code>TransportMessage</code>. This byte array contains all the information needed to be sent.</li> <li>Then, it uses <code>outStream.write()</code> to write the byte array to the output stream. This sends the data over the network connection.</li> </ul> <p>Relevant Code Snippets</p> <p>Here's a simplified version of the <code>receive()</code> method in <code>src/main/java/no/hvl/dat110/messagetransport/Connection.java</code>:</p> <pre><code>public class Connection {\n\n    private DataInputStream inStream;\n\n    public TransportMessage receive() {\n        TransportMessage message;\n        byte[] recvbuf;\n\n        recvbuf = new byte[MessageConfig.SEGMENTSIZE];\n\n        try {\n            int read = inStream.read(recvbuf,0, MessageConfig.SEGMENTSIZE);\n\n            if (read != MessageConfig.SEGMENTSIZE) {\n                throw new IOException(\"receive - missing data\");\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Connection: \" + ex.getMessage());\n        }\n\n        message = new TransportMessage();\n\n        message.decapsulate(recvbuf);\n\n        return message;\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>receive()</code> method reads from the input stream into a byte array <code>recvbuf</code>.</li> <li>Then, it creates a new <code>TransportMessage</code> and uses the <code>decapsulate()</code> method to populate the <code>TransportMessage</code> object from the byte array.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Connection</code> class and how it provides a reliable way to send and receive raw data over a network connection. We've seen how it uses TCP sockets, input streams, and output streams to handle the low-level details of network communication. The <code>Connection</code> class provides the foundation for building more complex messaging systems.</p> <p>In the next chapter, we'll explore the Dispatcher class, which is responsible for handling incoming messages and routing them to the appropriate recipients.</p>"},{"location":"oblig2/07_dispatcher_/","title":"Chapter 7: Dispatcher","text":"<p>In the previous chapter, Connection, we learned how to establish a connection between a client and the broker and send raw data back and forth. But once the broker receives the data, how does it know what to do with it? That's where the <code>Dispatcher</code> comes in!</p> <p>Think of the <code>Dispatcher</code> as the traffic controller at an airport. Airplanes (messages) arrive, and the traffic controller directs them to the correct runway (handler) based on their type (e.g., arriving, departing, emergency). The <code>Dispatcher</code> receives messages from connected clients, figures out what kind of message it is (using the MessageType we learned about!), and then calls the right method to handle it.</p> <p>Why do we need a Dispatcher?</p> <p>Imagine a scenario where you have many different types of messages: connecting, disconnecting, publishing data, subscribing to topics, etc. Without a <code>Dispatcher</code>, the <code>Broker</code> would have to handle every single message type directly. This would make the <code>Broker</code> code very long, complex, and hard to maintain.</p> <p>The <code>Dispatcher</code> solves this problem by:</p> <ol> <li>Centralizing Message Handling: It provides a single place to handle all incoming messages.</li> <li>Decoupling Message Types from the Broker:  The <code>Broker</code> doesn't need to know about the specifics of each message type. It just passes the message to the <code>Dispatcher</code> and lets it handle the rest.</li> <li>Routing Messages to the Correct Handlers:  It determines the message type and calls the appropriate handler method.</li> </ol> <p>Key Concepts</p> <p>The <code>Dispatcher</code> has a few key concepts:</p> <ol> <li>Message Handling: The <code>Dispatcher</code>'s main job is to receive messages from clients.</li> <li>Message Type Determination: It uses the MessageType to figure out what kind of message it is (e.g., CONNECT, PUBLISH, SUBSCRIBE).</li> <li>Handler Methods: It has different methods for handling different message types (e.g., <code>onConnect()</code>, <code>onPublish()</code>, <code>onSubscribe()</code>). These methods contain the logic for processing each type of message.</li> <li>Storage: It interacts with the Storage to manage topics, subscribers, and client sessions. We will learn about it in the next chapter.</li> </ol> <p>Using the Dispatcher: A Simple Example</p> <p>Let's say a client sends a <code>PublishMsg</code> to the broker. Here's how the <code>Dispatcher</code> would handle it:</p> <ol> <li>The Broker receives the <code>PublishMsg</code> from the client.</li> <li>The <code>Broker</code> passes the <code>PublishMsg</code> to the <code>Dispatcher</code>.</li> <li>The <code>Dispatcher</code> examines the MessageType of the message. It sees that the type is <code>PUBLISH</code>.</li> <li>The <code>Dispatcher</code> calls the <code>onPublish()</code> method to handle the <code>PublishMsg</code>.</li> <li>The <code>onPublish()</code> method retrieves the topic and message content from the <code>PublishMsg</code> and then forwards the message to all clients subscribed to that topic.</li> </ol> <p>Relevant Code Snippet:</p> <pre><code>public void dispatch(ClientSession client, Message msg) {\n\n    MessageType type = msg.getType();\n\n    switch (type) {\n        case PUBLISH:\n            onPublish((PublishMsg) msg);\n            break;\n        // ... other message types\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>This code snippet shows how the <code>Dispatcher</code> uses a <code>switch</code> statement to determine which handler method to call based on the <code>MessageType</code>.</li> <li>If the <code>MessageType</code> is <code>PUBLISH</code>, it calls the <code>onPublish()</code> method, casting the <code>Message</code> to a <code>PublishMsg</code> so that the handler has access to the topic and message content.</li> </ul> <p>The <code>onPublish</code> Method:</p> <pre><code>public void onPublish(PublishMsg msg) {\n    Logger.log(\"onPublish:\" + msg.toString());\n    // Get subscribers to the topic\n    Set&lt;String&gt; users = storage.getSubscribers(msg.getTopic());\n\n    // Iterate through the subscribers and send them the message\n    for (String user : users) {\n        ClientSession clientSession = storage.clients.get(user);\n        clientSession.send(msg);\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>onPublish</code> method retrieves all users subscribed to the topic from the Storage.</li> <li>It iterates through these subscribers, retrieves their <code>ClientSession</code>, and sends the <code>PublishMsg</code> to each of them using the <code>ClientSession.send()</code> method.</li> </ul> <p>Under the Hood: How it Works</p> <p>When a message arrives at the broker, here's a simplified sequence of events involving the <code>Dispatcher</code>:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Broker\n    participant Dispatcher\n    participant Storage\n    participant ClientSession\n\n    Client-&gt;&gt;Broker: Send PublishMsg (topic, message)\n    Broker-&gt;&gt;Dispatcher: dispatch(PublishMsg, clientSession)\n    activate Dispatcher\n    Dispatcher-&gt;&gt;Dispatcher: Determine MessageType (PUBLISH)\n    Dispatcher-&gt;&gt;Dispatcher: onPublish(PublishMsg)\n    Dispatcher-&gt;&gt;Storage: getSubscribers(topic)\n    Storage--&gt;&gt;Dispatcher: Set&lt;String&gt; users\n    loop For each user in users\n        Dispatcher-&gt;&gt;Storage: clients.get(user)\n        Storage--&gt;&gt;Dispatcher: ClientSession\n        Dispatcher-&gt;&gt;ClientSession: send(PublishMsg)\n        ClientSession--&gt;&gt;Dispatcher: Ack\n    end\n    Dispatcher--&gt;&gt;Broker: Done\n    deactivate Dispatcher\n</code></pre> <p>Here's the breakdown:</p> <ol> <li>The <code>Client</code> sends a <code>PublishMsg</code> to the <code>Broker</code>.</li> <li>The <code>Broker</code> calls the <code>dispatch()</code> method of the <code>Dispatcher</code>, passing in the <code>PublishMsg</code> and the <code>ClientSession</code> associated with the client.</li> <li>The <code>Dispatcher</code> determines that the message type is <code>PUBLISH</code> and calls the <code>onPublish()</code> method.</li> <li>The <code>onPublish()</code> method retrieves the list of subscribers for the topic from the <code>Storage</code>.</li> <li>For each subscriber, it retrieves the corresponding <code>ClientSession</code> from the <code>Storage</code> and sends the <code>PublishMsg</code> to that client.</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the <code>doProcess()</code> method in <code>src/main/java/no/hvl/dat110/broker/Dispatcher.java</code>:</p> <pre><code>@Override\npublic void doProcess() {\n\n    Collection&lt;ClientSession&gt; clients = storage.getSessions();\n\n    for (ClientSession client : clients) {\n\n        Message msg = null;\n\n        if (client.hasData()) {\n            msg = client.receive();\n        }\n\n        if (msg != null) {\n            dispatch(client, msg);\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>doProcess()</code> method is the main loop of the <code>Dispatcher</code>.</li> <li>It iterates through all the active <code>ClientSession</code> objects stored in the <code>Storage</code>.</li> <li>For each <code>ClientSession</code>, it checks if there is any data available to be read using <code>client.hasData()</code>.</li> <li>If there is data, it calls <code>client.receive()</code> to receive a Message.</li> <li>If a message is received (<code>msg != null</code>), it calls the <code>dispatch()</code> method to handle the message.</li> </ul> <p>How the <code>onConnect()</code> method is used</p> <p>The <code>onConnect</code> method is particularly important as it's the entrypoint for new clients.</p> <pre><code>public void onConnect(ConnectMsg msg, Connection connection) {\n\n    String user = msg.getUser();\n\n    Logger.log(\"onConnect:\" + msg.toString());\n\n    storage.addClientSession(user, connection);\n\n}\n</code></pre> <p>Explanation:</p> <ul> <li>This method is called by the Broker when a new client attempts to connect.</li> <li>It extracts the username from the <code>ConnectMsg</code>.</li> <li>It creates a new ClientSession object (we will dive into it later) and associates it with the client's username and Connection.</li> <li>Finally, it adds the new <code>ClientSession</code> to the <code>Storage</code>, allowing the <code>Dispatcher</code> to manage the client's messages.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Dispatcher</code> and how it acts as the brain of the broker, routing messages to the appropriate handler methods. We've seen how it uses the MessageType to determine the message type and how it interacts with the Storage to manage topics and subscribers. The <code>Dispatcher</code> is essential for managing the complexity of a messaging system.</p> <p>In the next chapter, we'll explore the Storage class, which is responsible for storing topics, subscribers, and client sessions.</p>"},{"location":"oblig2/08_storage_/","title":"Chapter 8: Storage","text":"<p>In the previous chapter, Dispatcher, we learned how the <code>Dispatcher</code> acts as the traffic controller, routing messages to the correct handlers. But where does the <code>Dispatcher</code> get the information it needs to make those routing decisions? That's where the <code>Storage</code> class comes in!</p> <p>Think of the <code>Storage</code> class as a filing cabinet in the broker's office. It stores essential information like:</p> <ul> <li>Which clients are currently connected.</li> <li>What topics each client is subscribed to.</li> </ul> <p>This information is crucial for the broker to know where to route messages when a publisher sends data to a specific topic.</p> <p>Why do we need Storage?</p> <p>Imagine you're running a news service. Clients subscribe to different categories (topics) like \"Sports\", \"Politics\", and \"Technology\". When a new article (message) is published, the broker needs to know which clients are interested in that category so it can deliver the article to them.</p> <p>Without the <code>Storage</code> class, the broker would have no way of knowing which clients are subscribed to which topics! It would be like shouting the news article to everyone, even people who aren't interested.</p> <p>The <code>Storage</code> class solves this problem by:</p> <ol> <li>Storing Client Sessions: It keeps track of all currently connected clients and their associated ClientSession objects (we'll learn about <code>ClientSession</code> in the next chapter).</li> <li>Storing Subscriptions: It stores information about which clients are subscribed to which topics.</li> <li>Providing Access to Information: It provides methods for the Dispatcher to access this information so it can route messages correctly.</li> </ol> <p>Key Concepts</p> <p>The <code>Storage</code> class relies on these core concepts:</p> <ol> <li>Client Sessions: A <code>ClientSession</code> represents a connection between a client and the broker. It holds information about the client, such as its username and the Connection object.</li> <li>Subscriptions: A subscription represents a client's interest in a particular topic.</li> <li>Concurrent Hash Maps: The <code>Storage</code> class uses <code>ConcurrentHashMap</code> to store client sessions and subscriptions. <code>ConcurrentHashMap</code> is a thread-safe data structure, meaning that multiple threads can access and modify it safely at the same time. This is crucial in a multi-threaded environment like a message broker.</li> </ol> <p>Using the Storage: A Simple Example</p> <p>Let's say we have a client named \"sensor1\" who wants to subscribe to the \"temperature\" topic. Here's how the <code>Storage</code> class would be used:</p> <ol> <li>The Dispatcher receives a <code>SubscribeMsg</code> from \"sensor1\" requesting to subscribe to \"temperature\".</li> <li>The <code>Dispatcher</code> calls the <code>addSubscriber()</code> method of the <code>Storage</code> class to add \"sensor1\" as a subscriber to the \"temperature\" topic.</li> <li>Later, when a <code>PublishMsg</code> is received for the \"temperature\" topic, the <code>Dispatcher</code> calls the <code>getSubscribers()</code> method of the <code>Storage</code> class to get a list of all subscribers to the \"temperature\" topic.</li> <li>The <code>Storage</code> class returns a list containing \"sensor1\".</li> <li>The <code>Dispatcher</code> then sends the <code>PublishMsg</code> to \"sensor1\".</li> </ol> <p>Example Code Snippet:</p> <pre><code>// Assuming we have a Storage object called \"storage\"\nString topic = \"temperature\";\nString user = \"sensor1\";\n\n// Add \"sensor1\" as a subscriber to the \"temperature\" topic\nstorage.addSubscriber(user, topic);\n\n// Get all subscribers to the \"temperature\" topic\nSet&lt;String&gt; subscribers = storage.getSubscribers(topic);\n\n// Print the subscribers\nSystem.out.println(\"Subscribers to \" + topic + \": \" + subscribers);\n</code></pre> <p>Example Output:</p> <pre><code>Subscribers to temperature: [sensor1]\n</code></pre> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>Storage</code> class when the <code>Dispatcher</code> calls the <code>addSubscriber()</code> method.</p> <pre><code>sequenceDiagram\n    participant Dispatcher\n    participant Storage\n\n    Dispatcher-&gt;&gt;Storage: addSubscriber(user, topic)\n    Storage-&gt;&gt;Storage: subscriptions.get(topic)\n    Storage-&gt;&gt;Storage: Add user to the set of subscribers\n    Storage--&gt;&gt;Dispatcher: Done\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The Dispatcher calls the <code>addSubscriber()</code> method of the <code>Storage</code> class, passing in the username and the topic.</li> <li>The <code>Storage</code> class retrieves the set of subscribers for the given topic from the <code>subscriptions</code> map.</li> <li>The <code>Storage</code> class adds the username to the set of subscribers.</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the <code>addSubscriber()</code> method in <code>src/main/java/no/hvl/dat110/broker/Storage.java</code>:</p> <pre><code>public class Storage {\n\n    protected ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt; subscriptions;\n\n    public void addSubscriber(String user, String topic) {\n        // TODO: add the user as subscriber to the topic\n        subscriptions.get(topic).add(user);\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>addSubscriber()</code> method takes the username and topic as input.</li> <li>It retrieves the set of subscribers for the given topic from the <code>subscriptions</code> map using <code>subscriptions.get(topic)</code>.</li> <li>It then adds the username to the set of subscribers using <code>add(user)</code>.</li> </ul> <p>Let's look at the <code>createTopic()</code> method in <code>src/main/java/no/hvl/dat110/broker/Storage.java</code>:</p> <pre><code>public class Storage {\n\n    protected ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt; subscriptions;\n\n    public void createTopic(String topic) {\n        // TODO: create topic in the storage\n        subscriptions.put(topic, ConcurrentHashMap.newKeySet());\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>createTopic()</code> method takes the topic name as input.</li> <li>It creates a new <code>ConcurrentHashMap.newKeySet()</code> for the topic, which is a thread-safe Set implementation.</li> <li>It puts the topic and the newly created set into the <code>subscriptions</code> map.</li> </ul> <p>Let's look at the <code>addClientSession()</code> method in <code>src/main/java/no/hvl/dat110/broker/Storage.java</code>:</p> <pre><code>public class Storage {\n\n    protected ConcurrentHashMap&lt;String, ClientSession&gt; clients;\n\n    public void addClientSession(String user, Connection connection) {\n        // TODO: add corresponding client session to the storage\n        // See ClientSession class\n        clients.put(user, new ClientSession(user, connection));\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>addClientSession()</code> method takes the username and a Connection object as input.</li> <li>It creates a new ClientSession object, passing in the username and the Connection object. We will explore <code>ClientSession</code> in the next chapter.</li> <li>It puts the username and the new <code>ClientSession</code> object into the <code>clients</code> map.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Storage</code> class and how it acts as a filing cabinet for the broker, storing essential information about clients and their subscriptions. We've seen how it uses <code>ConcurrentHashMap</code> to ensure thread safety and how the Dispatcher interacts with it to route messages correctly.</p> <p>In the next chapter, we'll explore the ClientSession class, which represents a connection between a client and the broker.</p>"},{"location":"oblig2/09_clientsession_/","title":"Chapter 9: ClientSession","text":"<p>In the previous chapter, Storage, we learned how the <code>Storage</code> class acts as the broker's filing cabinet, storing information about clients and their subscriptions. Now, let's zoom in on what it means for a client to actually be connected to the broker. That's where the <code>ClientSession</code> class comes in!</p> <p>Imagine a coffee shop again. The Broker is like the barista, and each customer is a Client. The <code>ClientSession</code> is like the individual interaction the barista has with one specific customer. It remembers who the customer is, what they ordered, and handles all communication related to that particular customer.</p> <p>Why do we need a ClientSession?</p> <p>Think about it: the broker needs to keep track of each client separately. Each client has its own unique connection to the broker. The <code>ClientSession</code> is designed to manage this connection.</p> <p>Let's say a client wants to subscribe to a topic, and then later publish messages to that topic. The broker needs to remember who is subscribing and publishing. The <code>ClientSession</code> class helps the broker keep track of this information for each client.</p> <p>The <code>ClientSession</code> class solves this problem by:</p> <ol> <li>Representing a Connection: It represents a single connection between a client and the broker.</li> <li>Holding Client Information: It stores the client's username.</li> <li>Managing the Underlying Connection: It manages the underlying Connection object, which is the actual communication channel.</li> <li>Providing Send and Receive Methods: It provides methods to send and receive Message objects to and from the client.</li> </ol> <p>Key Concepts</p> <p>The <code>ClientSession</code> has a few key components:</p> <ol> <li>User: The username of the client. This identifies the client.</li> <li>Connection: The Connection object that represents the underlying network connection between the client and the broker.</li> <li>Send Method: A method for sending messages to the client.</li> <li>Receive Method: A method for receiving messages from the client.</li> </ol> <p>Using the ClientSession: A Simple Example</p> <p>Let's say the broker receives a <code>PublishMsg</code> from a client named \"sensor1\". The broker needs to send this message to all other clients that are subscribed to the topic. Here's how the <code>ClientSession</code> class would be used:</p> <ol> <li>The Dispatcher receives a <code>PublishMsg</code> from \"sensor1\".</li> <li>The <code>Dispatcher</code> uses the Storage to find all clients that are subscribed to the topic.</li> <li>For each subscriber, the <code>Dispatcher</code> retrieves the <code>ClientSession</code> object from the Storage.</li> <li>The <code>Dispatcher</code> calls the <code>send()</code> method of the <code>ClientSession</code> object to send the <code>PublishMsg</code> to the subscriber.</li> </ol> <p>Example Code Snippet:</p> <pre><code>// Assuming we have a ClientSession object called \"clientSession\"\nPublishMsg publishMessage = new PublishMsg(\"sensor1\", \"temperature\", \"25 degrees\");\n\n// Send the message to the client\nclientSession.send(publishMessage);\n\nSystem.out.println(\"Message sent to client!\");\n</code></pre> <p>Explanation:</p> <ol> <li>We create a <code>PublishMsg</code> object.</li> <li>We use the <code>clientSession.send()</code> method to send the <code>PublishMsg</code> to the client associated with that <code>ClientSession</code>.</li> </ol> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>ClientSession</code> class when the <code>Dispatcher</code> calls the <code>send()</code> method.</p> <pre><code>sequenceDiagram\n    participant Dispatcher\n    participant ClientSession\n    participant MessageUtils\n    participant Connection\n\n    Dispatcher-&gt;&gt;ClientSession: send(PublishMsg)\n    ClientSession-&gt;&gt;MessageUtils: send(connection, PublishMsg)\n    activate MessageUtils\n    MessageUtils-&gt;&gt;Connection: send(TransportMessage)\n    activate Connection\n    Connection--&gt;&gt;MessageUtils: Ack\n    deactivate Connection\n    MessageUtils--&gt;&gt;ClientSession: Done\n    deactivate MessageUtils\n    ClientSession--&gt;&gt;Dispatcher: Complete\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The Dispatcher calls the <code>send()</code> method of the <code>ClientSession</code> object, passing in the <code>PublishMsg</code>.</li> <li>The <code>ClientSession</code> class calls <code>MessageUtils.send(connection, message)</code> to send the message to the Connection which in turn sends the message over the network.</li> <li>The Connection object sends the message to the client.</li> <li>The <code>ClientSession</code> returns control to the Dispatcher.</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the <code>send()</code> method in <code>src/main/java/no/hvl/dat110/broker/ClientSession.java</code>:</p> <pre><code>public class ClientSession {\n    private Connection connection;\n\n    public void send(Message message) {\n        MessageUtils.send(connection, message);\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>send()</code> method takes a Message object as input.</li> <li>It calls <code>MessageUtils.send(connection, message)</code> to send the message to the client using the underlying Connection object. We utilize MessageUtils because messages need to be converted to <code>byte[]</code> to be transported over network.</li> </ul> <p>Let's look at the <code>receive()</code> method in <code>src/main/java/no/hvl/dat110/broker/ClientSession.java</code>:</p> <pre><code>public class ClientSession {\n    private Connection connection;\n\n    public Message receive() {\n        Message msg = MessageUtils.receive(connection);\n        return msg;\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>receive()</code> method receives a Message from the underlying Connection object. The <code>MessageUtils.receive(connection)</code> handles conversion from <code>byte[]</code> to <code>Message</code> object.</li> <li>It returns the received Message object.</li> </ul> <p>Relevant Code Snippets</p> <p>Here's the <code>hasData()</code> method in <code>src/main/java/no/hvl/dat110/broker/ClientSession.java</code>:</p> <pre><code>public class ClientSession {\n    private Connection connection;\n\n    public boolean hasData() {\n        return connection.hasData();\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>hasData()</code> method checks if the underlying Connection has any data available to read.</li> <li>This check is performed by calling the <code>connection.hasData()</code> method and returning its result. The <code>hasData()</code> prevents the program to wait indefinitely for data, which may never arrive.</li> </ul> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>ClientSession</code> class and how it represents a connection between a client and the broker. We've seen how it stores client information, manages the underlying Connection object, and provides methods to send and receive messages. The <code>ClientSession</code> class is a crucial component for managing client connections in a message broker.</p> <p>In the next chapter, we'll explore the Stopable class, which provides a mechanism for stopping the broker and other components gracefully.</p>"},{"location":"oblig2/10_stopable_/","title":"Chapter 10: Stopable","text":"<p>In the previous chapter, ClientSession, we explored how the <code>ClientSession</code> manages individual connections between clients and the broker. But what if we need to shut down the broker gracefully? How do we ensure that all threads, like the Broker and Dispatcher, stop their work cleanly? That's where the <code>Stopable</code> class comes in!</p> <p>Imagine you're running a server application, like our message broker. You need to be able to stop the server when you're done, but you don't want to just abruptly kill the process. You want to give the server a chance to finish any ongoing tasks and shut down cleanly. The <code>Stopable</code> class provides a way to achieve this.</p> <p>Why do we need Stopable?</p> <p>Without a mechanism for graceful shutdown, our threads (like the Broker and Dispatcher) would potentially be left in an inconsistent state. Imagine the broker abruptly shutting down while it is receiving messages. This can lead to corrupted data or incomplete operations.</p> <p>The <code>Stopable</code> class solves this problem by:</p> <ol> <li>Providing a Base for Threads: It's an abstract class that threads (like our Broker and Dispatcher) can extend.</li> <li>Introducing a <code>stop</code> Flag: It uses a boolean flag (<code>stop</code>) to signal when the thread should stop running.</li> <li>Implementing a Controlled Loop: It defines a <code>run()</code> method that executes a processing loop as long as the <code>stop</code> flag is not set.</li> <li>Providing <code>doStop()</code> and <code>doCont()</code> Methods: It offers methods to set the <code>stop</code> flag (<code>doStop()</code>) and check if the thread should continue running (<code>doCont()</code>).</li> </ol> <p>Key Concepts</p> <p>The <code>Stopable</code> class relies on these core concepts:</p> <ol> <li>Thread Extension: Any class that needs to be gracefully stopped should extend the <code>Stopable</code> class. This inherits the stopping mechanism.</li> <li><code>stop</code> Flag: This boolean variable signals whether the thread should continue running. <code>true</code> means stop, <code>false</code> means continue.</li> <li><code>doProcess()</code> Method: This abstract method contains the actual work that the thread needs to perform.  This must be implemented by the classes which extend Stopable.</li> <li><code>doStop()</code> Method: This method sets the <code>stop</code> flag to <code>true</code>, signaling the thread to stop.</li> <li><code>doCont()</code> Method: This method returns <code>true</code> if the thread should continue running (i.e., <code>stop</code> is <code>false</code>), and <code>false</code> otherwise.</li> </ol> <p>Using Stopable: A Simple Example</p> <p>Let's say we want to create a simple thread that prints numbers from 0 to 9 and then stops. We can use the <code>Stopable</code> class to achieve this.</p> <pre><code>public class NumberPrinter extends Stopable {\n\n    private int number = 0;\n\n    public NumberPrinter() {\n        super(\"Number Printer\"); // Name of the thread\n    }\n\n    @Override\n    public void doProcess() {\n        System.out.println(\"Number: \" + number);\n        number++;\n\n        try {\n            Thread.sleep(500); // Simulate some work\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        NumberPrinter printer = new NumberPrinter();\n        printer.start(); // Start the thread\n\n        Thread.sleep(3000); // Let it run for 3 seconds\n        printer.doStop(); // Signal it to stop\n        printer.join(); // Wait for it to finish\n\n        System.out.println(\"Number printer stopped.\");\n    }\n}\n</code></pre> <p>Explanation:</p> <ol> <li>We create a <code>NumberPrinter</code> class that extends the <code>Stopable</code> class.</li> <li>We override the <code>doProcess()</code> method to define what the thread should do (print a number).</li> <li>In the <code>main()</code> method, we create an instance of <code>NumberPrinter</code> and start it.</li> <li>We let the thread run for 3 seconds, then call <code>printer.doStop()</code> to signal it to stop.</li> <li>We call <code>printer.join()</code> to wait for the thread to finish its work and terminate.</li> </ol> <p>Example Output (approximate):</p> <pre><code>Number: 0\nNumber: 1\nNumber: 2\nNumber: 3\nNumber: 4\nNumber: 5\nNumber printer stopped.\n</code></pre> <p>The thread prints numbers for about 3 seconds, then stops gracefully.</p> <p>Under the Hood: How it Works</p> <p>Let's take a peek at what's happening inside the <code>Stopable</code> class when we call <code>doStop()</code>.</p> <pre><code>sequenceDiagram\n    participant MainThread\n    participant StopableThread\n    participant Stopable\n\n    MainThread-&gt;&gt;StopableThread: doStop()\n    activate StopableThread\n    StopableThread-&gt;&gt;Stopable: doStop()\n    activate Stopable\n    Stopable-&gt;&gt;Stopable: stop = true\n    deactivate Stopable\n    StopableThread--&gt;&gt;MainThread: Stopped\n    deactivate StopableThread\n</code></pre> <p>Here's a step-by-step explanation:</p> <ol> <li>The <code>MainThread</code> (or any other thread) calls the <code>doStop()</code> method on the <code>StopableThread</code>.</li> <li>The <code>doStop()</code> method sets the <code>stop</code> flag to <code>true</code>.</li> <li>The <code>run()</code> method of the <code>StopableThread</code> continuously checks the <code>doCont()</code> method (which returns <code>!stop</code>).</li> <li>When <code>stop</code> is <code>true</code>, <code>doCont()</code> returns <code>false</code>, causing the <code>run()</code> method to exit the loop and the thread to terminate.</li> </ol> <p>Relevant Code Snippets</p> <p>Let's look at the <code>Stopable</code> class itself in <code>src/main/java/no/hvl/dat110/common/Stopable.java</code>:</p> <pre><code>public abstract class Stopable extends Thread {\n\n    private boolean stop = false;\n    protected String name;\n\n    public Stopable(String name) {\n        this.name = name;\n    }\n\n    public synchronized void doStop() {\n        stop = true;\n    }\n\n    private synchronized boolean doCont() {\n        return !stop;\n\n    }\n\n    public abstract void doProcess();\n\n    public void run() {\n\n        Logger.log(name + \" running\");\n\n        while (doCont()) {\n\n            doProcess();\n\n        }\n\n        Logger.log(name + \" stopping\");\n\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>stop</code> variable is a boolean that controls the thread's execution.</li> <li>The <code>doStop()</code> method sets <code>stop</code> to <code>true</code>. It's <code>synchronized</code> to ensure thread safety (multiple threads can't modify <code>stop</code> at the same time).</li> <li>The <code>doCont()</code> method returns <code>true</code> if <code>stop</code> is <code>false</code>, and <code>false</code> otherwise. It's also <code>synchronized</code> for thread safety.</li> <li>The <code>doProcess()</code> method is an abstract method that must be implemented by any class that extends <code>Stopable</code>. This is where the thread's work happens.</li> <li>The <code>run()</code> method is the main loop of the thread. It calls <code>doProcess()</code> repeatedly as long as <code>doCont()</code> returns <code>true</code>. When <code>doCont()</code> returns <code>false</code>, the loop exits, and the thread terminates.</li> </ul> <p>How it's used in Broker and Dispatcher</p> <p>Both the Broker and Dispatcher extend the <code>Stopable</code> class. This allows us to stop these important components cleanly when we need to shut down the broker. When shutting down the server gracefully, <code>doStop()</code> is called on the Broker and Dispatcher threads.</p> <p>Conclusion</p> <p>In this chapter, we've learned about the <code>Stopable</code> class and how it provides a mechanism for gracefully stopping threads. We've seen how it uses a <code>stop</code> flag, <code>doStop()</code> and <code>doCont()</code> methods, and an abstract <code>doProcess()</code> method to control the thread's execution loop. This is crucial for ensuring that our server applications, like the message broker, can be shut down cleanly and safely.</p> <p>This concludes the tutorial for <code>dat110-oblig2</code>! You've now explored all the core components of a message broker. You've learned how to create clients that can connect to a broker, how the broker routes messages, and how to manage client connections. You should now have a solid understanding of building distributed messaging systems!</p>"},{"location":"oblig3/01_file_management___replication_/","title":"Chapter 1: File Management &amp; Replication","text":"<p>Welcome to the first chapter of the DAT110 Project 3 tutorial! We're going to start by looking at how our distributed system handles files.</p> <p>Imagine you have an important digital document, like your homework assignment. If you only store it on your laptop, what happens if your laptop breaks? You lose the file! That's a big problem. In a system with many computers working together (a distributed system), we want to make sure files are safe and available even if some computers fail or leave the network.</p> <p>This chapter introduces File Management &amp; Replication, the part of our system responsible for keeping files safe and findable. Think of it like a super-organized librarian or filing clerk for our network.</p> <p>What You'll Learn:</p> <ul> <li>Why we need to make copies (replicas) of files.</li> <li>How the system decides which computers (nodes) should store these copies.</li> <li>How the system finds the locations of these copies when you need the file back.</li> </ul>"},{"location":"oblig3/01_file_management___replication_/#the-filing-clerk-analogy","title":"The Filing Clerk Analogy","text":"<p>Let's stick with our filing clerk analogy. Imagine a large office building where many people work in different offices (these are our computers, or Nodes).</p> <ol> <li>Receiving a Document: You give an important document (your file) to the central filing clerk (<code>FileManager</code>).</li> <li>Making Copies: The clerk knows one copy isn't safe enough. They make several photocopies (replicas) of the document.</li> <li>Finding Offices: The clerk needs to decide which offices should store these copies. They use the building directory (our Chord system, which we'll learn more about later) to find the right offices based on some identifier for each photocopy.</li> <li>Storing Copies: The clerk sends each photocopy to its assigned office.</li> <li>Finding Copies Later: When you need the document back, you ask the clerk. The clerk again uses the directory to figure out which offices have copies and tells you where they are.</li> </ol> <p>This is exactly what our File Management &amp; Replication system does for digital files!</p>"},{"location":"oblig3/01_file_management___replication_/#key-ideas","title":"Key Ideas","text":"<ol> <li>Replication: Making multiple copies of a file and storing them on different computers (Nodes) in the network. If one computer fails, copies still exist on others. This makes the file reliable and available. We call each copy a replica.</li> <li>Distribution: Deciding where to store each replica. We don't just put them anywhere! We use a clever system based on unique IDs. Every file (or rather, each replica) gets an ID, usually by Hashing its name. Our distributed directory system, Chord, tells us exactly which Node (Peer) is responsible for storing a file with a specific ID.</li> <li>Lookup: Finding out which nodes are currently storing the replicas of a specific file.</li> </ol>"},{"location":"oblig3/01_file_management___replication_/#using-file-management","title":"Using File Management","text":"<p>Let's see how you'd interact with this system, perhaps from a user interface. The main tool we use is the <code>FileManager</code> class.</p> <p>Scenario: You want to upload a file named <code>my_notes.txt</code>.</p> <ol> <li> <p>Prepare the File: First, the <code>FileManager</code> needs to read the file's content from your disk.</p> <pre><code>// In a real application, you'd get the Node object representing this computer\nNodeInterface myself = ... // Represents the current node in the Chord network\n\n// Create a FileManager associated with this node\n// We decide to make 3 replicas of each file (N=3)\nint N = 3;\nFileManager fileManager = new FileManager(myself, N);\n\n// Tell the FileManager where the file is located\nfileManager.setFilepath(\"/path/to/your/my_notes.txt\");\n\ntry {\n    // Read the file content into memory\n    fileManager.readFile();\n    System.out.println(\"Read file: \" + fileManager.getFilename() + \", Size: \" + fileManager.getSizeOfByte() + \" KB\");\n} catch (IOException e) {\n    System.err.println(\"Error reading file: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: We create a <code>FileManager</code> linked to our current position (<code>myself</code>) in the network. We specify we want 3 replicas (<code>N=3</code>). <code>setFilepath</code> tells it which file we're interested in, and <code>readFile</code> loads its name and content.</p> </li> <li> <p>Distribute the Replicas: Now, tell the <code>FileManager</code> to create replicas and spread them across the network.</p> <pre><code>try {\n    // This does the core work: creates replica IDs, finds nodes, and sends copies\n    int replicas_distributed = fileManager.distributeReplicastoPeers();\n    System.out.println(\"Successfully distributed \" + replicas_distributed + \" replicas.\");\n} catch (RemoteException e) {\n    System.err.println(\"Error distributing file replicas: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: The <code>distributeReplicastoPeers()</code> method handles making copies, figuring out where they should go using Chord, and telling the responsible nodes to save them. It returns how many copies were successfully stored.</p> </li> <li> <p>Finding the File Later: Imagine another user (or you, later) wants to find <code>my_notes.txt</code>.</p> <pre><code>try {\n    // Ask the FileManager to find all nodes that have a replica of \"my_notes\"\n    // Note: We pass the base filename without \".txt\" as per how readFile processed it.\n    Set&lt;Message&gt; locations = fileManager.requestActiveNodesForFile(\"my_notes\");\n\n    System.out.println(\"Found \" + locations.size() + \" locations for the file:\");\n    for (Message msg : locations) {\n        // Each 'Message' contains info about a replica and the node storing it\n        System.out.println(\"- Node: \" + msg.getNodeName() + \" (Port: \" + msg.getPort() + \")\");\n    }\n    // Store these locations for later use (e.g., downloading the file)\n    fileManager.setActiveNodesforFile(locations);\n\n} catch (RemoteException e) {\n    System.err.println(\"Error finding file locations: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: <code>requestActiveNodesForFile()</code> takes the base filename. It figures out the replica IDs, uses Chord to find the nodes responsible for those IDs, and asks those nodes if they indeed have the replica's metadata. It returns a <code>Set</code> of Message objects, each describing a replica and the Node (Peer) storing it.</p> </li> </ol>"},{"location":"oblig3/01_file_management___replication_/#how-it-works-under-the-hood","title":"How it Works Under the Hood","text":"<p>Let's peek behind the curtain of <code>FileManager</code>.</p> <p>Distributing Replicas (<code>distributeReplicastoPeers</code>)</p> <ol> <li> <p>Create Replica IDs: The <code>FileManager</code> doesn't just copy the file content <code>N</code> times. It creates <code>N</code> different identifiers. It usually does this by taking the original filename and adding a number (e.g., <code>my_notes0</code>, <code>my_notes1</code>, <code>my_notes2</code>). Then, it calculates the Hash of each of these unique names to get <code>N</code> distinct replica IDs (BigInteger numbers).</p> <pre><code>// Inside FileManager.java createReplicaFiles() method (simplified)\n// Example: filename = \"my_notes\", numReplicas = 3\nfor (int i = 0; i &lt; numReplicas; i++) {\n    String replicaName = filename + i; // e.g., \"my_notes0\", \"my_notes1\", ...\n    BigInteger replicaHash = Hash.hashOf(replicaName); // Calculate unique ID\n    replicafiles[i] = replicaHash; // Store the ID\n}\n</code></pre> </li> <li> <p>Find Responsible Node: For each <code>replicaHash</code>, the <code>FileManager</code> uses the Chord Protocol (specifically, the <code>findSuccessor</code> method of its associated <code>chordnode</code>) to determine which Node (Peer) in the network is responsible for storing data with that specific ID.</p> </li> <li> <p>Send and Store: The <code>FileManager</code> contacts the responsible node found in step 2 (using Remote Communication (RMI)). It tells that node to:</p> <ul> <li>Remember that it's now responsible for this <code>replicaHash</code> (<code>addKey</code>).</li> <li>Save the actual file content (<code>bytesOfFile</code>) along with the original filename and the <code>replicaHash</code> (<code>saveFileContent</code>).</li> <li>Mark one of the replicas randomly as the \"primary\" copy. This is important for keeping all copies consistent when the file is modified, which we'll discuss in the Consistency chapter.</li> </ul> <pre><code>// Inside FileManager.java distributeReplicastoPeers() method (simplified)\nRandom rnd = new Random();\nint primaryIndex = rnd.nextInt(numReplicas); // Pick a random primary\n\nfor (int i = 0; i &lt; replicafiles.length; i++) {\n    BigInteger replicaHash = replicafiles[i];\n\n    // Ask Chord: \"Who is responsible for this ID?\"\n    NodeInterface successor = chordnode.findSuccessor(replicaHash);\n\n    if (successor != null) {\n        // Tell the responsible node: \"You are responsible for this ID\"\n        successor.addKey(replicaHash);\n\n        // Tell the responsible node: \"Save this file content for this ID\"\n        boolean isPrimary = (i == primaryIndex);\n        successor.saveFileContent(filename, replicaHash, bytesOfFile, isPrimary);\n        counter++; // Count successful distributions\n    }\n}\n</code></pre> <p>Explanation: The code iterates through the replica IDs generated earlier. For each ID, it asks its own <code>chordnode</code> (using <code>findSuccessor</code>) to find the correct node (<code>successor</code>) in the distributed network. Then, it remotely calls methods (<code>addKey</code>, <code>saveFileContent</code>) on that <code>successor</code> node to make it store the replica information and content.</p> </li> </ol> <p>Here's a simplified sequence diagram:</p> <pre><code>sequenceDiagram\n    participant User\n    participant FM as FileManager\n    participant CN as ChordNode (Local)\n    participant RNode1 as Responsible Node 1\n    participant RNode2 as Responsible Node 2\n\n    User-&gt;&gt;FM: distributeReplicastoPeers(\"my_notes.txt\")\n    FM-&gt;&gt;FM: createReplicaFiles() -&gt; replicaID1, replicaID2, ...\n    loop For Each Replica ID\n        FM-&gt;&gt;CN: findSuccessor(replicaID1)\n        CN--&gt;&gt;FM: RNode1\n        FM-&gt;&gt;RNode1: addKey(replicaID1)\n        FM-&gt;&gt;RNode1: saveFileContent(\"my_notes\", replicaID1, data, isPrimary?)\n\n        FM-&gt;&gt;CN: findSuccessor(replicaID2)\n        CN--&gt;&gt;FM: RNode2\n        FM-&gt;&gt;RNode2: addKey(replicaID2)\n        FM-&gt;&gt;RNode2: saveFileContent(\"my_notes\", replicaID2, data, isPrimary?)\n        Note over RNode1, RNode2: Each node saves the file data locally.\n    end\n    FM--&gt;&gt;User: Distribution complete (count)</code></pre> <p>Finding Replicas (<code>requestActiveNodesForFile</code>)</p> <p>This process is similar but instead of sending data to the nodes, we ask them for information about the data they already hold.</p> <ol> <li>Create Replica IDs: Just like before, generate the <code>N</code> replica IDs from the base filename (<code>my_notes0</code>, <code>my_notes1</code>, etc., and hash them).</li> <li>Find Responsible Node: For each <code>replicaHash</code>, use <code>chordnode.findSuccessor(replicaHash)</code> to find the node responsible for that ID.</li> <li>Request Metadata: Contact the responsible node and ask for the metadata associated with that specific <code>replicaHash</code> using the <code>getFilesMetadata(replicaHash)</code> method. This metadata is stored as a Message object on the responsible node.</li> <li>Collect Results: Gather all the <code>Message</code> objects received from the responsible nodes. This set contains information about all active replicas and where they are stored.</li> </ol> <pre><code>// Inside FileManager.java requestActiveNodesForFile(filename) (simplified)\nactiveNodesforFile = new HashSet&lt;Message&gt;();\ncreateReplicaFiles(); // Generate replica IDs (e.g., replicafiles array)\n\nfor (BigInteger replicaHash : replicafiles) {\n    // Ask Chord: \"Who is responsible for this ID?\"\n    NodeInterface successor = chordnode.findSuccessor(replicaHash);\n\n    if (successor != null) {\n        // Ask the responsible node: \"What info do you have for this ID?\"\n        Message metadata = successor.getFilesMetadata(replicaHash);\n\n        if (metadata != null) {\n            // If the node has the metadata, add it to our set\n            activeNodesforFile.add(metadata);\n        }\n    }\n}\nreturn activeNodesforFile; // Return the set of locations/metadata\n</code></pre> <p>Explanation: Similar loop structure, but instead of <code>saveFileContent</code>, we call <code>getFilesMetadata</code> on the <code>successor</code> node. This method returns a <code>Message</code> object containing details like the filename, hash, node name, port, etc., which we collect in the <code>activeNodesforFile</code> set.</p>"},{"location":"oblig3/01_file_management___replication_/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about the crucial role of File Management &amp; Replication. We saw why making copies (replicas) is essential for reliability in a distributed system and how the <code>FileManager</code> acts as our coordinator. It uses unique IDs (Hashing) and a distributed directory (Chord Protocol) to figure out where to store these replicas and how to find them later.</p> <p>We've seen what the <code>FileManager</code> does and how it interacts with other parts of the system at a high level. We know that it relies on individual computers, or Nodes, to actually store the data.</p> <p>In the next chapter, we'll zoom in on these individual players: the Node (Peer). We'll explore what a Node is, what information it keeps track of, and its basic responsibilities within the larger network.</p>"},{"location":"oblig3/02_node__peer__/","title":"Chapter 2: Node (Peer)","text":"<p>Welcome to Chapter 2! In the previous chapter, we learned how our system manages files and creates copies (replicas) to keep them safe. We saw how the <code>FileManager</code> acts like a central clerk, deciding where to store these copies. But where exactly do those copies go? They go to the individual computers participating in our network.</p> <p>This chapter introduces the concept of a Node (also called a Peer). Think of it as a single worker or computer that's part of our distributed system.</p> <p>What You'll Learn:</p> <ul> <li>What a Node is and why each one is unique.</li> <li>What important information each Node keeps track of (like its neighbors and the files it's holding).</li> <li>How a Node is created and becomes part of the network.</li> </ul>"},{"location":"oblig3/02_node__peer__/#what-is-a-node-the-office-building-analogy","title":"What is a Node? The Office Building Analogy","text":"<p>Imagine our distributed system is like a very large, circular office building.</p> <ul> <li>Node: Each individual office in the building is a Node. It's a single computer or process running our software.</li> <li>Unique ID: Every office has a unique room number (e.g., Office #101, Office #253). Similarly, every Node has a unique Node ID. This ID helps us tell nodes apart and organize them. We usually get this ID by taking the Node's network address (like an IP address or a name) and running it through a special function called Hashing.</li> <li>Neighbors: Since the building is circular, each office knows the office immediately next to it (its Successor) and the office immediately before it (its Predecessor). Nodes in our system also keep track of their direct neighbors in a logical ring structure, which we'll explore more in the Chord Protocol chapter.</li> <li>Storage: Each office is responsible for storing certain documents or files. Our Nodes are responsible for storing specific file replicas, determined by the Hashing of the file's replica ID. If a replica's ID matches the Node's responsibilities, that Node stores the file data.</li> </ul> <p>So, a Node (Peer) is a fundamental building block \u2013 a single, identifiable participant in the network that knows its immediate neighbors and holds a piece of the shared data.</p>"},{"location":"oblig3/02_node__peer__/#key-information-a-node-holds","title":"Key Information a Node Holds","text":"<p>Let's look inside one of these \"offices\" (our <code>Node</code> object in the code). What does it need to know?</p> <ol> <li><code>nodeID</code> (BigInteger): The unique identifier for this Node. Calculated using Hashing. It's a large number.</li> <li><code>nodename</code> (String): A human-readable name or address for the node (like \"node1.example.com\" or \"192.168.1.10\").</li> <li><code>port</code> (int): The network port number this Node uses to listen for incoming connections, crucial for Remote Communication (RMI).</li> <li><code>successor</code> (NodeInterface): A reference (like a phone number) to the next Node in the logical ring.</li> <li><code>predecessor</code> (NodeInterface): A reference to the previous Node in the logical ring.</li> <li><code>keys</code> (Set): A list of all the file replica IDs that this Node is currently responsible for storing. Remember from Chapter 1, the <code>FileManager</code> tells a Node to <code>addKey()</code> when assigning it a replica. <li><code>filesMetadata</code> (Map): The actual information about the files this Node is storing. For each <code>key</code> (replica ID) the Node is responsible for, it stores a Message object containing details like the original filename, the replica ID, and whether it's the primary copy. This is where the file content itself (or information about it) is managed."},{"location":"oblig3/02_node__peer__/#creating-and-starting-a-node","title":"Creating and Starting a Node","text":"<p>How does a computer become a Node in our system? We use two main classes: <code>Node</code> and <code>NodeServer</code>.</p> <ol> <li> <p><code>NodeServer</code>: This class acts like the building manager for a specific office. Its job is to:</p> <ul> <li>Create the actual <code>Node</code> object (the office itself).</li> <li>Set up the communication infrastructure (Remote Communication (RMI)) so other nodes can contact this one. Think of it as installing the phone line in the office.</li> <li>Register the Node with a central directory (the RMI Registry) using its <code>nodename</code>, so others can find it.</li> </ul> </li> <li> <p><code>Node</code>: This is the class representing the office we discussed. When <code>NodeServer</code> creates a <code>Node</code> object, the <code>Node</code> constructor does the following:</p> <ul> <li>Takes the <code>nodename</code> and <code>port</code> as input.</li> <li>Calculates its unique <code>nodeID</code> using <code>Hash.hashOf(nodename)</code>.</li> <li>Initializes its internal state: sets up empty storage for <code>keys</code> and <code>filesMetadata</code>, and prepares other components like those for lookups and updates (which we'll cover later).</li> </ul> </li> </ol> <p>Example: Starting a Node</p> <p>Let's see simplified code for starting a Node named \"node101\" that listens on port 9091.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/NodeServer.java (Simplified)\n\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport no.hvl.dat110.rpc.interfaces.NodeInterface;\n\npublic class NodeServer {\n\n    private String nodename;\n    private int port;\n    private NodeInterface chordnode; // Holds the actual Node object\n\n    public NodeServer(String nodename, int port) {\n        this.nodename = nodename;\n        this.port = port;\n        start(); // Start the server immediately\n        // In the real code, Chord protocols are started here too\n    }\n\n    public void start() {\n        try {\n            // 1. Create the Node object (the \"office\")\n            chordnode = new Node(nodename, port); // Calls the Node constructor\n\n            // 2. Set up the RMI Registry (the \"phone directory\") on the specified port\n            Registry registry = LocateRegistry.createRegistry(port);\n\n            // 3. Register this Node in the directory with its name\n            registry.bind(nodename, chordnode);\n\n            System.out.println(nodename + \" server running on port \" + port);\n\n        } catch (Exception e) {\n            System.err.println(\"Error starting Node Server: \" + e.getMessage());\n        }\n    }\n\n    public NodeInterface getNode() {\n        return chordnode; // Method to get the created Node object\n    }\n\n    // --- Main method to run this example ---\n    public static void main(String[] args) {\n        // Start a node named \"node101\" on port 9091\n        new NodeServer(\"node101\", 9091);\n    }\n}\n</code></pre> <p>Explanation: 1.  We create a <code>NodeServer</code> instance, giving it a name (\"node101\") and a port (9091). 2.  The <code>start()</code> method is called. 3.  Inside <code>start()</code>, <code>new Node(\"node101\", 9091)</code> creates our actual Node participant. The <code>Node</code> constructor calculates its unique ID from \"node101\". 4.  <code>LocateRegistry.createRegistry(port)</code> sets up the RMI communication listener on port 9091. 5.  <code>registry.bind(nodename, chordnode)</code> makes this specific <code>Node</code> object available over the network under the name \"node101\". Now other nodes can find and talk to it using Remote Communication (RMI).</p> <p>Inside the <code>Node</code> Constructor</p> <p>What happens when <code>new Node(nodename, port)</code> is called?</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/Node.java (Simplified Constructor)\n\nimport java.math.BigInteger;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.HashSet;\nimport java.util.HashMap;\n// ... other imports\n\n// Node extends UnicastRemoteObject to allow RMI calls\npublic class Node extends UnicastRemoteObject implements NodeInterface {\n\n    private BigInteger nodeID;\n    protected String nodename;\n    private int port;\n    private NodeInterface successor;\n    private NodeInterface predecessor;\n    private Set&lt;BigInteger&gt; keys;           // Stores IDs of files this node is responsible for\n    private Map&lt;BigInteger, Message&gt; filesMetadata; // Stores info about those files\n\n    // ... other fields for Chord, Mutex, etc.\n\n    public Node(String nodename, int port) throws RemoteException {\n        super(); // Needed for UnicastRemoteObject\n        this.port = port;\n        this.nodename = nodename;\n\n        // Calculate the unique ID using Hashing\n        this.nodeID = Hash.hashOf(nodename);\n\n        // Initialize storage - initially empty\n        this.keys = new HashSet&lt;BigInteger&gt;();\n        this.filesMetadata = new HashMap&lt;BigInteger, Message&gt;();\n\n        // Initialize successor and predecessor to null (will be set later by Chord)\n        this.successor = null;\n        this.predecessor = null;\n\n        // ... initialize other helper objects (Lookup, Updater, Mutex)\n\n        System.out.println(\"Node created: \" + nodename + \" (ID: \" + nodeID + \")\");\n    }\n\n    // ... other methods like getNodeID(), addKey(), getFilesMetadata() ...\n}\n</code></pre> <p>Explanation: The constructor simply takes the name and port, calculates the <code>nodeID</code> using the <code>Hash.hashOf()</code> method (which we'll explore in Hashing &amp; ID Space), and prepares empty containers (<code>HashSet</code>, <code>HashMap</code>) to store the <code>keys</code> (file replica IDs) and <code>filesMetadata</code> it will eventually be responsible for. It also initializes its neighbors (<code>successor</code>, <code>predecessor</code>) to <code>null</code> - the Chord Protocol will be responsible for finding and setting these later.</p>"},{"location":"oblig3/02_node__peer__/#how-nodes-interact-a-glimpse","title":"How Nodes Interact (A Glimpse)","text":"<p>Nodes don't just sit there; they interact. We saw in Chapter 1 how the <code>FileManager</code> interacts with Nodes. For example, to store a file replica:</p> <ol> <li>The <code>FileManager</code> calculates the replica ID (a <code>BigInteger</code>).</li> <li>It uses the Chord Protocol (specifically, the <code>findSuccessor</code> method on its own Node) to find the Node responsible for that ID. Let's say it finds \"Node 253\".</li> <li>The <code>FileManager</code> then uses Remote Communication (RMI) to call methods on \"Node 253\".</li> <li>It might call <code>Node253.addKey(replicaID)</code> to tell Node 253 it's now responsible for this ID.</li> <li>It might call <code>Node253.saveFileContent(filename, replicaID, fileData, isPrimary)</code> to send the actual file data and metadata for storage. Node 253 would then store this information in its <code>keys</code> set and <code>filesMetadata</code> map.</li> </ol> <p>Here's a simplified sequence diagram showing this:</p> <pre><code>sequenceDiagram\n    participant FM as FileManager (on Node A)\n    participant NodeA as Node A (Local)\n    participant NodeB as Node B (Remote)\n\n    FM-&gt;&gt;NodeA: findSuccessor(replicaID)\n    Note over NodeA: Uses Chord logic...\n    NodeA--&gt;&gt;FM: NodeB is responsible\n    FM-&gt;&gt;NodeB: addKey(replicaID) via RMI\n    Note over NodeB: Node B adds replicaID to its 'keys' set\n    FM-&gt;&gt;NodeB: saveFileContent(file, ID, data, primary) via RMI\n    Note over NodeB: Node B stores data in its 'filesMetadata' map</code></pre> <p>This shows that a Node isn't just passive storage. It actively participates by responding to requests from other parts of the system, managing its own set of responsibilities (<code>keys</code>), and storing the associated data (<code>filesMetadata</code>).</p>"},{"location":"oblig3/02_node__peer__/#conclusion","title":"Conclusion","text":"<p>We've now met the individual workers in our distributed system: the Nodes or Peers. Each Node is like an office in our circular building \u2013 it has a unique ID (<code>nodeID</code>), knows its neighbors (<code>successor</code>, <code>predecessor</code>), and is responsible for storing a specific set of file replicas (<code>keys</code> and <code>filesMetadata</code>).</p> <p>We saw how a <code>NodeServer</code> brings a <code>Node</code> to life and connects it to the network's communication system. Understanding the Node is crucial because everything in the distributed system ultimately happens on or between these Nodes.</p> <p>In the next chapter, we'll dive deeper into how these Nodes talk to each other across the network using Remote Communication (RMI). We'll see how the <code>FileManager</code> (or any Node) can call methods on a remote Node as if it were right there!</p>"},{"location":"oblig3/03_remote_communication__rmi__/","title":"Chapter 3: Remote Communication (RMI)","text":"<p>Welcome to Chapter 3! In the previous chapter, we met the individual computers, or Nodes (Peers), that make up our distributed system. We learned that each Node is like an office in a large building, with its own ID, neighbors, and responsibility for storing certain files.</p> <p>But how do these separate offices talk to each other? If the <code>FileManager</code> on Node A decides that Node B should store a file replica, how does Node A tell Node B to do that? They need a way to communicate across the network.</p> <p>This chapter introduces Remote Communication (RMI), the technology that lets our Nodes interact as if they were making direct calls to each other, even when they're physically separated.</p> <p>What You'll Learn:</p> <ul> <li>What Remote Method Invocation (RMI) is and why it's useful.</li> <li>How one Node can \"call a function\" on another Node across the network.</li> <li>The basic components needed for RMI to work (Interfaces, Stubs, Registry).</li> </ul>"},{"location":"oblig3/03_remote_communication__rmi__/#the-office-phone-system-analogy","title":"The Office Phone System Analogy","text":"<p>Think back to our office building analogy for Nodes. How does Office A ask Office B to file a document? Office A doesn't physically walk over there. Instead, Office A uses the internal phone system.</p> <ol> <li>Look up the number: Office A looks up Office B's extension number in the building directory.</li> <li>Dial the number: Office A dials the extension.</li> <li>Make the request: When Office B answers, Office A says, \"Hi, could you please file this document under ID XYZ?\"</li> <li>Get confirmation: Office B performs the task and confirms, \"Okay, document XYZ is filed.\"</li> </ol> <p>Java RMI (Remote Method Invocation) works exactly like this for our software Nodes:</p> <ul> <li>Building Directory: The RMI Registry is like the central phone directory where Nodes register their names and \"extensions\" (network addresses/ports).</li> <li>Phone Call: Making an RMI call is like dialing another Node.</li> <li>Request: Asking the other Node to \"file the document\" is like invoking a method (calling a function) on the remote Node object.</li> <li>Confirmation: Getting the confirmation back is like receiving the return value from the remote method.</li> </ul> <p>RMI allows a piece of code running on one computer (Node A) to call a method on an object residing on a different computer (Node B) seamlessly, as if the object were right there in Node A's own memory.</p>"},{"location":"oblig3/03_remote_communication__rmi__/#key-rmi-concepts","title":"Key RMI Concepts","text":"<p>To make this phone system work, we need a few pieces:</p> <ol> <li> <p>The Remote Interface (<code>NodeInterface</code>): This is like a menu of services or a list of requests that an \"office\" (Node) knows how to handle. It defines which methods can be called remotely. Any Node wanting to be callable by others must promise to implement the methods listed in this interface.</p> <p>Analogy: The phone directory might list \"Office B - Filing Services, Document Retrieval\". The interface defines what you can ask Office B to do.</p> </li> <li> <p>The Server Object (<code>Node</code>): This is the actual object living on the remote computer that implements the Remote Interface. It contains the real code that performs the requested task when called.</p> <p>Analogy: The actual person or department in Office B who performs the filing or retrieval when called.</p> </li> <li> <p>The Stub: This is a special helper object that lives on the caller's machine (Node A). When Node A wants to call a method on Node B, it actually calls the method on the Stub object. The Stub looks exactly like the real remote object (it implements the same <code>NodeInterface</code>), but its job is purely to handle the network communication: package up the request, send it to Node B, wait for the response, and unpack it.</p> <p>Analogy: This is like a \"speed dial\" button on Office A's phone labeled \"Office B Filing\". Pressing the button looks like you're directly talking to Office B, but the phone system (the Stub) handles the dialing and connection behind the scenes.</p> </li> <li> <p>The RMI Registry: A simple name server where server objects (like our Nodes) register themselves under a unique name. Clients (like other Nodes or the <code>FileManager</code>) can look up these names in the Registry to get the corresponding Stub object, which allows them to make remote calls.</p> <p>Analogy: The central building phone directory where Office B registers its extension number under the name \"Office B\". Office A looks up \"Office B\" to get the extension (the Stub).</p> </li> </ol>"},{"location":"oblig3/03_remote_communication__rmi__/#how-nodes-use-rmi","title":"How Nodes Use RMI","text":"<p>Let's revisit the scenario from Chapter 1: The <code>FileManager</code> (running on Node A) needs to tell Node B to store a replica of a file.</p> <p>Use Case: Node A needs to call the <code>saveFileContent(filename, fileID, data, isPrimary)</code> method on Node B.</p> <p>Step 1: Find Node B's \"Phone Number\" (Get the Stub)</p> <p>Node A needs to get the Stub object for Node B. It knows Node B's name (e.g., \"nodeB_process\") and the port number where Node B's RMI Registry is running (e.g., 9092). It uses a helper function <code>Util.getProcessStub</code> to connect to Node B's Registry and ask for the object named \"nodeB_process\". The Registry sends back the Stub.</p> <pre><code>// Somewhere in Node A's code (e.g., inside FileManager)\nString targetNodeName = \"process2\"; // Name Node B registered with\nint targetPort = 9092;          // Port Node B's RMI registry runs on\n\ntry {\n    // Use a utility function to look up Node B in its RMI registry\n    // This returns the STUB object for Node B\n    NodeInterface nodeB_stub = Util.getProcessStub(targetNodeName, targetPort);\n\n    if (nodeB_stub != null) {\n        System.out.println(\"Successfully obtained a connection (stub) to \" + targetNodeName);\n        // Now we can use nodeB_stub to call methods on the actual Node B\n    } else {\n        System.out.println(\"Could not find or connect to \" + targetNodeName);\n    }\n\n} catch (Exception e) {\n    System.err.println(\"Error connecting to Node B: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: <code>Util.getProcessStub</code> acts like looking up \"process2\" in the phone directory at extension 9092. If successful, it returns <code>nodeB_stub</code>, which is our \"speed dial\" button for Node B.</p> <p>Step 2: Make the \"Phone Call\" (Invoke the Remote Method)</p> <p>Now that Node A has the <code>nodeB_stub</code>, it can call methods on it just like any regular Java object. RMI handles the magic of sending the call over the network to the real Node B.</p> <pre><code>// Continuing from Step 1, assuming nodeB_stub was obtained successfully\n\nString filename = \"my_notes\";\nBigInteger replicaID = someBigIntegerID; // The calculated ID for this replica\nbyte[] fileData = someByteArray;     // The actual content of the file\nboolean isPrimary = false;\n\ntry {\n    // Call the method directly on the stub object!\n    System.out.println(\"Asking Node B to save the file...\");\n    nodeB_stub.saveFileContent(filename, replicaID, fileData, isPrimary);\n    System.out.println(\"Request sent to Node B successfully.\");\n\n    // We could also call other methods defined in NodeInterface, e.g.,\n    // BigInteger nodeB_ID = nodeB_stub.getNodeID();\n    // System.out.println(\"Node B's ID is: \" + nodeB_ID);\n\n} catch (RemoteException e) {\n    // This exception occurs if there's a network problem during the call\n    System.err.println(\"Error calling remote method on Node B: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: We simply call <code>nodeB_stub.saveFileContent(...)</code>. Even though <code>nodeB_stub</code> is an object running on Node A, this call results in the actual <code>saveFileContent</code> method being executed on the real <code>Node</code> object running on Node B's computer. If <code>saveFileContent</code> had a return value, it would be sent back and appear as the result of this call. <code>RemoteException</code> is caught because network errors can happen during the remote communication.</p>"},{"location":"oblig3/03_remote_communication__rmi__/#under-the-hood-how-rmi-works","title":"Under the Hood: How RMI Works","text":"<p>Let's peek behind the curtain. What happens when <code>nodeB_stub.saveFileContent(...)</code> is called?</p> <ol> <li>Stub Packs: The <code>nodeB_stub</code> on Node A takes the method name (\"saveFileContent\") and the arguments (<code>filename</code>, <code>replicaID</code>, <code>fileData</code>, <code>isPrimary</code>) and bundles them into a message. This is called marshalling.</li> <li>Network Send: The stub sends this message over the network to the IP address and port associated with Node B (which it learned from the RMI Registry).</li> <li>Server Receives: Node B's RMI system is constantly listening for incoming network messages on its port (9092 in our example). It receives the message from Node A.</li> <li>Server Unpacks: Node B's RMI system unpacks the message (unmarshalling), figuring out which method needs to be called (<code>saveFileContent</code>) and what the arguments are.</li> <li>Actual Call: The RMI system then calls the <code>saveFileContent</code> method on the real <code>Node</code> object that Node B registered earlier.</li> <li>Execution: The <code>Node</code> object on Node B executes the <code>saveFileContent</code> code, saving the file data to its local storage (<code>filesMetadata</code> map, etc.).</li> <li>(If there's a return value): If the method had a return value, Node B's RMI system would package it up (marshal) and send it back to Node A over the network.</li> <li>(Stub Receives): Node A's stub would receive the response message, unpack it (unmarshal), and return the value to the original caller. (In our <code>saveFileContent</code> example, the method returns <code>void</code>, so there's no return value step).</li> </ol> <p>Here\u2019s a simplified sequence diagram:</p> <pre><code>sequenceDiagram\n    participant NodeA as Node A (Caller)\n    participant StubB as Stub for Node B (on A)\n    participant RMIRegistryB as RMI Registry (on B)\n    participant RMINodeB as RMI Runtime (on B)\n    participant RealNodeB as Actual Node B Object\n\n    NodeA-&gt;&gt;Util: getProcessStub(\"process2\", 9092)\n    Util-&gt;&gt;RMIRegistryB: lookup(\"process2\")\n    RMIRegistryB--&gt;&gt;Util: Stub for Node B\n    Util--&gt;&gt;NodeA: nodeB_stub\n\n    NodeA-&gt;&gt;StubB: saveFileContent(args...)\n    StubB-&gt;&gt;RMINodeB: Marshalled Request (saveFileContent, args) [Network]\n    RMINodeB-&gt;&gt;RMINodeB: Unmarshal Request\n    RMINodeB-&gt;&gt;RealNodeB: saveFileContent(args...)\n    Note over RealNodeB: Executes the method, saves file.\n    RealNodeB--&gt;&gt;RMINodeB: (Returns void)\n    RMINodeB--&gt;&gt;StubB: Acknowledgement (or return value) [Network]\n    StubB--&gt;&gt;NodeA: (Returns void)</code></pre> <p>Key Code Pieces Enabling RMI:</p> <ol> <li> <p>The Interface (<code>NodeInterface.java</code>): Must extend <code>java.rmi.Remote</code>. Methods must declare <code>throws RemoteException</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/interfaces/NodeInterface.java (Simplified)\npackage no.hvl.dat110.rpc.interfaces;\n\nimport java.math.BigInteger;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n// ... other imports\n\npublic interface NodeInterface extends Remote { // Must extend Remote\n\n    // Example methods that can be called remotely\n    BigInteger getNodeID() throws RemoteException; // Must throw RemoteException\n    NodeInterface findSuccessor(BigInteger key) throws RemoteException;\n    void saveFileContent(String filename, BigInteger fileID, byte[] bytesOfFile, boolean primary)\n        throws RemoteException;\n\n    // ... other methods\n}\n</code></pre> </li> <li> <p>The Server Implementation (<code>Node.java</code>): Must implement the <code>NodeInterface</code>. Usually extends <code>java.rmi.server.UnicastRemoteObject</code> to handle server-side RMI logic easily.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/Node.java (Simplified)\npackage no.hvl.dat110.middleware;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n// ... other imports\nimport no.hvl.dat110.rpc.interfaces.NodeInterface;\n\n// Extends UnicastRemoteObject, implements the interface\npublic class Node extends UnicastRemoteObject implements NodeInterface {\n\n    // ... fields like nodeID, nodename, port, filesMetadata ...\n\n    public Node(String nodename, int port) throws RemoteException {\n        super(); // Important call for UnicastRemoteObject\n        // ... initialize fields ...\n    }\n\n    @Override // Implement methods from NodeInterface\n    public void saveFileContent(String filename, BigInteger fileID, byte[] bytesOfFile, boolean primary)\n            throws RemoteException {\n        System.out.println(\"Node \" + nodename + \": Received request to save file \" + filename);\n        // ... Actual logic to store the file in filesMetadata ...\n        System.out.println(\"Node \" + nodename + \": File saved successfully.\");\n    }\n\n    // ... implementations for other NodeInterface methods ...\n}\n</code></pre> </li> <li> <p>Server Registration (<code>NodeServer.java</code>): Creates the <code>Node</code> object and binds it to the RMI Registry.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/NodeServer.java (Simplified Start)\npackage no.hvl.dat110.middleware;\n\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport no.hvl.dat110.rpc.interfaces.NodeInterface;\n\npublic class NodeServer {\n    // ... fields: nodename, port, chordnode ...\n\n    public void start() {\n        try {\n            // 1. Create the actual Node object that will handle calls\n            chordnode = new Node(nodename, port); // 'chordnode' is a NodeInterface\n\n            // 2. Create the RMI Registry on the specified port\n            Registry registry = LocateRegistry.createRegistry(port);\n\n            // 3. Register the Node object with a name in the registry\n            // Now others can look up \"nodename\" on this \"port\"\n            registry.bind(nodename, chordnode);\n\n            System.out.println(nodename + \" server ready on port \" + port);\n\n        } catch (Exception e) {\n            System.err.println(\"Node Server Error: \" + e.getMessage());\n        }\n    }\n    // ... constructor and main method ...\n}\n</code></pre> </li> <li> <p>Client Lookup (<code>Util.java</code>): Finds the registry and looks up the remote object by name to get the stub.</p> <pre><code>// File: src/main/java/no/hvl/dat110/util/Util.java (Simplified getProcessStub)\npackage no.hvl.dat110.util;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport no.hvl.dat110.rpc.interfaces.NodeInterface;\n\npublic class Util {\n\n    public static NodeInterface getProcessStub(String name, int port) {\n        NodeInterface nodestub = null;\n        Registry registry = null;\n        try {\n            // 1. Get a reference to the RMI registry running on 'localhost' at 'port'\n            // (Assumes client and server are on the same machine for simulation)\n            registry = LocateRegistry.getRegistry(\"localhost\", port);\n\n            // 2. Look up the object registered under 'name'\n            // This returns the STUB object\n            nodestub = (NodeInterface) registry.lookup(name);\n\n        } catch (NotBoundException | RemoteException e) {\n            System.err.println(\"Failed to get stub for \" + name + \":\" + port + \" - \" + e.getMessage());\n            return null; // Return null if lookup fails\n        }\n        return nodestub;\n    }\n    // ... other utility methods ...\n}\n</code></pre> </li> </ol>"},{"location":"oblig3/03_remote_communication__rmi__/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored Remote Method Invocation (RMI), the \"internal phone system\" of our distributed application. We learned that RMI allows objects on one Node (Peer) to call methods on objects residing on another Node across the network, almost as easily as calling a local method. We saw the key components: the <code>NodeInterface</code> (the menu of services), the <code>Node</code> object (the actual worker), the RMI Registry (the phone directory), and the Stub (the speed dial button that handles the network details).</p> <p>This ability for Nodes to communicate and trigger actions on each other is fundamental to building a distributed system. It's how file replicas get stored, how Nodes find their neighbors, and how the whole system coordinates its activities.</p> <p>Now that we know how Nodes talk, we need to understand what they often talk about. One crucial piece of information is the unique identifier assigned to both Nodes and files. In the next chapter, we'll dive into Hashing &amp; ID Space to see how these unique IDs are created and why they are so important for organizing our distributed system.</p>"},{"location":"oblig3/04_hashing___id_space_/","title":"Chapter 4: Hashing &amp; ID Space","text":"<p>Welcome to Chapter 4! In the previous chapter, we learned how our individual Nodes (Peers) can talk to each other across the network using Remote Communication (RMI), like using an office phone system.</p> <p>Now, imagine our building again. To make the phone system work, every office needs a unique extension number. Also, if we want to file documents efficiently, each document (or its copy) needs a unique filing code. How do we come up with these unique numbers or codes in a consistent way?</p> <p>This chapter introduces Hashing &amp; ID Space. This is the universal addressing system for our distributed \"building.\" It defines how we generate unique numerical identifiers (IDs) for everything \u2013 both the offices (Nodes (Peers)) and the file copies (File Management &amp; Replication) \u2013 and describes the \"space\" or range where all these addresses live.</p> <p>What You'll Learn:</p> <ul> <li>What hashing is and how it creates unique IDs (like fingerprints).</li> <li>How we use the MD5 algorithm for hashing in this project.</li> <li>What the ID Space is (the range of all possible IDs).</li> <li>Why this ID space is \"circular\" and why that's important.</li> </ul>"},{"location":"oblig3/04_hashing___id_space_/#the-problem-assigning-unique-addresses","title":"The Problem: Assigning Unique Addresses","text":"<p>In our distributed system, we have many Nodes and many file replicas. We need a reliable way to:</p> <ol> <li>Give every Node a unique ID so we can tell them apart and organize them.</li> <li>Give every file replica a unique ID so we know which Node is responsible for storing it.</li> </ol> <p>If Node A wants to find Node B, it needs Node B's unique ID. If a user wants to find a file, the system needs to know the IDs of its replicas to figure out where they are stored. We can't just assign numbers randomly (what if two things get the same number?) or sequentially (what happens when nodes join and leave?). We need a deterministic and consistent method.</p>"},{"location":"oblig3/04_hashing___id_space_/#key-concepts","title":"Key Concepts","text":""},{"location":"oblig3/04_hashing___id_space_/#1-hashing-the-fingerprint-generator","title":"1. Hashing: The Fingerprint Generator","text":"<p>Imagine a magical machine. You feed it any piece of text (like a Node's name \"node101\" or a file replica's name \"my_notes0\"), and it always spits out a unique, fixed-size string of characters or numbers based on the input. This is essentially what a hash function does.</p> <ul> <li>Input: Any data (in our case, usually a String like a name).</li> <li>Output: A fixed-size value, typically a sequence of numbers and letters (or just a very large number), called the hash value or digest.</li> <li>Key Properties:<ul> <li>Deterministic: The same input always produces the same output hash. (Putting \"node101\" in always gives the same result).</li> <li>Uniform: Different inputs should ideally produce very different outputs, spreading the hashes out.</li> <li>One-way: It's practically impossible to figure out the original input just by looking at the output hash.</li> <li>Collision Resistant: It's very unlikely that two different inputs will accidentally produce the same output hash (like two different people having the same fingerprint).</li> </ul> </li> </ul> <p>In this project, we use a specific hash function called MD5 (Message Digest 5). MD5 takes any input and produces a 128-bit output. We represent this 128-bit output as a very large non-negative integer (<code>BigInteger</code> in Java).</p> <p>Analogy: Think of MD5 as a super-precise fingerprint generator. Every person (input string) gets a unique fingerprint (hash value).</p>"},{"location":"oblig3/04_hashing___id_space_/#2-id-space-the-range-of-all-addresses","title":"2. ID Space: The Range of All Addresses","text":"<p>The MD5 hash function produces 128-bit outputs. How many possible unique IDs can we generate with 128 bits? That's 2<sup>128</sup>, which is an astronomically large number!</p> <p>2<sup>128</sup> = 340,282,366,920,938,463,463,374,607,431,768,211,456</p> <p>This enormous range of possible IDs, from 0 up to 2<sup>128</sup> - 1, is called the ID Space. Every Node ID and every file replica ID generated by our MD5 hash function will be a number somewhere within this space.</p> <p>Analogy: If our building used 3-digit room numbers, the ID space would be 000 to 999 (1000 possible addresses). Our MD5 ID space is vastly larger.</p>"},{"location":"oblig3/04_hashing___id_space_/#3-circular-id-space-wrapping-around","title":"3. Circular ID Space: Wrapping Around","text":"<p>Imagine all these possible ID numbers arranged not on a straight line, but on a huge circle, like the numbers on a clock face. The largest number (2<sup>128</sup> - 1) is immediately followed by 0, completing the circle.</p> <pre><code>graph TD\n    subgraph \"Circular ID Space (Conceptual)\"\n        direction LR\n        A(0) --&gt; B(...)\n        B --&gt; C(Node ID 1)\n        C --&gt; D(...)\n        D --&gt; E(File ID X)\n        E --&gt; F(...)\n        F --&gt; G(Node ID 2)\n        G --&gt; H(...)\n        H --&gt; I(2^128 - 1)\n        I --&gt; A\n    end</code></pre> <p>Explanation: This diagram shows a conceptual ring. IDs are points on this circle. The circle connects the maximum ID back to 0. Nodes and File Replicas get assigned IDs that place them somewhere on this ring.</p> <p>This circular arrangement is fundamental to how the Chord Protocol (Ring, Lookup, Stabilization) works. It ensures there are no \"start\" or \"end\" points, making it easy to define concepts like \"the next node on the ring\" (successor) regardless of where you are.</p>"},{"location":"oblig3/04_hashing___id_space_/#how-we-use-hashing-and-the-id-space","title":"How We Use Hashing and the ID Space","text":"<p>We use a utility class called <code>Hash</code> to perform these operations.</p> <p>1. Assigning a Node ID:</p> <p>When a Node (Peer) starts, its unique name (like \"node101\" or the process name like \"process1\") is fed into the hash function to get its permanent <code>nodeID</code>.</p> <pre><code>// In Node.java constructor (Simplified)\nString nodename = \"process1\"; // Example name for this node\nBigInteger nodeID;\n\n// Use the Hash utility to calculate the ID\nnodeID = Hash.hashOf(nodename);\n\nSystem.out.println(\"Node \" + nodename + \" has ID: \" + nodeID);\n</code></pre> <p>Explanation: We call <code>Hash.hashOf()</code> with the node's name. It runs the MD5 algorithm and returns a unique <code>BigInteger</code> which becomes the <code>nodeID</code>. This ID determines the node's position on the circular ID space.</p> <p>Example Output (IDs will vary): <code>Node process1 has ID: 184883359565900980586981169341156351448</code></p> <p>2. Assigning File Replica IDs:</p> <p>As we saw in File Management &amp; Replication, when distributing a file, the <code>FileManager</code> creates multiple replica names (e.g., \"my_notes0\", \"my_notes1\", \"my_notes2\") and hashes each one to get distinct replica IDs.</p> <pre><code>// In FileManager.java createReplicaFiles() method (Simplified)\nString baseFilename = \"my_notes\";\nint numReplicas = 3;\nBigInteger[] replicaIDs = new BigInteger[numReplicas];\n\nfor (int i = 0; i &lt; numReplicas; i++) {\n    String replicaName = baseFilename + i; // e.g., \"my_notes0\"\n    // Use the Hash utility for each replica name\n    replicaIDs[i] = Hash.hashOf(replicaName);\n    System.out.println(\"Replica \" + replicaName + \" has ID: \" + replicaIDs[i]);\n}\n</code></pre> <p>Explanation: Each unique replica name (\"my_notes0\", \"my_notes1\", etc.) is hashed separately. This produces multiple distinct <code>BigInteger</code> IDs, each representing a point on the circular ID space where a copy of the file should ideally be managed.</p> <p>Example Output (IDs will vary): <code>Replica my_notes0 has ID: 26845416607232347001079434980358746769</code> <code>Replica my_notes1 has ID: 337557115089051893325617838048617738677</code> <code>Replica my_notes2 has ID: 179507865398391841007180138972716939810</code></p> <p>3. Determining Responsibility:</p> <p>These generated IDs (both for nodes and file replicas) are crucial for the Chord Protocol (Ring, Lookup, Stabilization). Chord uses these IDs and the circular ID space to determine which Node is responsible for which range of IDs, and therefore, which Node should store which file replica. (We'll see exactly how in the next chapter!)</p>"},{"location":"oblig3/04_hashing___id_space_/#under-the-hood-the-hashjava-utility","title":"Under the Hood: The <code>Hash.java</code> Utility","text":"<p>Let's peek inside the <code>Hash.java</code> utility class to see how it works.</p> <p><code>Hash.hashOf(String entity)</code>:</p> <p>This method takes a string input and returns the MD5 hash as a <code>BigInteger</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/util/Hash.java (Simplified hashOf)\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HexFormat; // Used to convert byte array to hex string\n\npublic class Hash {\n\n    public static BigInteger hashOf(String entity) {\n        BigInteger result = null;\n        try {\n            // 1. Get an MD5 message digest instance\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n            // 2. Convert the input string to bytes\n            byte[] entityBytes = entity.getBytes();\n\n            // 3. Compute the MD5 hash (digest) of the bytes\n            byte[] hashBytes = md.digest(entityBytes); // Returns 16 bytes for MD5\n\n            // 4. Convert the byte array hash into a hexadecimal string\n            String hexHash = HexFormat.of().formatHex(hashBytes);\n\n            // 5. Convert the hexadecimal string into a BigInteger\n            // The '16' means the input string is base-16 (hex)\n            result = new BigInteger(hexHash, 16);\n\n            // Ensure the BigInteger is non-negative\n            result = result.signum() &gt;= 0 ? result : BigInteger.ZERO; // Adjust if negative\n\n        } catch (NoSuchAlgorithmException e) {\n            // This happens if \"MD5\" algorithm is not supported by the Java env\n            e.printStackTrace();\n        }\n        return result;\n    }\n    // ... other methods ...\n}\n</code></pre> <p>Explanation: 1.  <code>MessageDigest.getInstance(\"MD5\")</code>: Gets the Java security object ready to perform MD5 hashing. 2.  <code>entity.getBytes()</code>: Converts the input string (e.g., \"node101\") into raw bytes. 3.  <code>md.digest(entityBytes)</code>: Performs the core MD5 calculation on the bytes, producing a 16-byte array (128 bits). 4.  <code>HexFormat.of().formatHex(hashBytes)</code>: Converts the 16 raw bytes into a 32-character hexadecimal string (like \"d41d8cd98f00b204e9800998ecf8427e\"). 5.  <code>new BigInteger(hexHash, 16)</code>: Parses the hexadecimal string to create the final <code>BigInteger</code> representing the ID. 6.  The check <code>result.signum() &gt;= 0</code> handles a technicality where <code>BigInteger</code> might interpret the leading bit as a sign bit; we ensure our IDs are always positive.</p> <p><code>Hash.bitSize()</code> and <code>Hash.addressSize()</code>:</p> <p>These methods provide information about the ID space.</p> <pre><code>// File: src/main/java/no/hvl/dat110/util/Hash.java (Simplified bitSize/addressSize)\npublic class Hash {\n    // ... hashOf method ...\n\n    public static int bitSize() {\n        try {\n            // Ask the MD5 algorithm for its digest length in bytes\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            int digestlenBytes = md.getDigestLength(); // This is 16 for MD5\n            // Convert bytes to bits\n            return digestlenBytes * 8; // 16 * 8 = 128 bits\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e); // Should not happen for MD5\n        }\n    }\n\n    public static BigInteger addressSize() {\n        // Calculate 2 raised to the power of the number of bits\n        int bits = bitSize(); // Get 128\n        BigInteger base = BigInteger.valueOf(2);\n        BigInteger size = base.pow(bits); // 2^128\n        return size;\n    }\n    // ... toHex method ...\n}\n</code></pre> <p>Explanation: *   <code>bitSize()</code>: Determines the size of the hash output in bits (always 128 for MD5). *   <code>addressSize()</code>: Calculates the total number of possible unique IDs in the space by computing 2<sup>bits</sup> (2<sup>128</sup>).</p>"},{"location":"oblig3/04_hashing___id_space_/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about the crucial concept of Hashing &amp; ID Space. We saw how hash functions, specifically MD5, act like fingerprint generators to create unique, large numerical IDs (<code>BigInteger</code>) for both Nodes (Peers) and file replicas based on their names.</p> <p>These IDs all exist within a vast ID Space (0 to 2<sup>128</sup>-1), which we visualize as being circular. This consistent way of assigning addresses and the circular nature of the space are the absolute foundation for organizing our distributed system.</p> <p>Now that we know how everything gets a unique address and where these addresses live, how do we use this to actually build the network structure, find specific nodes, and determine who is responsible for which file replica IDs? That's exactly what we'll cover in the next chapter on the Chord Protocol (Ring, Lookup, Stabilization).</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/","title":"Chapter 5: Chord Protocol (Ring, Lookup, Stabilization)","text":"<p>Welcome to Chapter 5! In the previous chapter, we learned how Hashing &amp; ID Space provides a unique numerical address (ID) for every Node (Peer) and file replica, placing them all within a vast, circular range of numbers.</p> <p>Now, imagine our office building again. Every office has a unique room number (its ID from Chapter 4). But how do we know which office is next to which? How do we quickly find the office responsible for holding a specific document (using its file replica ID)? And what happens if a new office opens or an existing one closes down? We need a system to manage the building's layout, navigate it, and keep the directory up-to-date.</p> <p>This chapter introduces the Chord Protocol. Think of Chord as the intelligent directory and navigation system for our distributed building. It defines:</p> <ol> <li>Ring: How nodes organize themselves into a logical circle based on their IDs.</li> <li>Lookup: How any node can efficiently find the specific node responsible for a given ID (like a file replica ID).</li> <li>Stabilization: How the system handles nodes joining or leaving the network, keeping the ring structure correct over time.</li> </ol> <p>What You'll Learn:</p> <ul> <li>How nodes form a logical ring using their IDs.</li> <li>How Chord finds the correct node for a specific ID (<code>findSuccessor</code>).</li> <li>Why the ring needs to be maintained (<code>Stabilization</code>) and how it's done.</li> <li>How finger tables help speed up lookups (basic idea).</li> </ul>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#the-problem-finding-who-has-what","title":"The Problem: Finding Who Has What","text":"<p>Let's revisit the core task from File Management &amp; Replication. Suppose you want to store a file, and the <code>FileManager</code> calculates that replica \"my_notes1\" gets the ID <code>3375...677</code> (a huge number from Chapter 4). Which Node (Peer) in the network should store this replica?</p> <p>We can't just ask every single node \u2013 that would be incredibly slow in a large network. We need an efficient way to look up the responsible node based on the replica's ID. This is the main problem Chord solves.</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#key-concepts-of-chord","title":"Key Concepts of Chord","text":""},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#1-the-ring-a-circle-of-nodes","title":"1. The Ring: A Circle of Nodes","text":"<p>Chord organizes nodes in a logical ring according to their numerical IDs (obtained via Hashing &amp; ID Space). Imagine placing the nodes on the giant circular ID space we discussed in Chapter 4.</p> <ul> <li>Each node connects to the node immediately following it in ID order. This next node is called its successor.</li> <li>Each node also often keeps track of the node immediately preceding it, its predecessor.</li> </ul> <pre><code>graph TD\n    subgraph \"Chord Ring (Simplified)\"\n        direction LR\n        N8(Node ID=8) --&gt; N20(Node ID=20)\n        N20 --&gt; N35(Node ID=35)\n        N35 --&gt; N50(Node ID=50)\n        N50 --&gt; N8\n        subgraph Links\n            N8 -- successor --&gt; N20\n            N20 -- successor --&gt; N35\n            N35 -- successor --&gt; N50\n            N50 -- successor --&gt; N8\n            N20 -- predecessor --&gt; N8\n            N35 -- predecessor --&gt; N20\n            N50 -- predecessor --&gt; N35\n            N8 -- predecessor --&gt; N50\n        end\n    end</code></pre> <p>Explanation: Nodes (like N8, N20, etc.) are arranged in a circle based on their IDs. Each node knows its direct <code>successor</code> (the next one clockwise) and <code>predecessor</code> (the previous one counter-clockwise).</p> <p>Responsibility: A node is responsible for storing all the file replica IDs (<code>keys</code>) that fall between its predecessor's ID and its own ID. In the diagram, Node 35 would be responsible for keys with IDs like 21, 22, ..., up to 35. The successor node is always responsible for its own ID.</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#2-lookup-finding-the-responsible-node-findsuccessor","title":"2. Lookup: Finding the Responsible Node (<code>findSuccessor</code>)","text":"<p>The core operation in Chord is <code>findSuccessor(key)</code>. Given a key (like a file replica ID), this function finds the first node in the ring whose ID is equal to or greater than the key (moving clockwise around the ring). This node is the one responsible for that key.</p> <p>How does it work (simplified)?</p> <ol> <li>Check Locally: A node first checks if the <code>key</code> falls between its own ID and its successor's ID. If yes, the successor is the answer!</li> <li>Ask Someone Else: If the key is not handled by the immediate successor, the node needs to ask another node further along the ring to continue the search.</li> <li>Forward the Request: The node intelligently chooses another node (usually using a \"finger table\" - see below) that is closer to the key and forwards the <code>findSuccessor(key)</code> request to that node. This process repeats until the responsible node is found.</li> </ol> <p>Analogy: You're in Office 8 and need to find who handles file ID 42. 1.  You check your successor, Office 20. Is 42 between 8 and 20? No. 2.  You need to jump further. Instead of asking Office 20 (who would ask Office 35, etc.), you might have a shortcut in your directory (finger table) that says \"For IDs around 40-50, try asking Office 35 directly.\" 3.  You call Office 35 and ask it: <code>findSuccessor(42)</code>. 4.  Office 35 checks its successor, Office 50. Is 42 between 35 and 50? Yes! 5.  Office 35 tells you (or the original requester) that Office 50 is responsible for ID 42.</p> <p>Finger Tables (The Shortcuts): Asking only the successor can be slow in a large ring. Each node maintains a \"finger table,\" which is like a list of shortcuts. It contains pointers to nodes at exponentially increasing distances around the ring (e.g., the node 1 step away, 2 steps away, 4 steps away, 8 steps away, etc., in terms of ID distance). When doing a lookup, a node checks its finger table to find the farthest node it knows that is still before the target key. It then forwards the request to that node, significantly speeding up the search. Think of it as having express elevators in the building directory.</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#3-stabilization-keeping-the-ring-healthy","title":"3. Stabilization: Keeping the Ring Healthy","text":"<p>Nodes can join and leave the network at any time. When this happens, the ring structure (successors, predecessors, finger tables) needs to be updated to reflect the changes. This process is called stabilization.</p> <p>Nodes periodically run stabilization protocols:</p> <ul> <li>Check Successor: A node asks its successor, \"Who is your predecessor?\". If the successor's predecessor is actually a node between the current node and the successor, that node should become the current node's new successor. (This handles nodes joining).</li> <li>Notify Successor: A node periodically tells its successor, \"Hey, I exist, and I think you are my successor.\" This allows the successor to update its predecessor if needed.</li> <li>Check Predecessor: A node periodically checks if its predecessor is still responding (alive). If not, it sets its predecessor to <code>null</code>. (This handles nodes leaving abruptly).</li> <li>Fix Fingers: Nodes periodically recalculate their finger table entries to ensure the shortcuts point to the correct, live nodes.</li> </ul> <p>Analogy: Stabilization is like the building management periodically: *   Checking if the office listed next door is still the correct one or if a new office opened in between. *   Reminding the office next door that you exist. *   Checking if the office listed before yours is still occupied. *   Updating the express elevator directory (finger table).</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#using-chord-in-our-project","title":"Using Chord in Our Project","text":"<p>The <code>FileManager</code> (and Nodes themselves) rely heavily on Chord, primarily through the <code>findSuccessor</code> method implemented in <code>ChordLookup.java</code> and accessed via the <code>NodeInterface</code>.</p> <p>Scenario: <code>FileManager</code> needs to find where to store replica ID <code>key = 3375...677</code>. It runs on a node we'll call <code>currentNode</code>.</p> <ol> <li> <p>Initiate Lookup: The <code>FileManager</code> calls <code>findSuccessor(key)</code> on its local <code>currentNode</code> object.</p> <pre><code>// In FileManager, needing to find the node for replicaId\nBigInteger replicaId = Hash.hashOf(\"my_notes1\"); // Get the ID\nNodeInterface currentNode = ... // Get the Node object FileManager is running on\n\ntry {\n    // Ask the local node to find the node responsible for replicaId\n    NodeInterface responsibleNode = currentNode.findSuccessor(replicaId);\n\n    if (responsibleNode != null) {\n        System.out.println(\"Node responsible for ID \" + replicaId + \" is: \" + responsibleNode.getNodeName());\n        // Now FileManager can use RMI to contact responsibleNode\n        // e.g., responsibleNode.saveFileContent(...)\n    } else {\n        System.out.println(\"Could not find responsible node for ID \" + replicaId);\n    }\n} catch (RemoteException e) {\n    System.err.println(\"Error during Chord lookup: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: The <code>FileManager</code>, using its associated <code>NodeInterface</code> (<code>currentNode</code>), calls the <code>findSuccessor</code> method with the target <code>replicaId</code>. Chord handles the potentially complex lookup process across the network transparently. The result (<code>responsibleNode</code>) is an RMI stub (Chapter 3) for the node that should manage this ID.</p> </li> <li> <p>Chord Does the Work: The <code>findSuccessor</code> implementation within <code>currentNode</code> (and potentially other nodes it contacts via RMI) executes the Chord lookup algorithm described earlier (checking successor, using finger tables, forwarding requests) until the correct node is identified.</p> </li> <li> <p>Result: The <code>findSuccessor</code> call returns a reference (<code>NodeInterface</code> stub) to the responsible node. The <code>FileManager</code> can then use this reference to interact with that node (e.g., to store or retrieve the file replica) using Remote Communication (RMI).</p> </li> </ol>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#under-the-hood-how-chord-finds-things","title":"Under the Hood: How Chord Finds Things","text":"<p>Let's look at the core <code>findSuccessor</code> logic in <code>ChordLookup.java</code>.</p> <p><code>findSuccessor(key)</code> Method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chordoperations/ChordLookup.java (Simplified findSuccessor)\n\npublic NodeInterface findSuccessor(BigInteger key) throws RemoteException {\n\n    // Get my own successor node\n    NodeInterface successor = node.getSuccessor();\n    BigInteger nodeID = node.getNodeID();\n    BigInteger succID = successor.getNodeID();\n\n    // 1. Is the key between me (exclusive) and my successor (inclusive)?\n    // Util.checkInterval handles the wrap-around logic for the circular ID space\n    if (Util.checkInterval(key, nodeID.add(BigInteger.ONE), succID)) {\n        // Yes! My successor is responsible for the key.\n        return successor;\n    } else {\n        // 2. No. Need to ask someone closer to the key.\n        // Find the best node in my finger table to forward the request to.\n        NodeInterface highestPred = findHighestPredecessor(key);\n\n        // 3. Ask that node to continue the search.\n        // This is a recursive RMI call!\n        return highestPred.findSuccessor(key);\n    }\n}\n</code></pre> <p>Explanation: 1.  It first checks if the <code>key</code> logically falls between its own <code>nodeID</code> and its direct <code>successor</code>'s ID (<code>succID</code>). The <code>Util.checkInterval</code> function correctly handles the circular nature of the ID space (where the successor might have a smaller ID than the current node if it wraps around past 0). 2.  If the successor is responsible, it's returned immediately. 3.  If not, it calls <code>findHighestPredecessor(key)</code> (explained below) to find the node in its finger table that is \"closest\" to the <code>key</code> without going past it. 4.  It then makes a remote call (using RMI) to that <code>highestPred</code> node, asking it to <code>findSuccessor(key)</code>. This forwards the search efficiently around the ring.</p> <p><code>findHighestPredecessor(key)</code> Method:</p> <p>This helper method searches the node's finger table to find the best shortcut.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chordoperations/ChordLookup.java (Simplified findHighestPredecessor)\n\nprivate NodeInterface findHighestPredecessor(BigInteger key) throws RemoteException {\n    // Get my finger table (list of shortcuts)\n    List&lt;NodeInterface&gt; fingers = node.getFingerTable();\n    BigInteger nodeID = node.getNodeID();\n\n    // Iterate backwards through the finger table (from farthest to closest shortcut)\n    for (int i = fingers.size() - 1; i &gt;= 0; i--) {\n        NodeInterface fingerNode = fingers.get(i);\n\n        if (fingerNode != null) {\n            BigInteger fingerID = fingerNode.getNodeID();\n            // Check if this finger node is between me and the key (exclusive)\n            if (Util.checkInterval(fingerID, nodeID.add(BigInteger.ONE), key.subtract(BigInteger.ONE))) {\n                // Found the best shortcut! Return this node.\n                return fingerNode;\n            }\n        }\n    }\n    // If no finger is better than myself, return myself.\n    return node; // 'node' refers to the current Node object\n}\n</code></pre> <p>Explanation: It looks through the finger table entries (<code>fingers</code>) from the end (longest jump) to the beginning (shortest jump - the successor). It returns the first finger node it finds whose ID is strictly between the current node's ID and the target <code>key</code>. This ensures we make the biggest possible jump towards the key without overshooting it. If no suitable finger is found, it means the current node itself is the closest predecessor, so it returns <code>node</code>.</p> <p>Sequence Diagram: <code>findSuccessor(42)</code> (Example)</p> <p>Imagine Node 8 initiates <code>findSuccessor(42)</code>. Let's say its finger table points to Node 35 as a shortcut for IDs in that range.</p> <pre><code>sequenceDiagram\n    participant N8 as Node 8\n    participant N35 as Node 35 (Finger)\n    participant N50 as Node 50 (Successor of N35)\n\n    N8-&gt;&gt;N8: findSuccessor(42)\n    N8-&gt;&gt;N8: checkInterval(42, 8+1, 20)? --&gt; false\n    N8-&gt;&gt;N8: findHighestPredecessor(42) --&gt; N35 (from finger table)\n    N8-&gt;&gt;N35: findSuccessor(42) via RMI\n    N35-&gt;&gt;N35: checkInterval(42, 35+1, 50)? --&gt; true\n    N35--&gt;&gt;N8: N50 (result)\n    N8--&gt;&gt;N8: return N50</code></pre> <p>Explanation: Node 8 checks its successor (N20), fails. Finds N35 in its finger table as the highest predecessor for 42. It remotely calls <code>findSuccessor(42)</code> on N35. N35 checks its successor (N50). Since 42 is between 35 and 50, N35 returns N50 as the result back to N8.</p> <p>Stabilization Logic:</p> <p>The stabilization code (<code>StabilizationProtocols.java</code>) runs periodically in the background:</p> <ul> <li><code>stabilizeRing()</code>: Asks successor (<code>succ</code>) for its predecessor (<code>predsucc</code>). If <code>predsucc</code> has an ID between <code>nodeID</code> and <code>succID</code>, it means <code>predsucc</code> just joined and should be the new successor. The current node updates its successor to <code>predsucc</code> and notifies <code>predsucc</code>.</li> <li><code>notify(potential_pred)</code>: Called remotely on a node (e.g., <code>succ</code>) by another node (<code>potential_pred</code>) claiming to be its predecessor. The receiving node (<code>succ</code>) checks if <code>potential_pred</code>'s ID is between its current predecessor's ID and its own ID. If yes, it updates its predecessor to <code>potential_pred</code>.</li> <li><code>checkPredecessor()</code>: Pings the current predecessor using RMI (<code>Util.getProcessStub</code>). If the RMI call fails (returns null or throws exception), it means the predecessor is gone, so the node sets its predecessor reference to <code>null</code>.</li> <li><code>fixFingerTable()</code>: Periodically recalculates all finger table entries. For each entry <code>i</code>, it computes <code>start = (nodeID + 2^i) mod addressSize</code> and calls <code>findSuccessor(start)</code> to find the node responsible for that ID, updating the <code>i</code>-th finger.</li> </ul> <pre><code>// File: src/main/java/no/hvl/dat110/chordoperations/StabilizationProtocols.java (Simplified stabilizeRing logic)\n\nprivate void stabilizeRing() {\n    try {\n        NodeInterface succ = chordnode.getSuccessor(); // My successor\n        NodeInterface pred_of_succ = succ.getPredecessor(); // Ask successor for its predecessor (RMI call)\n\n        if (pred_of_succ != null) {\n            BigInteger nodeID = chordnode.getNodeID();\n            BigInteger succID = succ.getNodeID();\n            BigInteger pred_of_succ_ID = pred_of_succ.getNodeID();\n\n            // Is pred_of_succ between me and my successor?\n            boolean cond = Util.checkInterval(pred_of_succ_ID, nodeID.add(BigInteger.ONE), succID.subtract(BigInteger.ONE));\n\n            if (cond) {\n                // Yes, pred_of_succ should be my new successor\n                chordnode.setSuccessor(pred_of_succ);\n            }\n        }\n        // Always notify my current successor that I exist\n        // (This allows the successor to update its predecessor if needed)\n        chordnode.getSuccessor().notify(chordnode);\n\n    } catch (RemoteException e) { /* ... handle error ... */ }\n}\n</code></pre> <p>Explanation: This snippet shows the core check. If a node (<code>pred_of_succ</code>) exists between the current node (<code>chordnode</code>) and its successor (<code>succ</code>), <code>chordnode</code> adopts <code>pred_of_succ</code> as its new direct successor. It then always notifies its (potentially updated) successor.</p>"},{"location":"oblig3/05_chord_protocol__ring__lookup__stabilization__/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored the Chord Protocol, the backbone of our distributed system's organization. We learned how nodes use their unique IDs (Hashing &amp; ID Space) to form a logical Ring. We saw how the crucial Lookup operation (<code>findSuccessor</code>) efficiently finds the node responsible for any given ID, using successor pointers and finger table shortcuts. Finally, we understood the importance of Stabilization protocols, which keep the ring structure accurate even when nodes join or leave, ensuring the system remains robust and navigable. Chord provides the essential directory and navigation services for our distributed office building.</p> <p>Now that we know how nodes are organized and how they find each other, let's look closer at what they actually pass around when communicating. In the next chapter, we'll examine the Message structure, which is used not only for communication requests but also for storing the metadata about the file replicas managed by each node.</p>"},{"location":"oblig3/06_message_/","title":"Chapter 6: Message","text":"<p>Welcome to Chapter 6! In the previous chapter, we learned how the Chord Protocol acts like a clever directory and navigation system, allowing nodes to organize themselves into a ring and efficiently find the node responsible for any given piece of data using its ID.</p> <p>Now, imagine Node A has used Chord to find that Node B is responsible for storing a replica of \"my_notes.txt\". Node A needs to send a request to Node B using Remote Communication (RMI). But what exactly should Node A send? It needs to include the file name, the replica ID, the actual file data, maybe who sent the request, and perhaps some special instructions. Just sending raw bits of data isn't organized. We need a standard format for these communications.</p> <p>This chapter introduces the Message concept. It's a standardized data structure, like a pre-printed form or memo, used to package information neatly when nodes exchange data or requests.</p> <p>What You'll Learn:</p> <ul> <li>Why a standardized <code>Message</code> format is useful for communication.</li> <li>What key pieces of information are included in a <code>Message</code>.</li> <li>How <code>Message</code> objects are created and used in the system.</li> <li>How <code>Message</code> objects are also used to store file metadata on Nodes (Peers).</li> </ul>"},{"location":"oblig3/06_message_/#the-standardized-memo-analogy","title":"The Standardized Memo Analogy","text":"<p>Think of inter-office communication in a large company. If everyone just scribbled notes on random pieces of paper, it would be chaos! Important details might be missed, and processing requests would be slow. Instead, companies often use standardized memo forms.</p> <p>A typical memo form might have fields for:</p> <ul> <li>FROM: (Sender's Name/Department)</li> <li>TO: (Recipient's Name/Department - Implied by delivery)</li> <li>DATE: (When it was sent)</li> <li>SUBJECT: (What is this memo about?)</li> <li>BODY: (The actual content or request)</li> <li>ATTACHMENTS: (Any accompanying documents)</li> <li>URGENT? (Checkbox for priority)</li> <li>ACTION REQUIRED? (Checkbox for status)</li> </ul> <p>Our <code>Message</code> class is exactly like this standardized memo for our distributed system nodes. It ensures that whenever nodes communicate or store information about files, all the necessary details are present in a predictable format.</p>"},{"location":"oblig3/06_message_/#key-information-in-a-message","title":"Key Information in a <code>Message</code>","text":"<p>Let's look at the important fields inside our <code>Message</code> \"memo\":</p> <ol> <li> <p>Sender Information:</p> <ul> <li><code>nodeID</code> (BigInteger): The unique ID of the node sending or associated with this message. (Like the sender's official employee ID).</li> <li><code>nodename</code> (String): The human-readable name of the sender node (e.g., \"process1\").</li> <li><code>port</code> (int): The communication port of the sender node.</li> </ul> </li> <li> <p>File Information (if applicable):</p> <ul> <li><code>nameOfFile</code> (String): The original name of the file this message relates to (e.g., \"my_notes\"). (Like the \"SUBJECT\" line).</li> <li><code>hashOfFile</code> (BigInteger): The specific ID of the file replica this message is about (e.g., the hash of \"my_notes1\").</li> <li><code>bytesOfFile</code> (<code>byte[]</code>): The actual content of the file replica. (Like the \"ATTACHMENTS\"). This isn't always filled, only when sending the file data itself.</li> <li><code>filepath</code> (String): Sometimes used to store the original path of the file, though less critical for internal node communication.</li> </ul> </li> <li> <p>Ordering &amp; Status:</p> <ul> <li><code>clock</code> (int): A Lamport clock timestamp. This is a simple counter used to help determine the order of events across different nodes, which is important for things like Consistency (Remote-Write Protocol). (Like a sequence number on the memo).</li> <li><code>acknowledged</code> (boolean): A flag to indicate if this message has been acknowledged or processed. (Like a \"RECEIVED\" stamp).</li> <li><code>primaryServer</code> (boolean): A special flag indicating if the node holding this file replica is the \"primary\" copy. This is crucial for coordinating updates, as we'll see in the Consistency (Remote-Write Protocol) chapter. (Like an \"ACTION REQUIRED BY:\" checkbox).</li> </ul> </li> </ol>"},{"location":"oblig3/06_message_/#using-message-objects","title":"Using <code>Message</code> Objects","text":"<p><code>Message</code> objects are used in two primary ways:</p> <p>1. Packaging Information for RMI Calls:</p> <p>When one node needs to send data to another using Remote Communication (RMI), it often packages the necessary information into a <code>Message</code> object.</p> <p>Example: Node A (running <code>FileManager</code>) wants to tell Node B to save a file replica.</p> <pre><code>// --- On Node A (inside FileManager or similar) ---\nNodeInterface nodeB_stub = Util.getProcessStub(\"process2\", 9092); // Get RMI stub for Node B\n\n// Details of the replica to be saved\nString filename = \"my_notes\";\nBigInteger replicaId = Hash.hashOf(\"my_notes1\");\nbyte[] fileContent = //... read file content ...\nboolean isPrimary = false; // Assume this is not the primary replica\n\n// Create a Message object to package the info\nMessage fileInfoMsg = new Message(nodeA.getNodeID(), nodeA.getNodeName(), nodeA.getPort());\nfileInfoMsg.setNameOfFile(filename);\nfileInfoMsg.setHashOfFile(replicaId);\nfileInfoMsg.setBytesOfFile(fileContent);\nfileInfoMsg.setPrimaryServer(isPrimary);\n// fileInfoMsg.setClock(...); // Lamport clock would be set here too\n\ntry {\n    // Send the entire Message object via RMI\n    // (Note: In the actual project, RMI methods might take individual parameters\n    // derived from the Message, or the Message itself might be adapted/wrapped)\n\n    // Example hypothetical RMI call:\n    // nodeB_stub.receiveAndStoreFile(fileInfoMsg);\n\n    // OR, more likely based on current NodeInterface:\n    nodeB_stub.saveFileContent(fileInfoMsg.getNameOfFile(),\n                               fileInfoMsg.getHashOfFile(),\n                               fileInfoMsg.getBytesOfFile(),\n                               fileInfoMsg.isPrimaryServer());\n\n    System.out.println(\"Sent file info for \" + filename + \" to Node B.\");\n\n} catch (RemoteException e) {\n    System.err.println(\"Error sending file info: \" + e.getMessage());\n}\n</code></pre> <p>Explanation: Node A gathers all the necessary details about the file replica (<code>filename</code>, <code>replicaId</code>, <code>fileContent</code>, <code>isPrimary</code>, plus sender info). It creates a <code>Message</code> object and uses setter methods (like <code>setNameOfFile</code>, <code>setBytesOfFile</code>) to populate it. This organized <code>Message</code> (or the information extracted from it) is then sent over the network using RMI to Node B.</p> <p>2. Storing File Metadata on Nodes:</p> <p>As mentioned in the Node (Peer) chapter, each node maintains a <code>filesMetadata</code> map:</p> <pre><code>// Inside Node.java\nprivate Map&lt;BigInteger, Message&gt; filesMetadata; // Stores info about files this node holds\n</code></pre> <p>This map uses the file replica ID (<code>BigInteger</code>) as the key. The value stored for each key is a <code>Message</code> object! This <code>Message</code> object holds all the relevant metadata about that specific file replica stored on this node (like its original name, its replica ID, whether it's the primary, its Lamport clock value, etc.). It typically doesn't store the <code>bytesOfFile</code> in this map to save memory; the actual file content might be stored separately on disk, referenced by the metadata.</p> <p>Example: When Node B receives the <code>saveFileContent</code> call from Node A.</p> <pre><code>// --- On Node B (inside Node.java's saveFileContent method) ---\n@Override\npublic void saveFileContent(String filename, BigInteger fileID, byte[] bytesOfFile, boolean primary)\n        throws RemoteException {\n\n    System.out.println(\"Node \" + nodename + \": Received request to save \" + filename + \" (ID: \" + fileID + \")\");\n\n    // Create a Message object to store the *metadata* for this replica\n    // Use info about *this* node (Node B) as the 'sender' in the metadata context\n    Message metaData = new Message(this.nodeID, this.nodename, this.port);\n    metaData.setNameOfFile(filename);\n    metaData.setHashOfFile(fileID);\n    // metaData.setBytesOfFile(null); // Don't store bytes in the metadata map\n    metaData.setPrimaryServer(primary);\n    // metaData.setClock(0); // Initialize clock\n\n    // Store the metadata Message in the map, keyed by the replica ID\n    filesMetadata.put(fileID, metaData);\n\n    // Store the actual file content (bytesOfFile) somewhere else, e.g., on disk\n    // storeBytesToFileSystem(fileID, bytesOfFile); // Hypothetical method\n\n    System.out.println(\"Node \" + nodename + \": Stored metadata for \" + filename);\n}\n</code></pre> <p>Explanation: When Node B is asked to save a file replica, it creates a new <code>Message</code> object to represent the metadata it needs to remember about this replica. It populates this <code>Message</code> with the provided details (<code>filename</code>, <code>fileID</code>, <code>primary</code> status) and information about itself (<code>nodeID</code>, <code>nodename</code>, <code>port</code>). This metadata <code>Message</code> is then stored in the <code>filesMetadata</code> map. This allows Node B to later answer questions like \"What files are you storing?\" or \"Are you the primary for file replica X?\".</p>"},{"location":"oblig3/06_message_/#under-the-hood-the-messagejava-class","title":"Under the Hood: The <code>Message.java</code> Class","text":"<p>The <code>Message</code> class itself is relatively simple. It's primarily a container for data.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/Message.java (Simplified)\n\npackage no.hvl.dat110.middleware;\n\nimport java.io.Serializable; // Important!\nimport java.math.BigInteger;\nimport java.rmi.RemoteException;\n\n// Message must implement Serializable to be sent via RMI\npublic class Message implements Serializable {\n\n    // Unique ID for serialization compatibility\n    private static final long serialVersionUID = 1L;\n\n    // Fields we discussed:\n    private int clock = 0;             // Lamport clock\n    private BigInteger nodeID;         // Sender/Owner Node ID\n    private String nodename;           // Sender/Owner Node Name\n    private int port;                  // Sender/Owner Node Port\n    private boolean acknowledged = false; // Acknowledgment status\n    private String filepath;           // Original file path (optional)\n\n    private byte[] bytesOfFile;        // File content (used for transfer)\n    private BigInteger hashOfFile;     // File replica ID\n    private String nameOfFile;         // Original file name\n\n    private boolean primaryServer;     // Is this the primary replica?\n\n\n    // Constructor to set basic node info\n    public Message(BigInteger nodeID, String nodename, int port) {\n        this.nodeID = nodeID;\n        this.nodename = nodename;\n        this.port = port;\n    }\n\n    // --- Getters and Setters for all fields ---\n    // Example:\n    public String getNameOfFile() {\n        return nameOfFile;\n    }\n    public void setNameOfFile(String nameOfFile) {\n        this.nameOfFile = nameOfFile;\n    }\n    // ... other getters and setters ...\n}\n</code></pre> <p>Explanation: *   <code>implements Serializable</code>: This is crucial. It's a marker interface from Java that tells the Java runtime environment that objects of this class are allowed to be \"flattened\" into a sequence of bytes (serialized) and sent over a network stream (like RMI does) or saved to a file. The receiving end can then reconstruct the original object from these bytes (deserialize). Without <code>Serializable</code>, RMI wouldn't be able to transmit <code>Message</code> objects. *   <code>serialVersionUID</code>: This is a version number used during serialization/deserialization to ensure the sender and receiver are using compatible versions of the <code>Message</code> class. *   Fields: It contains private fields for all the pieces of information we discussed (sender, file, status). *   Constructor: A simple constructor to initialize the basic node information. *   Getters and Setters: Standard methods (<code>getFieldName()</code>, <code>setFieldName(value)</code>) are provided to access and modify the private fields, following standard Java practice for data classes (JavaBeans).</p> <p>There's no complex logic inside the <code>Message</code> class itself; it's just a well-defined container, our standardized memo format.</p>"},{"location":"oblig3/06_message_/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about the <code>Message</code> class, which acts as a standardized information package \u2013 like a memo \u2013 for our distributed system. It bundles together crucial details about the sender, the file involved, status flags, and ordering information.</p> <p>We saw how <code>Message</code> objects are essential for packaging data sent between nodes using Remote Communication (RMI) and how they are also used by each Node (Peer) to store the metadata (<code>filesMetadata</code>) about the file replicas it manages. Using this standard format makes communication and data management much more organized and reliable.</p> <p>Now that we have nodes organized (Chord Protocol (Ring, Lookup, Stabilization)) and a standard way to package information (<code>Message</code>), a critical question arises: if we have multiple copies (replicas) of a file stored on different nodes, how do we ensure they all stay consistent when the file is updated? We'll tackle this challenge in the next chapter on Consistency (Remote-Write Protocol).</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/","title":"Chapter 7: Consistency (Remote-Write Protocol)","text":"<p>Welcome to Chapter 7! In the previous chapter, we learned about the <code>Message</code> structure, a standardized way to package information when nodes communicate or store file metadata. We saw that each Node (Peer) keeps track of the file replicas it stores using these <code>Message</code> objects.</p> <p>Now, remember from Chapter 1 that we make multiple copies (replicas) of each file and store them on different nodes for safety. But this creates a new challenge: what happens if someone updates the file? If we change the content of \"my_notes.txt\" on one node, how do we make sure all the other copies get the same changes? If we don't keep them synchronized, different users might see different versions of the file, leading to confusion!</p> <p>This chapter introduces a strategy called the Remote-Write Protocol (a type of Primary-Copy protocol) to solve this problem and maintain Consistency among replicas.</p> <p>What You'll Learn:</p> <ul> <li>Why keeping replicas consistent after updates is important.</li> <li>The \"Primary Copy\" strategy (Remote-Write Protocol).</li> <li>How to find the primary replica for a file.</li> <li>How updates are sent to the primary and then broadcast to other replicas.</li> </ul>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#the-problem-keeping-copies-in-sync","title":"The Problem: Keeping Copies in Sync","text":"<p>Imagine you and your friends are working together on a shared digital document, like a presentation slide. To make sure the work isn't lost if one computer crashes, the system automatically saves copies of the slide on several different computers (our Nodes (Peers)).</p> <p>Now, you decide to change the title on your copy of the slide. If only your copy is updated, your friends looking at their copies won't see the new title! Their copies are now inconsistent with yours. We need a rule or procedure to ensure that when one copy is updated, all other copies are eventually updated too.</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#key-concept-the-remote-write-primary-copy-strategy","title":"Key Concept: The Remote-Write (Primary Copy) Strategy","text":"<p>The Remote-Write protocol uses a simple but effective strategy: designate one specific copy of the file as the \"master\" or Primary replica. All other copies are considered Secondary replicas.</p> <p>Here's how it works, using our shared document analogy:</p> <ol> <li>Designate a Master Copy: One office (Node) holding a copy of the document is marked as having the \"Master Copy\" (Primary Replica). The <code>FileManager</code> did this randomly when distributing the file (remember the <code>isPrimary</code> flag in <code>saveFileContent</code> from Chapter 1?).</li> <li>Updates Go to the Master: Anyone wanting to change the document must send their proposed changes only to the office holding the Master Copy (the Primary Node). They are not allowed to change their local secondary copies directly.</li> <li>Master Updates Itself: The Primary Node first updates its own Master Copy with the changes.</li> <li>Master Tells Others: After updating itself, the Primary Node sends a message to all other offices (Secondary Nodes) that have a copy, telling them: \"Update your copy with these changes!\"</li> <li>Secondaries Update: Each Secondary Node receives the update instruction from the Primary and updates its local copy accordingly.</li> </ol> <p>This way, all updates are channeled through the Primary, which ensures the changes are applied consistently across all replicas.</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#using-the-remote-write-protocol","title":"Using the Remote-Write Protocol","text":"<p>Let's see how a user (interacting via the <code>FileManager</code>) would update a file using this protocol. Suppose we want to update the content of \"my_notes.txt\".</p> <p>Step 1: Find the Primary Node</p> <p>First, the <code>FileManager</code> needs to know which node holds the primary replica for \"my_notes.txt\". It already knows how to find all nodes holding replicas using <code>requestActiveNodesForFile</code> (from Chapter 1), which returns a set of <code>Message</code> objects. Each <code>Message</code> object has an <code>isPrimaryServer()</code> flag.</p> <pre><code>// --- In FileManager or user application code ---\n\n// Assume we already have the set of active nodes for \"my_notes\"\n// Set&lt;Message&gt; activeNodes = fileManager.requestActiveNodesForFile(\"my_notes\");\n\nNodeInterface primaryNode = null;\nSet&lt;Message&gt; replicas = fileManager.getActiveNodesforFile(); // Get the set of replica locations\n\nif (replicas != null &amp;&amp; !replicas.isEmpty()) {\n    // Loop through the Message objects describing each replica\n    for (Message replicaInfo : replicas) {\n        // Check the flag we learned about in Chapter 6!\n        if (replicaInfo.isPrimaryServer()) {\n            System.out.println(\"Found primary replica on node: \" + replicaInfo.getNodeName());\n            // Use the utility from Chapter 3 to get an RMI stub for the primary\n            primaryNode = Util.getProcessStub(replicaInfo.getNodeName(), replicaInfo.getPort());\n            break; // Found it, stop searching\n        }\n    }\n}\n\nif (primaryNode == null) {\n    System.err.println(\"Error: Could not find the primary node for the file!\");\n    // Handle error...\n}\n</code></pre> <p>Explanation: The code iterates through the <code>Set&lt;Message&gt;</code> called <code>replicas</code>. Each <code>Message</code> describes a node holding a copy. It checks the <code>isPrimaryServer()</code> boolean flag inside each <code>Message</code>. When it finds the one where this flag is <code>true</code>, it uses <code>Util.getProcessStub</code> (our RMI lookup tool from Chapter 3) to get a connection (stub) to that primary node and stores it in <code>primaryNode</code>.</p> <p>Step 2: Send Update Request to the Primary</p> <p>Now that we have the <code>primaryNode</code> stub, we can send the new file content to it. We don't send it to any other nodes. The <code>NodeInterface</code> has a specific method for this: <code>requestRemoteWriteOperation</code>. We need to send the new content (<code>byte[] new_content</code>) and also the full list of all replicas (<code>replicas</code>) so the primary knows who else to notify.</p> <pre><code>// --- Continuing in FileManager or user application code ---\n\n// Let's say 'new_content' is a byte array with the updated file data\nbyte[] new_content = \"Updated content for my notes.\".getBytes();\n\n// Make sure we found the primary and have the list of all replicas\nif (primaryNode != null &amp;&amp; replicas != null &amp;&amp; !replicas.isEmpty()) {\n    try {\n        System.out.println(\"Sending update request to primary node: \" + primaryNode.getNodeName());\n\n        // Call the special RMI method on the primary node ONLY\n        primaryNode.requestRemoteWriteOperation(new_content, replicas);\n\n        System.out.println(\"Update request sent successfully.\");\n\n    } catch (RemoteException e) {\n        System.err.println(\"Error sending remote write request: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Explanation: We simply use the <code>primaryNode</code> stub obtained in Step 1 and call the <code>requestRemoteWriteOperation</code> method via RMI. We pass the <code>new_content</code> and the <code>replicas</code> set (which contains <code>Message</code> objects describing all copies, including the primary and secondaries).</p> <p>This call triggers the primary node to start the update process. The <code>FileManager</code>'s job is now done for initiating the update.</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#internal-implementation-how-the-update-spreads","title":"Internal Implementation: How the Update Spreads","text":"<p>What happens after the primary node receives the <code>requestRemoteWriteOperation</code> call?</p> <p>1. Primary Node Receives the Request (<code>Node.requestRemoteWriteOperation</code>)</p> <p>The primary node's implementation of this method takes the new content and the list of all replicas. Its main job is to immediately trigger the broadcast of this update to all peers (including itself).</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/Node.java (Simplified method)\n\n@Override\npublic void requestRemoteWriteOperation(byte[] updates, Set&lt;Message&gt; activenodes) throws RemoteException {\n    System.out.println(\"Node \" + nodename + \" (Primary): Received remote write request.\");\n\n    // Store the list of active nodes needed for broadcasting\n    this.activenodesforfile = activenodes;\n\n    // Immediately call the broadcast method (which will update self and others)\n    // Note: 'updater' is an instance of UpdateOperations helper class\n    updater.broadcastUpdatetoPeers(activenodesforfile, updates);\n\n    System.out.println(\"Node \" + nodename + \" (Primary): Broadcast initiated.\");\n}\n</code></pre> <p>Explanation: This method on the primary node receives the <code>updates</code> (new content) and the <code>activenodes</code> list. It saves the list and then calls the <code>broadcastUpdatetoPeers</code> method (likely within its <code>UpdateOperations</code> helper object) to handle the actual distribution of the update.</p> <p>2. Primary Broadcasts to All Peers (<code>UpdateOperations.broadcastUpdatetoPeers</code>)</p> <p>This method orchestrates sending the update to all nodes that hold a replica (including the primary itself).</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/UpdateOperations.java (Simplified method)\n\npublic void broadcastUpdatetoPeers(Set&lt;Message&gt; activenodesforfile, byte[] updates) throws RemoteException {\n    System.out.println(\"Broadcasting updates to \" + activenodesforfile.size() + \" peers.\");\n\n    // Helper to group updates if a node holds multiple replicas (not shown in detail)\n    Map&lt;String, List&lt;Message&gt;&gt; perNodeUpdates = buildPerNodeUpdates(activenodesforfile, updates);\n\n    // Iterate through each node that needs updating\n    perNodeUpdates.forEach((peerNodeIdStr, updateMessagesForPeer) -&gt; {\n        Message firstMsg = updateMessagesForPeer.get(0); // Get info for RMI lookup\n        String peerName = firstMsg.getNodeName();\n        int peerPort = firstMsg.getPort();\n\n        try {\n            // Is this update for myself (the primary node)?\n            if (peerNodeIdStr.equals(node.getNodeID().toString())) {\n                System.out.println(\"Updating local replicas (on Primary)...\");\n                updateFileContent(updateMessagesForPeer); // Update myself directly\n            } else {\n                // It's for a secondary node, contact it via RMI\n                System.out.println(\"Sending update to secondary: \" + peerName);\n                NodeInterface secondaryNodeStub = Util.getProcessStub(peerName, peerPort);\n                if (secondaryNodeStub != null) {\n                    // Call updateFileContent on the secondary node\n                    secondaryNodeStub.updateFileContent(updateMessagesForPeer);\n                } else {\n                    System.err.println(\"Could not get stub for secondary: \" + peerName);\n                }\n            }\n        } catch (RemoteException e) {\n            System.err.println(\"Error updating peer \" + peerName + \": \" + e.getMessage());\n        }\n    });\n    System.out.println(\"Broadcast finished.\");\n}\n</code></pre> <p>Explanation: 1.  It first organizes the updates per node (using <code>buildPerNodeUpdates</code>, which handles cases where one node might store multiple replicas of the same file, though that's less common here). 2.  It then loops through each unique node (<code>peerNodeIdStr</code>) that needs updating. 3.  Self-Update: If the <code>peerNodeIdStr</code> matches the primary node's own ID, it calls <code>updateFileContent</code> locally to update its own copy. 4.  Remote Update: If it's a different node (a secondary), it gets an RMI stub for that node (<code>secondaryNodeStub</code>) and remotely calls the <code>updateFileContent</code> method on that secondary node, passing the new content details.</p> <p>3. Secondary Node Updates Itself (<code>Node.updateFileContent</code>)</p> <p>When a secondary node receives the <code>updateFileContent</code> call via RMI from the primary, it simply updates its local replica information.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/Node.java (Simplified method)\n\n@Override\npublic void updateFileContent(List&lt;Message&gt; updates) throws RemoteException {\n    // This method receives a list, in case one node holds multiple replicas\n\n    for(Message update : updates) {\n        BigInteger replicaID = update.getHashOfFile();\n        byte[] newContent = update.getBytesOfFile();\n        String filename = update.getNameOfFile(); // For logging\n\n        System.out.println(\"Node \" + nodename + \" (Secondary): Received update for \" + filename + \" (Replica ID: \" + replicaID + \")\");\n\n        // Find the existing metadata Message for this replica in the local map\n        Message existingMetadata = filesMetadata.get(replicaID);\n\n        if (existingMetadata != null) {\n            // Update the content (in a real system, this might write to disk)\n            // For simplicity here, we might update the metadata if it held the bytes,\n            // or assume a separate storage mechanism is updated.\n            // existingMetadata.setBytesOfFile(newContent); // If bytes were in metadata\n            System.out.println(\"Updating local storage for replica ID: \" + replicaID);\n            // updateLocalStorage(replicaID, newContent); // Hypothetical update\n\n            // Maybe update the Lamport clock too (for ordering)\n            // existingMetadata.setClock(...)\n\n            System.out.println(\"Node \" + nodename + \" (Secondary): Update complete for \" + replicaID);\n        } else {\n            System.err.println(\"Node \" + nodename + \": Received update for unknown replica ID: \" + replicaID);\n        }\n    }\n}\n</code></pre> <p>Explanation: This method, running on the secondary node, receives the update information. It finds the corresponding replica's metadata in its <code>filesMetadata</code> map using the <code>replicaID</code>. It then performs the actual update (e.g., saving the <code>newContent</code> to disk or updating an in-memory cache) and logs the completion.</p> <p>Sequence Diagram: Remote Write</p> <p>Here's how the whole process looks:</p> <pre><code>sequenceDiagram\n    participant Client as FileManager/User App\n    participant Primary as Primary Node\n    participant Secondary1 as Secondary Node 1\n    participant Secondary2 as Secondary Node 2\n\n    Client -&gt;&gt; Client: Find Primary Node (Check replicaInfo.isPrimaryServer())\n    Client -&gt;&gt; Primary: requestRemoteWriteOperation(newContent, replicas) via RMI\n    Primary -&gt;&gt; Primary: Store replica list\n    Primary -&gt;&gt; Primary: Call broadcastUpdatetoPeers(replicas, newContent)\n    Primary -&gt;&gt; Primary: updateFileContent(updateForSelf) [Update local copy]\n    Primary -&gt;&gt; Secondary1: updateFileContent(updateForSec1) via RMI\n    Secondary1 -&gt;&gt; Secondary1: Update local copy\n    Secondary1 --&gt;&gt; Primary: (Acknowledgement - Optional)\n    Primary -&gt;&gt; Secondary2: updateFileContent(updateForSec2) via RMI\n    Secondary2 -&gt;&gt; Secondary2: Update local copy\n    Secondary2 --&gt;&gt; Primary: (Acknowledgement - Optional)\n    Primary--&gt;&gt; Client: (Return from initial RMI call)</code></pre> <p>Explanation: The client finds the primary, sends the write request. The primary updates itself locally and then sends <code>updateFileContent</code> calls to all secondaries (Secondary1, Secondary2). Each secondary updates its local copy.</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#what-about-simultaneous-updates","title":"What About Simultaneous Updates?","text":"<p>This Remote-Write protocol ensures that if one update completes, all replicas will eventually become consistent. However, it has a limitation: what if two different users try to update the same file at almost the exact same time?</p> <p>Both users might find the primary node. User A sends their update, and just milliseconds later, User B sends their update. The primary might process A's request, broadcast it, and then process B's request and broadcast that. The final state will reflect User B's changes. But what if the primary processes B first, then A? The final state would reflect User A's changes. This potential inconsistency, depending on the exact timing of requests, is called a race condition.</p> <p>The simple Remote-Write protocol doesn't solve this concurrency problem by itself. We need an additional mechanism to ensure that only one update process can happen at a time for a specific file. This concept is called mutual exclusion.</p>"},{"location":"oblig3/07_consistency__remote_write_protocol__/#conclusion","title":"Conclusion","text":"<p>In this chapter, we tackled the problem of keeping multiple file copies (replicas) consistent after updates. We learned about the Remote-Write Protocol, a primary-copy strategy where:</p> <ol> <li>One replica is designated Primary.</li> <li>All updates are sent only to the Primary.</li> <li>The Primary updates itself and then broadcasts the update to all Secondary replicas.</li> </ol> <p>We saw how the <code>FileManager</code> finds the primary using the <code>isPrimaryServer</code> flag in the Message objects and how the update propagates through RMI calls like <code>requestRemoteWriteOperation</code> and <code>updateFileContent</code>. This protocol helps ensure that replicas don't permanently diverge after updates.</p> <p>However, we also touched upon the limitation of handling simultaneous update requests. To address this and ensure only one client can modify a file at a time, we need mechanisms for locking. That's exactly what we'll explore in the next chapter on Distributed Mutual Exclusion.</p>"},{"location":"oblig3/08_distributed_mutual_exclusion_/","title":"Chapter 8: Distributed Mutual Exclusion","text":"<p>Welcome to the final chapter! In the previous chapter, we learned how the Remote-Write protocol helps keep file replicas consistent by funneling all updates through a single Primary node. However, we also noted a potential problem: what if two different users try to update the same file at almost the exact same time? Both might send their requests to the Primary node nearly simultaneously. Without a coordination mechanism, the final state of the file might depend unpredictably on which request gets processed first, leading to a \"race condition\".</p> <p>This chapter introduces Distributed Mutual Exclusion, a protocol designed to solve exactly this problem. It ensures that even in a system with no central controller, only one Node (Peer) can modify a specific file replica (or enter the \"critical section\" related to it) at any given time.</p> <p>What You'll Learn:</p> <ul> <li>Why we need to control access when multiple nodes want to update the same file concurrently.</li> <li>What a \"critical section\" is.</li> <li>How nodes can coordinate using Lamport clocks and voting to achieve mutual exclusion.</li> <li>How a node requests and obtains permission (a \"lock\") before modifying a file.</li> </ul>"},{"location":"oblig3/08_distributed_mutual_exclusion_/#the-problem-colliding-updates","title":"The Problem: Colliding Updates","text":"<p>Imagine our shared file is like a physical file cabinet in an office building. Several different offices (Nodes (Peers)) might realize they need to update the same file in the cabinet at the same time. If they all rush to the cabinet simultaneously and try to write their changes, the file could end up garbled or reflecting only the changes from the last person who wrote, potentially overwriting important information from others.</p> <p>We need a system to ensure only one office gets to open the cabinet and modify the file at a time, while others wait their turn politely.</p>"},{"location":"oblig3/08_distributed_mutual_exclusion_/#key-concepts-the-traffic-light-system","title":"Key Concepts: The Traffic Light System","text":"<p>Think of Distributed Mutual Exclusion as a sophisticated traffic light system for accessing the shared file cabinet (our file replica).</p> <ol> <li>Critical Section: This is the action of accessing and modifying the shared resource \u2013 opening the cabinet and writing to the file. Our goal is to allow only one \"car\" (node's update request) into this section at a time.</li> <li>Mutual Exclusion: This is the \"one car at a time\" rule enforced by the traffic light.</li> <li>Distributed Coordination: Unlike a real traffic intersection with one controller, our \"traffic lights\" are controlled by agreement among all the offices (nodes) that hold a copy of the file. There's no single boss.</li> <li>Logical Clocks (Lamport Clocks): How do we decide who goes first if multiple offices request access at roughly the same time? We use Lamport Clocks, which act like sequential ticket numbers. Each request gets a \"timestamp\" (a number from the clock). Lower numbers generally get priority. If two requests have the exact same timestamp, we use the unique Node ID (like the office room number) to break the tie consistently (e.g., the lower ID goes first). We saw this clock in the Message chapter.</li> <li>Voting/Permission: Before an office can approach the file cabinet (enter the critical section), it must send a request message to all other offices holding a copy of that file. It must then wait until it receives an \"OK\" (permission message, or vote) back from every single one of them. This ensures everyone agrees it's this office's turn.</li> </ol>"},{"location":"oblig3/08_distributed_mutual_exclusion_/#using-mutual-exclusion-for-file-updates","title":"Using Mutual Exclusion for File Updates","text":"<p>How does a user, perhaps through the application's GUI, trigger an update that uses this mutual exclusion mechanism? The process builds upon what we learned in the Consistency (Remote-Write Protocol) chapter.</p> <ol> <li>User Initiates Update: The user modifies the file content in the application (like in the <code>FileContentUpdate</code> GUI).</li> <li>Identify Primary &amp; Peers: The application (e.g., using <code>FileManager</code>) finds the primary node and the set of all active nodes (<code>activepeers</code>) holding replicas for the file, just like in Chapter 7.</li> <li>Request Lock (Mutex): Instead of directly calling the update broadcast, the application now calls a special method on the primary node: <code>requestMutexWriteOperation</code>. This method initiates the mutual exclusion protocol (the voting process).</li> <li>Wait for Permission: The primary node executes the protocol. It requests permission from all <code>activepeers</code> (including itself) and waits for replies.</li> <li>If Granted: Once the primary node receives permission from everyone, it knows it has exclusive access (the \"lock\").</li> <li>Perform Update: Only now does the primary node proceed with the update broadcast (<code>broadcastUpdatetoPeers</code>) as described in Chapter 7.</li> <li>Release Lock: After the update broadcast is complete (or has been reliably initiated), the primary node releases the lock, sending messages to all peers informing them that the critical section is now free. This allows the next waiting node (if any) to proceed.</li> </ol> <p>Example Code Triggering the Process (GUI):</p> <p>Let's look at the <code>FileContentUpdate.java</code> code snippet, which shows how the update button might trigger this. <code>selectedpeer</code> here is assumed to be the primary node for the file being updated. <code>selectedpeerdata</code> is a Message object containing metadata about the file on the primary.</p> <pre><code>// File: src/main/java/no/hvl/dat110/gui/FileContentUpdate.java (Simplified btnUpdateContent)\n\nprivate void btnUpdateContent() {\n    String newcontent = txtArea.getText(); // Get the new text from the GUI\n\n    try {\n        // Get the list of all nodes holding replicas for this file\n        Set&lt;Message&gt; activepeers = filemanager.getActiveNodesforFile();\n        if (activepeers == null) {\n            activepeers = filemanager.requestActiveNodesForFile(selectedpeerdata.getNameOfFile());\n        }\n        if (activepeers == null || activepeers.isEmpty()) {\n            JOptionPane.showMessageDialog(null, \"Cannot find replica locations!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        // --- Mutual Exclusion Start ---\n        System.out.println(\"Requesting mutex lock from primary: \" + selectedpeer.getNodeName());\n        // selectedpeer is the primary node's RMI stub\n        // selectedpeerdata contains info like clock, node ID for the request message\n        boolean lockGranted = selectedpeer.requestMutexWriteOperation(\n                selectedpeerdata,          // Message with request info (clock, ID)\n                newcontent.getBytes(),     // The actual updates to be applied LATER\n                activepeers                // Set of all nodes involved in voting\n        );\n        // --- Mutual Exclusion End (blocks until granted or failed) ---\n\n        JOptionPane.showMessageDialog(null, \"Access granted? \" + lockGranted, \"Message\", JOptionPane.INFORMATION_MESSAGE);\n\n        if (lockGranted) {\n            System.out.println(\"Lock acquired! Update should have been broadcast by primary.\");\n            // NOTE: The actual broadcastUpdatetoPeers is called *inside* the primary node\n            //       after it successfully acquires the lock within requestMutexWriteOperation.\n            //       The primary also needs to release the lock eventually.\n\n            // --- Release Lock (implicitly handled by primary or needs explicit call?) ---\n            // The provided code seems to have the primary release locks *before* requesting?\n            // Let's assume the primary releases *after* the update.\n            // It might call multicastReleaseLocks internally or the client might trigger it.\n            // selectedpeer.multicastReleaseLocks(activepeers); // Maybe called by primary internally\n        } else {\n             System.out.println(\"Failed to acquire lock.\");\n        }\n\n    } catch (RemoteException e) {\n        JOptionPane.showMessageDialog(null, \"RMI Error: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n        e.printStackTrace();\n    }\n}\n</code></pre> <p>Explanation: 1.  It gets the updated text and the list of all nodes (<code>activepeers</code>) holding replicas. 2.  It calls <code>selectedpeer.requestMutexWriteOperation(...)</code> via Remote Communication (RMI) on the primary node. 3.  It passes:     *   <code>selectedpeerdata</code>: A Message object that the <code>MutualExclusion</code> logic will use to store the Lamport clock time and ID of this request.     *   <code>newcontent.getBytes()</code>: The actual file changes. The primary node will hold onto this and only broadcast it after getting the lock.     *   <code>activepeers</code>: The list of all nodes who need to vote. 4.  This call blocks (waits) until the primary node successfully gets permission from all peers (returns <code>true</code>) or fails/times out (returns <code>false</code>). 5.  If <code>lockGranted</code> is <code>true</code>, the user knows the primary node has acquired the lock and has initiated the update broadcast (from Chapter 7) within its locked critical section.</p>"},{"location":"oblig3/08_distributed_mutual_exclusion_/#internal-implementation-the-voting-protocol","title":"Internal Implementation: The Voting Protocol","text":"<p>Let's peek inside the <code>MutualExclusion.java</code> class on a Node (Peer) to see how this voting happens.</p> <p>Scenario: Node P (Primary) receives <code>requestMutexWriteOperation</code> and needs to get permission from Node A and Node B (and itself).</p> <p>Step 1: Initiate Request (<code>doMutexRequest</code>)</p> <p>When <code>requestMutexWriteOperation</code> is called on Node P, it delegates to <code>MutualExclusion.doMutexRequest</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/MutualExclusion.java (Simplified doMutexRequest)\n\npublic synchronized boolean doMutexRequest(Message message, byte[] updates) throws RemoteException {\n    logger.info(node.nodename + \" wants to access CS\");\n    // Clear previous acknowledgements and queued requests\n    queueack.clear();\n    mutexqueue.clear();\n\n    // 1. Increment local Lamport clock\n    clock.increment();\n    // 2. Set clock on the outgoing request message\n    message.setClock(clock.getClock());\n    node.getMessage().setClock(clock.getClock()); // Update node's own message clock too\n\n    // 3. Mark intention to enter CS\n    WANTS_TO_ENTER_CS = true;\n\n    // 4. Get unique list of peers to send requests to\n    List&lt;Message&gt; activenodes = removeDuplicatePeersBeforeVoting();\n\n    // 5. Send request to all peers (including self)\n    multicastMessage(message, activenodes);\n\n    // --- Wait for Replies ---\n    // (Simplified: loop or wait mechanism needed here to check areAllMessagesReturned)\n    long startTime = System.currentTimeMillis();\n    while (!areAllMessagesReturned(activenodes.size())) {\n        // Wait for acknowledgements to arrive via onMutexAcknowledgementReceived\n        // Add a timeout to prevent infinite waiting\n        if (System.currentTimeMillis() - startTime &gt; 5000) { // 5 sec timeout\n             logger.warn(node.nodename + \" timed out waiting for ACKs.\");\n             WANTS_TO_ENTER_CS = false;\n             return false; // Failed to get lock\n        }\n        try { Thread.sleep(100); } catch (InterruptedException e) {} // Pause briefly\n    }\n    // --- All Replies Received ---\n\n    // 6. Acquire the lock (enter critical section)\n    acquireLock();\n    logger.info(node.nodename + \" LOCK ACQUIRED\");\n\n    // --- Critical Section Start ---\n    node.broadcastUpdatetoPeers(updates); // Perform the actual update (from Chapter 7)\n    // --- Critical Section End ---\n\n    // 7. Release the lock and notify queued processes\n    releaseLocks(); // Mark CS as free\n    multicastReleaseLocks(node.getActiveNodesforFile()); // Tell peers lock is free\n    sendQueuedAcknowledgements(); // Tell waiting nodes they can try now\n\n    mutexqueue.clear();\n    return true; // Success!\n}\n\n// Helper to send request messages\nprivate void multicastMessage(Message message, List&lt;Message&gt; activenodes) throws RemoteException {\n    logger.info(\"Multicasting mutex request to \" + activenodes.size() + \" peers.\");\n    for (Message m : activenodes) {\n        NodeInterface stub = Util.getProcessStub(m.getNodeName(), m.getPort());\n        if (stub != null) {\n            // Make RMI call to each peer\n            stub.onMutexRequestReceived(message);\n        } // else handle error: node might be down\n    }\n}\n</code></pre> <p>Explanation: 1.  Increments its Lamport clock (<code>clock.increment()</code>) to get a unique timestamp for this request. 2.  Sets this timestamp on the outgoing <code>message</code>. 3.  Sets <code>WANTS_TO_ENTER_CS = true</code>. 4.  Gets the list of unique peers involved. 5.  Calls <code>multicastMessage</code> to send an <code>onMutexRequestReceived</code> RMI call to every peer (Node A, Node B, and itself). 6.  It then enters a waiting loop (<code>while (!areAllMessagesReturned(...)</code>) until it receives acknowledgments (<code>queueack</code>) from all peers. (This internal waiting logic is crucial). 7.  Once all ACKs are received, it calls <code>acquireLock()</code> (sets <code>CS_BUSY = true</code>), performs the <code>broadcastUpdatetoPeers</code> from Chapter 7, and then releases the lock using <code>releaseLocks()</code> and <code>multicastReleaseLocks</code>.</p> <p>Step 2: Handling Received Requests (<code>onMutexRequestReceived</code>, <code>doDecisionAlgorithm</code>)</p> <p>Now, what happens when Node A receives the <code>onMutexRequestReceived(message)</code> call from Node P?</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/MutualExclusion.java (Simplified Request Handling)\n\npublic synchronized void onMutexRequestReceived(Message message) throws RemoteException {\n    // Increment local clock because an event occurred\n    clock.increment();\n    clock.adjustClock(Math.max(clock.getClock(), message.getClock())); // Adjust clock based on message\n\n    // Decide whether to grant permission immediately or queue the request\n    int caseid = -1;\n    if (!CS_BUSY &amp;&amp; !WANTS_TO_ENTER_CS) { // Case 0: I'm idle\n        caseid = 0;\n    } else if (CS_BUSY) {                // Case 1: I'm in the CS\n        caseid = 1;\n    } else {                             // Case 2: I also want to enter CS\n        caseid = 2;\n    }\n\n    doDecisionAlgorithm(message, mutexqueue, caseid);\n}\n\npublic void doDecisionAlgorithm(Message message, List&lt;Message&gt; queue, int condition) throws RemoteException {\n    String requesterName = message.getNodeName();\n    int requesterPort = message.getPort();\n\n    switch (condition) {\n        case 0: // Idle: Grant permission immediately\n            NodeInterface requesterStub = Util.getProcessStub(requesterName, requesterPort);\n            if (requesterStub != null) {\n                 // Send ACK back to the requester (Node P)\n                requesterStub.onMutexAcknowledgementReceived(node.getMessage());\n            }\n            break;\n        case 1: // Busy: Queue the request, don't reply yet\n            logger.info(node.nodename + \" is BUSY, queueing request from \" + requesterName);\n            queue.add(message);\n            break;\n        case 2: // Also Wants: Compare timestamps (and NodeIDs if timestamps equal)\n            int requesterClock = message.getClock();\n            int myClock = node.getMessage().getClock();\n            BigInteger requesterID = message.getNodeID();\n            BigInteger myID = node.getNodeID();\n\n            // Grant permission if requester has lower clock, or same clock and lower ID\n            if (requesterClock &lt; myClock || (requesterClock == myClock &amp;&amp; requesterID.compareTo(myID) &lt; 0)) {\n                 NodeInterface stub = Util.getProcessStub(requesterName, requesterPort);\n                 if (stub != null) {\n                     // Send ACK back\n                     stub.onMutexAcknowledgementReceived(node.getMessage());\n                 }\n            } else {\n                 // Requester has higher priority or equal, queue their request\n                 logger.info(node.nodename + \" wants lock too, queueing request from \" + requesterName);\n                 queue.add(message);\n            }\n            break;\n    }\n}\n</code></pre> <p>Explanation: 1.  Node A receives the request, increments its clock. 2.  It checks its own state (<code>CS_BUSY</code>, <code>WANTS_TO_ENTER_CS</code>). 3.  <code>doDecisionAlgorithm</code> decides:     *   Case 0 (Idle): Node A isn't using the resource and doesn't want it. It immediately sends an \"OK\" (<code>onMutexAcknowledgementReceived</code>) back to Node P via RMI.     *   Case 1 (Busy): Node A is currently in the critical section. It cannot grant permission now, so it adds Node P's request to its <code>mutexqueue</code> and does not reply yet.     *   Case 2 (Wants): Node A also wants to enter the critical section. It compares its own request's Lamport timestamp (<code>myClock</code>) with Node P's request timestamp (<code>requesterClock</code>).         *   If Node P has a lower timestamp (or the same timestamp but a lower Node ID), Node A grants permission (sends ACK back). Node P has priority.         *   Otherwise, Node A has priority. It queues Node P's request in <code>mutexqueue</code> and does not reply yet.</p> <p>Step 3: Receiving Acknowledgements (<code>onMutexAcknowledgementReceived</code>)</p> <p>When Node P receives an \"OK\" message back from Node A (or B, or itself), the <code>onMutexAcknowledgementReceived</code> method is called on Node P.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/MutualExclusion.java (Simplified ACK Handling)\n\npublic synchronized void onMutexAcknowledgementReceived(Message message) throws RemoteException {\n    logger.info(node.nodename + \" received ACK from \" + message.getNodeName());\n    // Add the ACK to the list\n    queueack.add(message);\n    // The waiting loop in doMutexRequest will check if queueack.size() is now sufficient\n}\n\n// Helper called by doMutexRequest\nprivate boolean areAllMessagesReturned(int numvoters) throws RemoteException {\n    //logger.info(node.getNodeName()+\": Size of queueack = \"+queueack.size()+\", Voters = \"+numvoters);\n    return queueack.size() &gt;= numvoters;\n}\n</code></pre> <p>Explanation: This method simply adds the received acknowledgment Message to the <code>queueack</code> list. The loop inside <code>doMutexRequest</code> continuously checks <code>areAllMessagesReturned</code> to see if enough ACKs have arrived.</p> <p>Step 4: Releasing the Lock (<code>releaseLocks</code>, <code>multicastReleaseLocks</code>)</p> <p>After Node P finishes its update broadcast inside the critical section, it calls <code>releaseLocks</code> and <code>multicastReleaseLocks</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/middleware/MutualExclusion.java (Simplified Release)\n\npublic synchronized void releaseLocks() {\n    WANTS_TO_ENTER_CS = false;\n    CS_BUSY = false;\n    logger.info(node.nodename + \" LOCK RELEASED\");\n}\n\n// This is called by the node *leaving* the CS\npublic void multicastReleaseLocks(Set&lt;Message&gt; activenodes) throws RemoteException {\n    logger.info(\"Multicasting release message to \"+ activenodes.size()+\" peers.\");\n    // Remove self from the list, no need to tell self\n    Set&lt;Message&gt; others = new HashSet&lt;&gt;(activenodes);\n    others.removeIf(m -&gt; m.getNodeID().equals(node.getNodeID()));\n\n    for (Message m : others) {\n        NodeInterface stub = Util.getProcessStub(m.getNodeName(), m.getPort());\n        if (stub != null) {\n            try {\n                // Tell the other peer to call its local releaseLocks method\n                stub.releaseLocks(); // This remote call triggers the method below on the peer\n            } catch (RemoteException e) {\n                logger.error(\"Failed releasing lock on peer \"+m.getNodeName()+\": \"+e.getMessage());\n            }\n        }\n    }\n    // Also send acknowledgements to any processes waiting in our queue\n    sendQueuedAcknowledgements();\n}\n\n// This method is called *remotely* on a peer when the lock holder releases\n@Override\npublic synchronized void releaseLocks() throws RemoteException {\n    // Mark lock as free on this peer\n    releaseLocks();\n    // Check if we had queued requests, and send ACKs to them now\n    sendQueuedAcknowledgements();\n}\n\n// Helper to process the queue of waiting requests after releasing the lock\nprivate synchronized void sendQueuedAcknowledgements() throws RemoteException {\n    List&lt;Message&gt; processed = new ArrayList&lt;&gt;();\n    for(Message waiting_msg : mutexqueue) {\n        NodeInterface stub = Util.getProcessStub(waiting_msg.getNodeName(), waiting_msg.getPort());\n         if (stub != null) {\n             logger.info(\"Sending delayed ACK to queued node \" + waiting_msg.getNodeName());\n             stub.onMutexAcknowledgementReceived(node.getMessage());\n             processed.add(waiting_msg);\n         }\n    }\n    mutexqueue.removeAll(processed); // Remove processed requests from queue\n}\n</code></pre> <p>Explanation: 1.  <code>releaseLocks()</code>: Resets the <code>WANTS_TO_ENTER_CS</code> and <code>CS_BUSY</code> flags locally. 2.  <code>multicastReleaseLocks()</code>: Sends a <code>releaseLocks()</code> RMI call to all other peers involved. This tells them the critical section is now free. 3.  <code>sendQueuedAcknowledgements()</code>: Critically, after releasing the lock, the node checks its <code>mutexqueue</code>. For any requests it had previously deferred (because it was busy or had priority), it now sends the \"OK\" acknowledgment message back to those waiting nodes. This allows the next node in line (by timestamp/ID priority) to potentially acquire the lock.</p> <p>Sequence Diagram: Mutex Request</p> <p>Here's a simplified flow for Node P requesting access from A and B:</p> <pre><code>sequenceDiagram\n    participant P as \"Requesting Node (Primary)\"\n    participant A as \"Peer Node A\"\n    participant B as \"Peer Node B\"\n\n    P-&gt;&gt;P: User triggers update \\-&gt; doMutexRequest()\n    P-&gt;&gt;P: clock++, WANTS_TO_ENTER_CS=true\n    P-&gt;&gt;A: onMutexRequestReceived(Req_P) via RMI\n    P-&gt;&gt;B: onMutexRequestReceived(Req_P) via RMI\n    P-&gt;&gt;P: onMutexRequestReceived(Req_P) [Self Request]\n\n    Note over P: Each node runs doDecisionAlgorithm()\n    A-&gt;&gt;P: onMutexAcknowledgementReceived(Ack_A) via RMI [Assume A grants OK]\n    B-&gt;&gt;P: onMutexAcknowledgementReceived(Ack_B) via RMI [Assume B grants OK]\n    P-&gt;&gt;P: onMutexAcknowledgementReceived(Ack_P) [Self Ack]\n\n    P-&gt;&gt;P: areAllMessagesReturned() \\-&gt; true\n    P-&gt;&gt;P: acquireLock() [Enter CS]\n    P-&gt;&gt;P: node.broadcastUpdatetoPeers(updates)\n    P-&gt;&gt;P: releaseLocks() [Exit CS]\n    P-&gt;&gt;A: releaseLocks() via RMI\n    P-&gt;&gt;B: releaseLocks() via RMI\n    P-&gt;&gt;P: sendQueuedAcknowledgements() [Notify any waiting nodes]\n\n    Note over A,B: Peers receive releaseLocks() call, mark CS as free, send queued ACKs.</code></pre> <p>Explanation: Node P initiates the request, sending it to A, B, and itself. Each node decides whether to grant permission immediately or queue the request based on clocks and state. Assuming P gets priority, A and B send acknowledgments back. Once P receives all ACKs, it enters the critical section, performs the update broadcast, and then releases the lock by notifying A and B.</p>"},{"location":"oblig3/08_distributed_mutual_exclusion_/#conclusion","title":"Conclusion","text":"<p>In this final chapter, we explored Distributed Mutual Exclusion, a crucial protocol for coordinating access to shared resources like file replicas in a distributed system. We saw how the naive approach to updates could lead to conflicts (race conditions) when multiple nodes try to write concurrently.</p> <p>We learned how nodes can act like a distributed traffic light system, using a voting mechanism based on Lamport clocks and Node IDs to ensure only one node enters the critical section (file update process) at a time. A node wanting access must request permission from all relevant peers and wait for acknowledgments before proceeding. After completing its update, it releases the \"lock,\" allowing other waiting nodes to potentially acquire it. This ensures orderly, conflict-free updates even without a central coordinator.</p> <p>Understanding these core concepts \u2013 from file replication and node management to communication, hashing, network structure (Chord), message passing, consistency protocols, and finally, mutual exclusion \u2013 provides a solid foundation for building robust and reliable distributed systems like the one in <code>DAT110-project3</code>. Congratulations on completing the tutorial!</p>"},{"location":"oblig3/oblig3_index/","title":"Project 3 Overview","text":"<p>This project implements a distributed file storage system. It uses the Chord protocol to organize participating computers (nodes) into a logical ring. Files are replicated (copied) across multiple nodes for availability and fault tolerance. The system includes mechanisms for finding file replicas, ensuring consistency when files are updated using a primary copy strategy, and managing concurrent access using distributed mutual exclusion. Hashing assigns unique IDs to nodes and files, and RMI is used for communication between nodes.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Node (Peer)\n\"]\n    A1[\"Chord Protocol (Ring, Lookup, Stabilization)\n\"]\n    A2[\"File Management &amp; Replication\n\"]\n    A3[\"Hashing &amp; ID Space\n\"]\n    A4[\"Distributed Mutual Exclusion\n\"]\n    A5[\"Remote Communication (RMI)\n\"]\n    A6[\"Message\n\"]\n    A7[\"Consistency (Remote-Write Protocol)\n\"]\n    A0 -- \"Uses for lookups\" --&gt; A1\n    A0 -- \"Uses for locking\" --&gt; A4\n    A1 -- \"Interacts with Nodes\" --&gt; A0\n    A1 -- \"Uses for IDs\" --&gt; A3\n    A2 -- \"Uses to locate Nodes\" --&gt; A1\n    A2 -- \"Coordinates updates with\" --&gt; A7\n    A4 -- \"Uses for protocol state\" --&gt; A6\n    A4 -- \"Operates within Node context\" --&gt; A0\n    A7 -- \"Uses for update data\" --&gt; A6\n    A7 -- \"Applies updates to\" --&gt; A0\n    A5 -- \"Enables remote calls to\" --&gt; A0</code></pre>"},{"location":"oblig3/oblig3_index/#chapters","title":"Chapters","text":"<ol> <li>File Management &amp; Replication </li> <li>Node (Peer) </li> <li>Remote Communication (RMI) </li> <li>Hashing &amp; ID Space </li> <li>Chord Protocol (Ring, Lookup, Stabilization) </li> <li>Message </li> <li>Consistency (Remote-Write Protocol) </li> <li>Distributed Mutual Exclusion </li> </ol>"}]}