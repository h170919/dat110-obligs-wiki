{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial: dat110-project2-javafx-chatapp","text":"<p>This project is a simple JavaFX Chat Application (ChApp). It allows users to connect to a central message broker (server), subscribe to chat topics, and publish/receive messages on those topics. The application has a graphical user interface (GUI) for interaction and handles the underlying network communication and message formatting.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Chapp (Application Entry Point)\n\"]\n    A1[\"Controller (UI Logic Coordinator)\n\"]\n    A2[\"Client (Network Interaction Logic)\n\"]\n    A3[\"Message Hierarchy (Communication Protocol)\n\"]\n    A4[\"MessageUtils (Serialization/Deserialization)\n\"]\n    A5[\"Connection (Network Stream Handling)\n\"]\n    A6[\"TransportMessage (Network Data Framing)\n\"]\n    A7[\"UI Areas (CommandArea &amp; MessageArea)\n\"]\n    A0 -- \"Creates and configures\" --&gt; A1\n    A0 -- \"Sets up GUI\" --&gt; A7\n    A7 -- \"Forwards user actions\" --&gt; A1\n    A1 -- \"Delegates network tasks\" --&gt; A2\n    A1 -- \"Updates display\" --&gt; A7\n    A2 -- \"Uses for message conversion\" --&gt; A4\n    A2 -- \"Establishes network connection\" --&gt; A5\n    A4 -- \"Serializes/Deserializes\" --&gt; A3\n    A4 -- \"Uses for framing/unframing\" --&gt; A6\n    A4 -- \"Sends/Receives via\" --&gt; A5\n    A5 -- \"Sends/Receives\" --&gt; A6\n</code></pre>"},{"location":"#chapters","title":"Chapters","text":"<ol> <li>Message Hierarchy (Communication Protocol) </li> <li>Client (Network Interaction Logic) </li> <li>Chapp (Application Entry Point) </li> <li>UI Areas (CommandArea &amp; MessageArea) </li> <li>Controller (UI Logic Coordinator) </li> <li>TransportMessage (Network Data Framing) </li> <li>Connection (Network Stream Handling) </li> <li>MessageUtils (Serialization/Deserialization) </li> </ol>"},{"location":"01_message_hierarchy__communication_protocol__/","title":"Chapter 1: Message Hierarchy (Communication Protocol)","text":"<p>Welcome to the <code>dat110-project2-javafx-chatapp</code> tutorial! We're going to build a chat application, and the very first thing we need to figure out is how different parts of our application will talk to each other.</p> <p>Imagine you want to send different kinds of information through the postal mail. You wouldn't use the same format for a quick postcard as you would for a formal registration form, right? Each serves a different purpose and needs different information.</p> <p>Our chat application faces a similar challenge. The Client (your chat window) needs to talk to the Server (the central hub managing the chat). They need to exchange various types of information:</p> <ul> <li>A user wanting to join the chat.</li> <li>A user wanting to send a message to a specific chat topic.</li> <li>A user wanting to start receiving messages from a topic (subscribing).</li> <li>A user wanting to leave the chat.</li> </ul> <p>If the client just sent raw text, how would the server know what the client wants to do? Is \"hello\" a message to publish, or is it the name of a topic the user wants to create? It's confusing!</p> <p>To solve this, we need a Communication Protocol \u2013 a set of rules and standardized formats for messages. In our project, this is achieved through a Message Hierarchy.</p>"},{"location":"01_message_hierarchy__communication_protocol__/#what-is-the-message-hierarchy","title":"What is the Message Hierarchy?","text":"<p>Think of it like creating standardized templates for different kinds of postal mail:</p> <ul> <li>A basic template (<code>Message</code>) with common fields like the sender's name (<code>user</code>).</li> <li>A specialized template for connecting (<code>ConnectMsg</code>).</li> <li>A specialized template for sending a message (<code>PublishMsg</code>).</li> <li>A specialized template for joining a topic (<code>SubscribeMsg</code>).</li> <li>And so on...</li> </ul> <p>This way, when the server receives a message, it can look at its type (like looking at the type of envelope or form) and immediately understand its purpose and what information to expect inside.</p>"},{"location":"01_message_hierarchy__communication_protocol__/#the-base-messagejava","title":"The Base: <code>Message.java</code>","text":"<p>Everything starts with the <code>Message</code> class. This is the most basic building block, like a generic envelope.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/Message.java\npackage no.hvl.dat110.messages;\n\npublic abstract class Message { // 'abstract' means you can't create a plain 'Message', only specific types\n\n    private MessageType type; // What kind of message is this? (e.g., CONNECT, PUBLISH)\n    private String user;      // Which user sent this message?\n\n    // Constructor to set the type and user when creating a specific message\n    public Message(MessageType type, String user) {\n        this.type = type;\n        this.user = user;\n    }\n\n    public MessageType getType() { return this.type; }\n    public String getUser() { return user; }\n\n    @Override\n    public String toString() { // A helpful way to print message info for debugging\n        return \"Message [type=\" + type + \", user=\" + user + \"]\";\n    }\n}\n</code></pre> <ul> <li><code>MessageType type</code>: This is crucial! It tells us exactly what kind of action this message represents (Connect? Publish? Subscribe?). We'll see <code>MessageType</code> in a moment.</li> <li><code>String user</code>: Stores the username associated with the message.</li> <li><code>abstract class</code>: This means we can't just make a generic <code>Message</code> object. We must use one of the specific types (like <code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) that extend this base class.</li> </ul>"},{"location":"01_message_hierarchy__communication_protocol__/#message-types-messagetypejava","title":"Message Types: <code>MessageType.java</code>","text":"<p>To keep track of the different kinds of messages, we use an <code>enum</code> (a special type for defining a set of constants).</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageType.java\npackage no.hvl.dat110.messages;\n\n// Defines all possible types of messages in our system\npublic enum MessageType {\n    CONNECT,      // User wants to connect\n    DISCONNECT,   // User wants to disconnect\n    SUBSCRIBE,    // User wants to subscribe to a topic\n    UNSUBSCRIBE,  // User wants to unsubscribe from a topic\n    PUBLISH,      // User wants to send a message to a topic\n    CREATETOPIC,  // User wants to create a new topic\n    DELETETOPIC;  // User wants to delete a topic\n    // STATUS; // (Note: STATUS might be used by the server, omitted for client focus here)\n}\n</code></pre> <p>This <code>enum</code> provides clear, readable names for each message type used in the <code>Message</code> class's <code>type</code> field.</p>"},{"location":"01_message_hierarchy__communication_protocol__/#specialized-messages-adding-specific-details","title":"Specialized Messages: Adding Specific Details","text":"<p>Now, let's look at how we create specific message types based on the <code>Message</code> template.</p> <p>1. Connecting (<code>ConnectMsg.java</code>)</p> <p>When a user wants to connect, they just need to tell the server their username.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/ConnectMsg.java\npackage no.hvl.dat110.messages;\n\n// Inherits from the base Message class\npublic class ConnectMsg extends Message {\n\n    // Constructor for a Connect message\n    public ConnectMsg (String user) {\n        // Calls the base Message constructor, setting the type to CONNECT\n        // and passing along the username.\n        super(MessageType.CONNECT, user);\n        // No extra information needed for connecting, just the user.\n    }\n}\n</code></pre> <ul> <li><code>extends Message</code>: This means <code>ConnectMsg</code> is a type of <code>Message</code> and gets the <code>type</code> and <code>user</code> fields automatically.</li> <li><code>super(MessageType.CONNECT, user)</code>: This calls the constructor of the base <code>Message</code> class, setting the <code>type</code> specifically to <code>CONNECT</code> and storing the provided <code>user</code>.</li> </ul> <p>2. Publishing a Message (<code>PublishMsg.java</code>)</p> <p>When a user wants to send (\"publish\") a message, they need to specify which topic it belongs to and what the message content is, in addition to their username.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/PublishMsg.java\npackage no.hvl.dat110.messages;\n\npublic class PublishMsg extends Message {\n\n    // Additional fields specific to publishing\n    private String topic;   // Which topic to publish to?\n    private String message; // What is the actual message content?\n\n    public PublishMsg(String user, String topic, String message) {\n        // Set the type to PUBLISH and store the user\n        super(MessageType.PUBLISH, user);\n        // Store the topic and message specific to this type\n        this.topic = topic;\n        this.message = message;\n    }\n\n    // Methods to get the topic and message (Getters)\n    public String getTopic() { return topic; }\n    public String getMessage() { return message; }\n\n    // ... (Setters and toString methods are also usually here)\n}\n</code></pre> <ul> <li><code>extends Message</code>: Again, it inherits from <code>Message</code>.</li> <li><code>private String topic;</code>, <code>private String message;</code>: These are new fields added specifically for <code>PublishMsg</code>.</li> <li><code>super(MessageType.PUBLISH, user)</code>: Sets the type to <code>PUBLISH</code>.</li> <li><code>this.topic = topic;</code>, <code>this.message = message;</code>: Stores the extra information needed for publishing.</li> </ul> <p>Other message types like <code>SubscribeMsg</code>, <code>UnsubscribeMsg</code>, <code>CreateTopicMsg</code>, <code>DeleteTopicMsg</code>, and <code>DisconnectMsg</code> follow the same pattern: they extend <code>Message</code>, set the appropriate <code>MessageType</code>, and add any extra fields they need (like <code>topic</code> for most topic-related actions).</p>"},{"location":"01_message_hierarchy__communication_protocol__/#how-it-works-in-practice-conceptual","title":"How It Works in Practice (Conceptual)","text":"<p>Imagine you are the <code>Client</code> and want to connect to the <code>Server</code> as user \"Alice\".</p> <ol> <li>Client: Creates a <code>ConnectMsg</code> object: <code>new ConnectMsg(\"Alice\")</code>. This object internally has <code>type = MessageType.CONNECT</code> and <code>user = \"Alice\"</code>.</li> <li>Client: Sends this <code>ConnectMsg</code> object over the network to the Server. (We'll cover how it's sent in later chapters about TransportMessage and Connection).</li> <li>Server: Receives the message data. It reconstructs the <code>ConnectMsg</code> object (using helpers from MessageUtils).</li> <li>Server: Checks the message's type: <code>message.getType()</code>. It sees <code>MessageType.CONNECT</code>.</li> <li>Server: Ah! This is a connection request. It gets the username: <code>message.getUser()</code> which returns \"Alice\".</li> <li>Server: Performs the actions needed to register Alice as a connected user.</li> </ol> <p>Here's a simplified diagram of this flow:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;C: Create ConnectMsg(\"Alice\")\n    Note right of C: type=CONNECT, user=\"Alice\"\n    C-&gt;&gt;S: Send ConnectMsg data\n    S-&gt;&gt;S: Reconstruct ConnectMsg from data\n    S-&gt;&gt;S: Check message.getType() -&gt; CONNECT\n    S-&gt;&gt;S: Get message.getUser() -&gt; \"Alice\"\n    S-&gt;&gt;S: Process connection for \"Alice\"\n</code></pre> <p>By using this hierarchy, the Server can easily understand the Client's intentions without ambiguity. Each message type clearly defines the required information for a specific action.</p>"},{"location":"01_message_hierarchy__communication_protocol__/#conclusion","title":"Conclusion","text":"<p>We've seen how the Message Hierarchy acts as a communication protocol for our chat application.</p> <ul> <li>It defines a base <code>Message</code> with common information (<code>type</code>, <code>user</code>).</li> <li>It uses specific message classes (<code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) that extend the base class and add action-specific data.</li> <li>It uses the <code>MessageType</code> enum to clearly identify the purpose of each message.</li> </ul> <p>This structured approach ensures that the Client and Server can communicate effectively and understand each other's requests and information.</p> <p>In the next chapter, we'll dive into the Client (Network Interaction Logic) and see how it actually uses these message objects to interact with the network and the server.</p>"},{"location":"02_client__network_interaction_logic__/","title":"Chapter 2: Client (Network Interaction Logic)","text":"<p>In Chapter 1: Message Hierarchy (Communication Protocol), we learned how to create different types of messages (<code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) to represent specific actions. This is like having different kinds of pre-printed forms for different requests.</p> <p>But how do we actually send these forms (messages) to the central server? And how do we receive replies or messages from others? We need someone \u2013 or something \u2013 dedicated to handling the communication with the server over the network. That's where the <code>Client</code> class comes in!</p>"},{"location":"02_client__network_interaction_logic__/#what-is-the-client-our-applications-messenger","title":"What is the <code>Client</code>? Our Application's Messenger","text":"<p>Imagine you live in a big apartment building (your application) and want to communicate with the building manager (the server) who lives in a separate office. You wouldn't shout across the courtyard! You'd probably have a dedicated way to send and receive mail or messages.</p> <p>The <code>Client</code> class (<code>Client.java</code>) is like your application's personal messenger. Its main job is to manage the communication link between your chat application and the central chat server (often called a \"broker\").</p> <p>Here's what it does:</p> <ol> <li>Knows the Server's Address: It stores the server's network address (like <code>localhost</code> or an IP address) and the specific \"door number\" (port number, e.g., <code>9091</code>) it needs to connect to.</li> <li>Establishes the Connection: It handles the process of creating a network connection (like establishing a phone line) to the server.</li> <li>Sends Messages: It takes the message objects we learned about in Chapter 1 (like <code>ConnectMsg</code>, <code>PublishMsg</code>) and sends them over the network to the server.</li> <li>Receives Messages: It listens for incoming messages from the server and makes them available to the rest of the application.</li> </ol> <p>Essentially, the <code>Client</code> hides the messy details of network programming and gives the rest of our application simple commands like <code>connect()</code>, <code>publish(\"news\", \"hello everyone!\")</code>, <code>subscribe(\"news\")</code>.</p>"},{"location":"02_client__network_interaction_logic__/#how-to-use-the-client","title":"How to Use the <code>Client</code>","text":"<p>Let's see how we would use our messenger (<code>Client</code>) to connect to the server and then publish a message.</p> <p>1. Creating the Messenger (<code>Client</code> object)</p> <p>First, we need to create an instance of the <code>Client</code>, telling it who we are (our username) and where the server is.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\nString username = \"Alice\";\nString serverHost = \"localhost\"; // Often the same machine for testing\nint serverPort = 9091;         // The port the server is listening on\n\n// Create a new Client instance\nClient chatClient = new Client(username, serverHost, serverPort);\n\nSystem.out.println(\"Chat client created for user: \" + username);\n</code></pre> <ul> <li>We provide the <code>username</code>, the <code>serverHost</code> (where the server is located), and the <code>serverPort</code>.</li> <li>This creates our <code>chatClient</code> object, ready to communicate but not yet connected.</li> </ul> <p>2. Connecting to the Server</p> <p>Now, we tell our messenger to establish the connection.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\n// Tell the client to connect to the server\nboolean success = chatClient.connect();\n\nif (success) {\n    System.out.println(\"Successfully connected to the server!\");\n} else {\n    System.out.println(\"Failed to connect to the server.\");\n}\n</code></pre> <ul> <li>Calling <code>chatClient.connect()</code> initiates the network connection process.</li> <li>It returns <code>true</code> if the connection was successful, <code>false</code> otherwise. Behind the scenes, this involves sending a <code>ConnectMsg</code> (from Chapter 1) to the server.</li> </ul> <p>3. Publishing a Message</p> <p>Once connected, we can send messages to topics.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\nString topic = \"general\";\nString messageContent = \"Hello from Alice!\";\n\n// Tell the client to publish a message to the 'general' topic\nchatClient.publish(topic, messageContent);\n\nSystem.out.println(\"Sent message to topic '\" + topic + \"'\");\n</code></pre> <ul> <li>We call <code>chatClient.publish()</code> with the desired <code>topic</code> and the <code>messageContent</code>.</li> <li>The <code>Client</code> takes care of creating the correct <code>PublishMsg</code> object (using our username \"Alice\") and sending it over the established connection.</li> </ul> <p>4. Other Actions</p> <p>The <code>Client</code> provides similar simple methods for other actions:</p> <ul> <li><code>subscribe(String topic)</code>: To start receiving messages from a topic.</li> <li><code>unsubscribe(String topic)</code>: To stop receiving messages.</li> <li><code>createTopic(String topic)</code>: To ask the server to create a new topic.</li> <li><code>deleteTopic(String topic)</code>: To ask the server to delete a topic.</li> <li><code>disconnect()</code>: To gracefully close the connection and inform the server.</li> <li><code>receive()</code>: To check for and retrieve any incoming messages sent from the server.</li> </ul> <p>All these methods use the appropriate message types from Chapter 1 under the hood.</p>"},{"location":"02_client__network_interaction_logic__/#under-the-hood-how-does-connect-work","title":"Under the Hood: How Does <code>connect()</code> Work?","text":"<p>Let's peek behind the curtain when you call <code>chatClient.connect()</code>. It's a team effort involving a few components:</p> <ol> <li><code>Client</code> (<code>Client.java</code>): Your main messenger object.</li> <li><code>MessagingClient</code> (<code>MessagingClient.java</code>): A helper specifically focused on the initial network socket setup.</li> <li><code>Connection</code> (<code>Connection.java</code>): An object that wraps the actual network socket and handles reading/writing raw byte data. (We'll learn more in the Connection (Network Stream Handling) chapter).</li> <li><code>MessageUtils</code> (<code>MessageUtils.java</code>): A utility to convert our <code>Message</code> objects into raw data suitable for network transport, and vice-versa. (Covered in the MessageUtils (Serialization/Deserialization) chapter).</li> </ol> <p>Here\u2019s a simplified sequence of events:</p> <pre><code>sequenceDiagram\n    participant App as Your Application Code\n    participant Cl as Client (chatClient)\n    participant MC as MessagingClient\n    participant Srv as Server\n    participant Conn as Connection\n\n    App-&gt;&gt;Cl: connect()\n    Cl-&gt;&gt;MC: connect(server, port)\n    MC-&gt;&gt;Srv: Establish TCP Socket\n    Srv--&gt;&gt;MC: Socket established\n    MC-&gt;&gt;Conn: new Connection(socket)\n    Conn--&gt;&gt;MC: Connection object created\n    MC--&gt;&gt;Cl: return Connection object\n    Cl-&gt;&gt;Cl: Create ConnectMsg(\"Alice\")\n    Note right of Cl: Using the username provided earlier\n    Cl-&gt;&gt;Conn: send(ConnectMsg data)\n    Note right of Cl: MessageUtils helps prepare data (details later)\n    Conn-&gt;&gt;Srv: Send ConnectMsg raw data\n    Cl--&gt;&gt;App: return true (if all steps ok)\n</code></pre> <p>Code Glimpse:</p> <p>Let's look at parts of the <code>Client.java</code> code.</p> <ul> <li> <p>Constructor: Stores the server info using <code>MessagingClient</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\nprivate MessagingClient client; // Helper for initial connection\nprivate Connection connection;   // Handles the active connection\nprivate String user;           // Stores the username\n\npublic Client(String user, String server, int port) {\n    // Creates the MessagingClient helper with server details\n    client = new MessagingClient(server, port);\n    this.user = user;\n}\n</code></pre> *   The constructor just sets up the <code>MessagingClient</code> helper and stores the <code>user</code>.</p> </li> <li> <p><code>connect()</code> Method: Uses <code>MessagingClient</code> to get a <code>Connection</code> and then sends the <code>ConnectMsg</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\npublic boolean connect() {\n    boolean connected = false;\n    // Ask MessagingClient helper to establish the network link\n    connection = client.connect(); // Returns a Connection object\n\n    // Create the specific message for connecting\n    ConnectMsg msg = new ConnectMsg(user);\n\n    if (connection != null) { // Check if connection succeeded\n        // If yes, send the ConnectMsg over the connection\n        send(msg); // Uses the private helper 'send' method\n        connected = true;\n    }\n    return connected;\n}\n</code></pre> *   <code>client.connect()</code> does the low-level network setup and gives us a <code>Connection</code> object. *   A <code>ConnectMsg</code> is created using the stored <code>user</code>. *   The <code>send()</code> helper method (shown next) is used to actually transmit the message.</p> </li> <li> <p><code>send()</code> Helper Method: Prepares and sends any message.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\n// Private helper method to send any type of Message\nprivate void send(Message msg) {\n    // Convert the Message object (e.g., ConnectMsg, PublishMsg)\n    // into a TransportMessage suitable for network sending.\n    // MessageUtils does this magic (details in Chapter 8).\n    TransportMessage transportMsg = MessageUtils.toTransportMessage(msg);\n\n    // Tell the Connection object to send the prepared data.\n    // Connection handles the raw network sending (details in Chapter 7).\n    connection.send(transportMsg);\n}\n</code></pre> *   This method takes any <code>Message</code> (like <code>ConnectMsg</code>, <code>PublishMsg</code>). *   It uses <code>MessageUtils</code> to package the message for network travel (see MessageUtils (Serialization/Deserialization)). The result is a <code>TransportMessage</code> (see TransportMessage (Network Data Framing)). *   It then tells the <code>Connection</code> object to actually send the packaged data over the wire (see Connection (Network Stream Handling)).</p> </li> <li> <p><code>publish()</code> Method: Creates a <code>PublishMsg</code> and uses <code>send()</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\npublic void publish(String topic, String message) {\n    // Create the specific message type for publishing\n    PublishMsg msg = new PublishMsg(user, topic, message);\n\n    // Use the same send helper to transmit it\n    send(msg);\n}\n</code></pre> *   Very straightforward: creates the <code>PublishMsg</code> with the user, topic, and message content. *   Calls the <code>send()</code> helper method to handle the rest.</p> </li> </ul> <p>All other action methods (<code>subscribe</code>, <code>unsubscribe</code>, etc.) work similarly: create the specific <code>Message</code> object and call <code>send()</code>. The <code>receive()</code> method works in reverse, getting data from the <code>Connection</code> and using <code>MessageUtils</code> to turn it back into a <code>Message</code> object.</p>"},{"location":"02_client__network_interaction_logic__/#conclusion","title":"Conclusion","text":"<p>The <code>Client</code> class acts as a crucial bridge between the high-level logic of our chat application (like wanting to connect or send a message) and the lower-level details of network communication. It provides simple methods (<code>connect</code>, <code>publish</code>, <code>subscribe</code>, etc.) that internally create the correct message types (from Chapter 1) and use helper components (<code>MessagingClient</code>, <code>Connection</code>, <code>MessageUtils</code>) to handle the actual sending and receiving over the network.</p> <p>You now understand how our application prepares to talk to the server. But how does the application actually start up, create this <code>Client</code>, and manage the user interface? That's the role of the application's entry point.</p> <p>In the next chapter, we'll look at Chapp (Application Entry Point), which ties everything together and launches the chat window.</p>"},{"location":"03_chapp__application_entry_point__/","title":"Chapter 3: Chapp (Application Entry Point)","text":"<p>In the previous chapter, we learned about the <code>Client</code> class \u2013 our application's dedicated messenger responsible for talking to the chat server. We saw how it can <code>connect</code>, <code>publish</code> messages, and handle other network tasks using the message types defined in Chapter 1.</p> <p>But having a messenger isn't enough. How does the application even start? How does the chat window appear on the screen? How are the different visual parts (like the place to type messages and the place where messages appear) put together? We need a starting point, a master coordinator for the launch sequence.</p>"},{"location":"03_chapp__application_entry_point__/#the-stage-manager-chappjava","title":"The Stage Manager: <code>Chapp.java</code>","text":"<p>Think about putting on a play in a theatre. You have actors (our data and logic), props (buttons, text fields), and maybe even a script (our message protocol). But who turns on the lights, raises the curtain, sets up the stage, and tells everyone when to start? That's the Stage Manager.</p> <p>In our chat application, the <code>Chapp</code> class (<code>Chapp.java</code>) is our Stage Manager. It's the Application Entry Point \u2013 the very first piece of our own code that runs when you launch the chat application.</p> <p>Its main jobs are:</p> <ol> <li>Starting the Show: It contains the special <code>main</code> method that the Java Virtual Machine (JVM) looks for to begin execution.</li> <li>Setting the Stage: It uses JavaFX (a toolkit for building user interfaces) to create the main application window (called a <code>Stage</code> in JavaFX).</li> <li>Bringing in the Scenery: It creates the main visual components, like the area for typing commands and the area for displaying messages.</li> <li>Arranging the Set: It organizes these visual components within the main window so they look right.</li> <li>Raising the Curtain: It makes the application window visible to the user.</li> </ol>"},{"location":"03_chapp__application_entry_point__/#how-the-application-starts-the-main-method","title":"How the Application Starts: The <code>main</code> Method","text":"<p>Every Java application needs a starting point, a method called <code>main</code>. Our <code>Chapp</code> class has one too.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n\n// Import necessary JavaFX class\nimport javafx.application.Application;\n\n// Chapp inherits features from JavaFX's Application class\npublic class Chapp extends Application {\n\n    // ... (start method will be here) ...\n\n    // The main entry point when the application is launched\n    public static void main(String[] args) {\n\n        // Tell JavaFX to start the application lifecycle\n        Application.launch(args);\n\n    }\n}\n</code></pre> <ul> <li><code>public static void main(String[] args)</code>: This is the standard signature Java looks for. When you run the application, this method is executed first.</li> <li><code>Application.launch(args);</code>: This is the key line for JavaFX applications. Instead of putting all our setup code directly in <code>main</code>, we tell the JavaFX toolkit to take over. JavaFX then does some internal setup and calls another important method in our <code>Chapp</code> class: <code>start</code>.</li> </ul>"},{"location":"03_chapp__application_entry_point__/#setting-up-the-window-the-start-method","title":"Setting Up the Window: The <code>start</code> Method","text":"<p>Because <code>Chapp</code> <code>extends Application</code>, it gets special abilities from JavaFX. One of these is the <code>start</code> method, which JavaFX calls automatically after <code>launch</code> is invoked. This is where we build our user interface.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n\n// Import necessary JavaFX classes\nimport javafx.application.Application;\nimport javafx.stage.Stage; // Represents the main window\nimport javafx.scene.Scene; // Represents the content inside the window\n// ... other imports ...\n\npublic class Chapp extends Application {\n\n    // This method is called by JavaFX after launch()\n    @Override // Indicates we are overriding a method from Application\n    public void start(Stage stage) {\n\n        // 'stage' is the main window, provided by JavaFX\n        stage.setTitle(\"ChApp - Chat Application\"); // Set the title bar text\n\n        // ... (We'll add the content setup here) ...\n\n        // Make the window visible!\n        stage.show(); \n    }\n\n    // ... (main method is also here) ...\n}\n</code></pre> <ul> <li><code>start(Stage stage)</code>: JavaFX creates the main window object (<code>Stage</code>) and passes it to our <code>start</code> method. Think of the <code>Stage</code> as the physical theatre building.</li> <li><code>stage.setTitle(...)</code>: Sets the text that appears in the window's title bar.</li> <li><code>stage.show()</code>: This is like opening the doors and turning on the lights \u2013 it makes the window appear on the screen. If we forget this, the application might be running, but we wouldn't see anything!</li> </ul>"},{"location":"03_chapp__application_entry_point__/#bringing-the-ui-parts-together","title":"Bringing the UI Parts Together","text":"<p>Okay, we have a window (<code>Stage</code>), but it's empty. We need to create the actual user interface elements. <code>Chapp</code> is responsible for creating the main building blocks:</p> <ol> <li><code>CommandArea</code>: The section (likely at the bottom or side) where the user types commands like <code>/connect alice</code>, <code>/join general</code>, or just sends messages.</li> <li><code>MessageArea</code>: The main section where incoming chat messages and notifications are displayed.</li> <li><code>Menus</code>: The menu bar at the top (e.g., File, Options).</li> <li><code>Controller</code>: This isn't a visual part, but it's the \"brain\" that connects user actions (like clicking \"Send\") to the underlying logic (like telling the Client to send a message). We'll cover this in detail in the Controller (UI Logic Coordinator) chapter.</li> </ol> <p>Let's create instances of these inside the <code>start</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, before stage.show()\n\n// Create the UI area for user input\nCommandArea carea = new CommandArea(); \n// Create the UI area for displaying messages\nMessageArea marea = new MessageArea(); \n\n// Create the menu bar logic (needs the stage and areas)\nMenus menus = new Menus(stage, carea, marea); \n\n// Create the controller (needs the message area to update it)\nController controller = new Controller(marea); \n</code></pre> <p>At this point, these objects exist in memory, but they aren't arranged visually, nor are they fully connected to each other yet.</p>"},{"location":"03_chapp__application_entry_point__/#arranging-the-ui-with-layouts","title":"Arranging the UI with Layouts","text":"<p>How do we place the <code>CommandArea</code> and <code>MessageArea</code> inside the window? JavaFX uses Layout Panes. Think of them like organizers or shelves for your UI elements. We'll use two common ones:</p> <ul> <li><code>HBox</code>: Arranges things horizontally (side-by-side).</li> <li><code>VBox</code>: Arranges things vertically (one above the other).</li> </ul> <p>We want the command area and message area next to each other, so we'll put them in an <code>HBox</code>. We also need to tell these areas about the <code>Controller</code> so they know who to talk to when the user does something.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after creating controller\n\n// Create a horizontal layout pane\nHBox hbox = new HBox(); \n\n// Tell the command area how to set itself up within the hbox\n// and who its controller is.\ncarea.setupCommandArea(hbox, controller, marea); \n// Tell the message area how to set itself up\nmarea.setupMessageAera(hbox, controller); \n\n// Also give the menus access to the controller\nmenus.setController(controller); \n// Get the actual visual menu bar from the Menus object\nMenuBar menuBar = menus.getMenuBar();\n</code></pre> <ul> <li>We create an <code>HBox</code>.</li> <li>We call <code>setup...</code> methods on <code>carea</code> and <code>marea</code>. These methods (defined within <code>CommandArea</code> and <code>MessageArea</code> themselves, which we'll see in Chapter 4) likely add buttons, text fields, etc., into the <code>hbox</code>. They also store a reference to the <code>controller</code>.</li> <li>We link the <code>controller</code> to the <code>menus</code> and get the visual <code>MenuBar</code>.</li> </ul> <p>Now, we want the <code>MenuBar</code> above the <code>HBox</code> containing the command and message areas. So, we put the <code>menuBar</code> and the <code>hbox</code> into a <code>VBox</code>:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after getting the menuBar\n\n// Create a vertical layout pane, putting the menu bar\n// on top of the horizontal box (hbox)\nVBox vbox = new VBox(menuBar, hbox); \n</code></pre>"},{"location":"03_chapp__application_entry_point__/#putting-it-all-on-the-stage-the-scene","title":"Putting it All on the Stage: The <code>Scene</code>","text":"<p>We have our neatly arranged layout (<code>vbox</code>), but how do we put it inside the window (<code>Stage</code>)? We need one more JavaFX concept: the <code>Scene</code>.</p> <p>Think of the <code>Stage</code> as the theatre building, and the <code>Scene</code> as the actual stage set, lights, and curtains within that building. The <code>Scene</code> holds the root layout pane (our <code>vbox</code>) and defines the dimensions of the content area.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after creating vbox\n\n// Create the scene containing our vertical layout (vbox)\n// Set the initial size of the content area to 750x500 pixels\nScene scene = new Scene(vbox, 750, 500); \n\n// Put the scene onto the stage (our main window)\nstage.setScene(scene); \n\n// Now, finally, make the stage visible!\nstage.show(); \n</code></pre> <ul> <li><code>new Scene(vbox, 750, 500)</code>: Creates the scene, telling it that <code>vbox</code> is the main content and specifying the desired width and height.</li> <li><code>stage.setScene(scene)</code>: This connects our carefully constructed scene to the main window.</li> <li><code>stage.show()</code>: Raises the curtain! The window appears with the menu bar, command area, and message area all arranged.</li> </ul>"},{"location":"03_chapp__application_entry_point__/#the-launch-sequence-simplified","title":"The Launch Sequence (Simplified)","text":"<p>Here's a simplified view of what happens when you run the application:</p> <pre><code>sequenceDiagram\n    participant OS as Operating System\n    participant JVM as Java Virtual Machine\n    participant Chapp as Chapp.java\n    participant JFX as JavaFX Toolkit\n    participant UI as UI Components (Areas, Menus)\n\n    OS-&gt;&gt;JVM: Run Chapp\n    JVM-&gt;&gt;Chapp: Execute main()\n    Chapp-&gt;&gt;JFX: Application.launch()\n    JFX-&gt;&gt;JFX: Internal Setup\n    JFX-&gt;&gt;Chapp: Create Stage object\n    JFX-&gt;&gt;Chapp: Call start(stage)\n    Chapp-&gt;&gt;UI: Create CommandArea, MessageArea, Menus\n    Chapp-&gt;&gt;Chapp: Create Controller\n    Chapp-&gt;&gt;Chapp: Create HBox, VBox (Layouts)\n    Chapp-&gt;&gt;UI: Call setup methods (add elements to layouts)\n    Chapp-&gt;&gt;JFX: Create Scene(vbox)\n    Chapp-&gt;&gt;JFX: stage.setScene(scene)\n    Chapp-&gt;&gt;JFX: stage.show()\n    JFX-&gt;&gt;OS: Display Application Window\n</code></pre>"},{"location":"03_chapp__application_entry_point__/#conclusion","title":"Conclusion","text":"<p>The <code>Chapp</code> class is the essential starting point for our graphical chat application. As the Application Entry Point, it performs the critical tasks of:</p> <ul> <li>Providing the <code>main</code> method to kick things off.</li> <li>Using JavaFX's <code>Application.launch</code> and <code>start</code> mechanism.</li> <li>Creating the main window (<code>Stage</code>).</li> <li>Instantiating the core UI building blocks (<code>CommandArea</code>, <code>MessageArea</code>, <code>Menus</code>) and the <code>Controller</code>.</li> <li>Arranging these blocks using layout panes (<code>HBox</code>, <code>VBox</code>).</li> <li>Placing the layout into a <code>Scene</code> and displaying it on the <code>Stage</code>.</li> </ul> <p>Think of <code>Chapp</code> as the director who gets everything ready before the main action begins. It sets up the visual structure, but the detailed behavior within those UI areas is handled by other components.</p> <p>Now that we've seen how the application window is built and displayed, we can dive into the details of the visual components themselves. In the next chapter, we'll explore the UI Areas (CommandArea &amp; MessageArea) to see how they are constructed and what elements they contain.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/","title":"Chapter 4: UI Areas (CommandArea &amp; MessageArea)","text":"<p>In the previous chapter, we saw how <code>Chapp</code> acts like a stage manager, setting up the main window (<code>Stage</code>) and creating the initial instances of our UI components. It brought the actors (<code>CommandArea</code>, <code>MessageArea</code>) onto the stage but didn't delve into what those actors actually do or how they are built.</p> <p>Now, let's look closely at two of those main actors: <code>CommandArea</code> and <code>MessageArea</code>. Think about any chat application you've used. You usually have:</p> <ol> <li>A place where you type your messages, maybe choose a topic, and click \"Send\" or \"Connect\".</li> <li>A separate area where you see the messages from other people appearing.</li> </ol> <p>It wouldn't make sense to mix these up, right? Having dedicated areas makes the application much easier to use. Our <code>CommandArea</code> and <code>MessageArea</code> classes define these distinct sections.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/#the-dashboard-analogy","title":"The Dashboard Analogy","text":"<p>Imagine the dashboard of a car. You have one area with controls: the steering wheel, pedals, buttons for lights or wipers. This is where you interact with the car to tell it what to do. This is like our <code>CommandArea</code>.</p> <p>Then, you have another area with displays: the speedometer, fuel gauge, warning lights. This shows you information from the car about its status. This is like our <code>MessageArea</code>.</p> <p><code>CommandArea</code> and <code>MessageArea</code> are Java classes that use JavaFX elements to build these visual panels for our chat application.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/#commandarea-the-control-panel","title":"<code>CommandArea</code>: The Control Panel","text":"<p>The <code>CommandArea</code> class (<code>CommandArea.java</code>) is responsible for creating the part of the user interface where the user gives commands or types messages. It contains all the buttons, text boxes, and labels needed for interaction.</p> <p>What's Inside?</p> <ul> <li>Buttons: For actions like \"Connect\", \"Create Topic\", \"Subscribe\", \"Publish\".</li> <li>Text Fields: For typing in the topic name or the message content.</li> <li>Labels: To display static text or simple information like the connected server or current username.</li> <li>Layout: It uses a layout pane (like <code>GridPane</code>) to arrange these elements neatly.</li> </ul> <p>Setting up the <code>CommandArea</code></p> <p>Remember in <code>Chapp.java</code>, we saw this line:</p> <pre><code>// From Chapp.java's start() method\ncarea.setupCommandArea(hbox, controller, marea);\n</code></pre> <p>This calls the <code>setupCommandArea</code> method inside <code>CommandArea.java</code>. Let's look at a simplified version of what that method does:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Simplified)\npackage no.hvl.dat110.chapp;\n\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.GridPane; // For arranging elements in a grid\nimport javafx.scene.layout.HBox;    // The horizontal box from Chapp\n// ... other imports\n\npublic class CommandArea {\n\n    private Controller controller; // Reference to the application's brain\n\n    public void setupCommandArea(HBox hbox, Controller controller, MessageArea marea) {\n        this.controller = controller; // Store the controller for later use\n\n        // Create a grid layout to organize controls\n        GridPane grid = new GridPane();\n        grid.setHgap(10); // Horizontal spacing\n        grid.setVgap(10); // Vertical spacing\n\n        // --- Example: Connect Button ---\n        Button connectBtn = new Button(\"Connect\");\n        grid.add(connectBtn, 0, 0); // Add button to grid at column 0, row 0\n\n        // --- Example: Topic Text Field ---\n        TextField topicField = new TextField();\n        topicField.setPromptText(\"Enter topic name\"); // Placeholder text\n        grid.add(topicField, 1, 1); // Add text field at column 1, row 1\n\n        // --- Example: Create Topic Button ---\n        Button createTopicBtn = new Button(\"Create Topic\");\n        grid.add(createTopicBtn, 0, 1); // Add button at column 0, row 1\n\n        // ... (Many other buttons and fields are created and added here) ...\n\n        // Finally, add the organized grid to the HBox provided by Chapp\n        hbox.getChildren().add(grid);\n    }\n}\n</code></pre> <ul> <li><code>setupCommandArea</code>: This method takes the main <code>HBox</code> (from <code>Chapp</code>), the central <code>Controller</code> (our application's brain), and the <code>MessageArea</code> as input.</li> <li><code>GridPane</code>: A handy JavaFX layout tool that arranges elements in rows and columns, like a spreadsheet.</li> <li><code>new Button(...)</code>, <code>new TextField()</code>: These lines create the actual visual components.</li> <li><code>grid.add(...)</code>: This places each component into a specific cell in the grid.</li> <li><code>hbox.getChildren().add(grid)</code>: The entire grid, filled with controls, is added to the <code>HBox</code> that <code>Chapp</code> created, making it visible in the main window layout.</li> </ul> <p>Making Buttons Do Things</p> <p>Creating buttons is nice, but they need to do something when clicked! This is where the Controller comes in. Inside <code>setupCommandArea</code>, we also set up event handlers.</p> <p>Think of an event handler as telling the button: \"When someone clicks you, call this specific method in the <code>Controller</code>.\"</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Simplified event handling)\n\n// Inside setupCommandArea, after creating createTopicBtn and topicField\n\ncreateTopicBtn.setOnAction((event) -&gt; {\n    // This code runs when createTopicBtn is clicked\n\n    String topic = topicField.getText(); // Get text from the topic input field\n\n    if (!topic.isEmpty()) { // Make sure the user typed something\n        // Tell the controller to handle the \"create topic\" action\n        controller.createTopic(topic);\n        System.out.println(\"Create Topic button clicked for: \" + topic);\n    }\n});\n\n// Similar setOnAction calls are made for connectBtn, subscribeBtn, publishBtn, etc.\n</code></pre> <ul> <li><code>setOnAction(...)</code>: This is a standard JavaFX way to define what happens when a button (or other control) is interacted with.</li> <li><code>controller.createTopic(topic)</code>: This is the crucial part! The <code>CommandArea</code> doesn't know how to create a topic itself. It just grabs the topic name from the text field and tells the <code>Controller</code> to handle the logic. The <code>Controller</code> will then likely use the <code>Client</code> to send the appropriate message (Chapter 1) to the server.</li> </ul> <p>So, the <code>CommandArea</code> is the user's input panel, collecting information and delegating the actual work to the <code>Controller</code>.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/#messagearea-the-information-display","title":"<code>MessageArea</code>: The Information Display","text":"<p>The <code>MessageArea</code> class (<code>MessageArea.java</code>) builds the other main part of our UI: the section where incoming chat messages, connection confirmations, and other notifications are shown to the user.</p> <p>What's Inside?</p> <ul> <li><code>TextArea</code>: The primary component. This is a multi-line text box designed to display (and optionally edit) text. In our case, we'll mostly use it for displaying incoming messages.</li> <li>Labels: Maybe a title like \"Messages\".</li> <li>Layout: It uses a layout pane (like <code>VBox</code>) to arrange its elements.</li> </ul> <p>Setting up the <code>MessageArea</code></p> <p>Similar to <code>CommandArea</code>, <code>Chapp.java</code> calls a setup method:</p> <pre><code>// From Chapp.java's start() method\nmarea.setupMessageAera(hbox, controller);\n</code></pre> <p>Let's look at a simplified <code>setupMessageAera</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/MessageArea.java (Simplified)\npackage no.hvl.dat110.chapp;\n\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextArea; // The main display area\nimport javafx.scene.layout.HBox;     // The horizontal box from Chapp\nimport javafx.scene.layout.VBox;     // Vertical layout for this area\n// ... other imports\n\npublic class MessageArea {\n\n    private Controller controller;\n    private TextArea messages; // The field where messages will appear\n\n    public void setupMessageAera(HBox hbox, Controller controller) {\n        this.controller = controller;\n\n        // Create a vertical layout for this panel\n        VBox vbox = new VBox();\n        vbox.setPadding(new Insets(10, 10, 10, 10)); // Add some spacing\n\n        // --- A Title Label ---\n        Label msgLabel = new Label(\"Messages\");\n\n        // --- The Main Message Display Area ---\n        messages = new TextArea(); // Create the text area\n        messages.setPrefHeight(500); // Suggest a height\n        messages.setPrefWidth(300);  // Suggest a width\n        messages.setEditable(false); // User shouldn't type directly here!\n\n        // Add the label and the text area to the vertical box\n        vbox.getChildren().addAll(msgLabel, messages);\n\n        // Add this vertical box to the main HBox from Chapp\n        hbox.getChildren().add(vbox);\n    }\n\n    // ... (methods to start/stop message handling are also here) ...\n}\n</code></pre> <ul> <li><code>setupMessageAera</code>: Takes the main <code>HBox</code> and the <code>Controller</code>.</li> <li><code>VBox</code>: A vertical layout pane. We put the \"Messages\" label above the <code>TextArea</code>.</li> <li><code>new TextArea()</code>: Creates the multi-line text display area.</li> <li><code>messages.setEditable(false)</code>: This is important! It prevents the user from typing directly into the message display area. Only our application logic should add text here.</li> <li><code>vbox.getChildren().addAll(...)</code>: Adds the label and the text area to our vertical layout.</li> <li><code>hbox.getChildren().add(vbox)</code>: Adds the <code>MessageArea</code>'s layout next to the <code>CommandArea</code>'s layout within the main window's <code>HBox</code>.</li> </ul> <p>Receiving and Displaying Messages</p> <p>How does text actually appear in the <code>messages</code> TextArea? The <code>MessageArea</code> itself doesn't directly listen for network messages. That's the job of the Client and the Controller.</p> <p>The <code>MessageArea</code> has a helper mechanism (involving <code>MessageHandler.java</code>, which we won't detail here) that periodically asks the <code>Controller</code> if any new messages have arrived. If the <code>Controller</code> provides a message, the <code>MessageHandler</code> updates the <code>TextArea</code>.</p> <p>A crucial part of this is starting the message handler:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/MessageArea.java\n\n// Reference to the message handler helper task\nprivate MessageHandler msghandler;\n// The TextArea defined in setupMessageAera\nprivate TextArea messages;\n\npublic void startMessageHandler () {\n    // Create the handler, giving it the controller (to ask for messages)\n    // and the messages TextArea (to update it)\n    msghandler = new MessageHandler(controller, messages);\n\n    // Start the handler running in the background\n    msghandler.start();\n}\n\npublic void stopMessageHandler () {\n    // Method to stop the background task gracefully\n    if (msghandler != null) {\n        msghandler.doStop();\n    }\n}\n\n// --- Inside MessageHandler.java (Conceptual) ---\n// public void doProcess() {\n//     String message = controller.receive(); // Ask controller for new message\n//     if (message != null) {\n//         messages.appendText(message + \"\\n-\\n\"); // Add to TextArea!\n//     }\n//     // Wait a bit before checking again\n// }\n</code></pre> <ul> <li><code>startMessageHandler()</code>: This method (called at the right time, often after connecting) creates and starts the <code>MessageHandler</code>.</li> <li><code>MessageHandler</code>: This helper continuously checks with the <code>controller.receive()</code> method.</li> <li><code>messages.appendText(...)</code>: If <code>controller.receive()</code> returns a message string, the handler adds it to the end of the text already in the <code>TextArea</code>.</li> </ul> <p>So, the <code>MessageArea</code> primarily provides the place (<code>TextArea</code>) for messages to be displayed, and relies on a helper mechanism coordinated by the <code>Controller</code> to actually get and display those messages.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/#how-they-fit-together","title":"How They Fit Together","text":"<pre><code>graph TD\n    subgraph User Interface Window\n        CA[CommandArea (GridPane)]\n        MA[MessageArea (VBox)]\n    end\n\n    User --&gt; CA(Clicks Button, Types Text)\n    CA --&gt; CTRL(Controller)\n    CTRL --&gt; Client(Client: Sends Message)\n    Client --&gt; Server\n\n    Server --&gt; Client(Client: Receives Message)\n    Client --&gt; CTRL(Controller: Processes Message)\n    CTRL --&gt; MH(MessageHandler)\n    MH --&gt; MA(Updates TextArea)\n\n    style CA fill:#ccf,stroke:#333,stroke-width:2px\n    style MA fill:#cdf,stroke:#333,stroke-width:2px\n</code></pre> <p>This diagram shows the flow: 1.  The User interacts with the <code>CommandArea</code>. 2.  <code>CommandArea</code> tells the <code>Controller</code> what the user did. 3.  The <code>Controller</code> uses the <code>Client</code> to talk to the Server. 4.  When messages come back from the Server via the <code>Client</code>, the <code>Controller</code> processes them. 5.  The <code>Controller</code> makes the message available to the <code>MessageHandler</code> (part of <code>MessageArea</code>'s machinery). 6.  The <code>MessageHandler</code> updates the <code>TextArea</code> inside the <code>MessageArea</code> for the user to see.</p>"},{"location":"04_ui_areas__commandarea___messagearea__/#conclusion","title":"Conclusion","text":"<p>We've learned that <code>CommandArea</code> and <code>MessageArea</code> are crucial for organizing our chat application's user interface into logical sections:</p> <ul> <li><code>CommandArea</code>: Acts as the control panel, providing buttons and text fields for user input. It delegates actions to the <code>Controller</code>.</li> <li><code>MessageArea</code>: Acts as the display panel, primarily using a <code>TextArea</code> to show incoming messages received via the <code>Controller</code> and its helper <code>MessageHandler</code>.</li> </ul> <p>These classes use standard JavaFX components (<code>Button</code>, <code>TextField</code>, <code>TextArea</code>, <code>GridPane</code>, <code>VBox</code>) to build their respective parts of the UI. They are created by <code>Chapp</code> and rely heavily on the <code>Controller</code> to link user actions and incoming data to the correct behavior.</p> <p>Now that we understand the input and output areas of our UI, it's time to look at the central coordinator that makes them work together. In the next chapter, we'll explore the Controller (UI Logic Coordinator), the brain that connects the user's actions in the <code>CommandArea</code> to the underlying <code>Client</code> logic and updates the <code>MessageArea</code>.</p>"},{"location":"05_controller__ui_logic_coordinator__/","title":"Chapter 5: Controller (UI Logic Coordinator)","text":"<p>In the previous chapter, we explored the <code>CommandArea</code> (where you type commands) and the <code>MessageArea</code> (where you see messages). We saw that when you click a button in the <code>CommandArea</code>, it needs to tell something to perform the actual action, like connecting to the server or sending a message. Similarly, when a new message arrives from the network, something needs to take that message and display it in the <code>MessageArea</code>.</p> <p>But who is this \"something\"? The <code>CommandArea</code> shouldn't know the details of network connections, and the <code>MessageArea</code> shouldn't be responsible for listening for incoming data. We need a central coordinator to manage the flow of information between the user interface and the background logic.</p>"},{"location":"05_controller__ui_logic_coordinator__/#the-director-of-the-play-introducing-the-controller","title":"The Director of the Play: Introducing the Controller","text":"<p>Imagine our chat application is like a stage play: *   The User Interface (<code>CommandArea</code>, <code>MessageArea</code>) are the actors on stage. *   The User is the audience member giving cues (clicking buttons). *   The Client (Chapter 2) is like the backstage crew handling technical things (network communication). *   The Message Protocol (Chapter 1) is the script they follow.</p> <p>Who tells the actors what to do based on the cues, and who tells the backstage crew when to perform their tasks? That's the Director!</p> <p>In our application, the <code>Controller</code> class (<code>Controller.java</code>) acts as this director. It's the UI Logic Coordinator. It sits between the UI elements and the <code>Client</code> logic, directing the flow of actions and information.</p> <p>Its main jobs are:</p> <ol> <li>Listen for Cues: When the user interacts with the <code>CommandArea</code> (e.g., clicks the \"Connect\" button), the <code>CommandArea</code> notifies the <code>Controller</code>.</li> <li>Direct the Action: The <code>Controller</code> interprets the cue and tells the <code>Client</code> what to do (e.g., <code>client.connect()</code>).</li> <li>Handle Incoming Information: When the <code>Client</code> receives something from the server (like a new message), it gives it to the <code>Controller</code>.</li> <li>Update the Stage: The <code>Controller</code> processes the incoming information and makes sure the <code>MessageArea</code> is updated so the user can see it.</li> </ol> <p>Without the <code>Controller</code>, the UI and the network logic would be disconnected, unable to work together.</p>"},{"location":"05_controller__ui_logic_coordinator__/#how-the-controller-gets-involved-a-button-click-example","title":"How the Controller Gets Involved: A Button Click Example","text":"<p>Let's revisit the \"Create Topic\" button from the <code>CommandArea</code> in Chapter 4.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Event Handling part)\n\n// Inside setupCommandArea, for the 'Create Topic' button\n\ncreateTopicBtn.setOnAction((event) -&gt; {\n    // This code runs when createTopicBtn is clicked\n\n    String topic = topicField.getText(); // Get text from the topic input field\n\n    if (!topic.isEmpty()) {\n        // HERE: CommandArea tells the Controller to do the work!\n        controller.createTopic(topic);\n        System.out.println(\"Create Topic button clicked for: \" + topic);\n    }\n});\n</code></pre> <ol> <li>The user types \"news\" into the <code>topicField</code> and clicks <code>createTopicBtn</code>.</li> <li>The <code>setOnAction</code> code runs.</li> <li>It gets the text \"news\" from <code>topicField</code>.</li> <li>Crucially, it calls <code>controller.createTopic(\"news\")</code>. The <code>CommandArea</code> delegates the task to the <code>Controller</code>. It doesn't know how to create a topic; it just knows it needs to ask the <code>Controller</code> to do it.</li> </ol>"},{"location":"05_controller__ui_logic_coordinator__/#what-happens-inside-the-controller","title":"What Happens Inside the Controller?","text":"<p>So, what does the <code>Controller</code> do when its <code>createTopic(\"news\")</code> method is called?</p> <ol> <li>Check Status: It first checks if the application is actually connected to the server. It doesn't make sense to create a topic if we're not connected!</li> <li>Delegate to Client: If connected, it tells the <code>Client</code> object (our network messenger from Chapter 2) to handle the request. It calls something like <code>client.createTopic(\"news\")</code>.</li> <li>Client Does the Work: The <code>Client</code> then creates the appropriate <code>CreateTopicMsg</code> (from Chapter 1) and sends it over the network to the server.</li> </ol> <p>Here\u2019s a simplified diagram of this flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant CA as CommandArea\n    participant Ctrl as Controller\n    participant Cl as Client\n    participant Srv as Server\n\n    User-&gt;&gt;CA: Clicks \"Create Topic\" (topic=\"news\")\n    CA-&gt;&gt;Ctrl: controller.createTopic(\"news\")\n    Ctrl-&gt;&gt;Ctrl: Check if connected? (Yes)\n    Ctrl-&gt;&gt;Cl: client.createTopic(\"news\")\n    Cl-&gt;&gt;Cl: Create CreateTopicMsg(\"news\")\n    Cl-&gt;&gt;Srv: Send CreateTopicMsg data\n    Note left of Srv: Server processes the request\n</code></pre>"},{"location":"05_controller__ui_logic_coordinator__/#a-look-at-the-controllers-code","title":"A Look at the Controller's Code","text":"<p>Let's peek inside <code>Controller.java</code>.</p> <p>1. Storing Information: The <code>Controller</code> needs to keep track of important details.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\nimport no.hvl.dat110.client.*; // Needed for the Client class\nimport no.hvl.dat110.messages.PublishMsg; // Needed for receiving messages\n\npublic class Controller {\n\n    // Information about the user and server\n    private String user;\n    private String brokerhost;\n    private int brokerport;\n\n    // The network messenger\n    private Client client;\n    // Flag to track connection status\n    private boolean isconnected = false;\n\n    // Default values if not set via menus\n    private static String DEFAULT_USER = \"me\";\n    private static String DEFAULT_BROKERHOST = \"localhost\";\n    private static int DEFAULT_BROKERPORT = 8080;\n\n    // Constructor - Sets default values initially\n    public Controller (MessageArea messagearea) {\n        this.brokerport = DEFAULT_BROKERPORT;\n        this.brokerhost = DEFAULT_BROKERHOST;\n        this.user = DEFAULT_USER;\n        // Note: The messagearea isn't stored here in this version,\n        // but it's passed to the MessageHandler later.\n    }\n\n    // ... methods to get/set user, host, port ...\n}\n</code></pre> <ul> <li>It stores the <code>user</code> name, <code>brokerhost</code>, and <code>brokerport</code>. These can be changed via the application menus.</li> <li>It holds a reference to the <code>Client</code> object (once connected).</li> <li><code>isconnected</code> is a simple boolean flag to know if we have an active connection.</li> </ul> <p>2. Handling the \"Connect\" Action:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public boolean connect () {\n        boolean success = true; // Assume success initially\n\n        // Create the Client instance with current user/host/port\n        this.client = new Client(user, brokerhost, brokerport);\n\n        // Tell the client to establish the network connection\n        client.connect(); // This internally sends a ConnectMsg\n\n        // In a real app, 'connect()' would return true/false\n        // based on success. Here we assume it worked.\n        if (success) {\n            isconnected = true; // Update our status flag\n        }\n\n        return success;\n    }\n</code></pre> <ul> <li>This method is called (likely by the <code>ConnectBtnHandler</code> we saw linked in <code>CommandArea</code>) when the user wants to connect.</li> <li>It creates a new <code>Client</code> instance using the current settings.</li> <li>It calls <code>client.connect()</code>, which handles the actual network setup and sends the initial <code>ConnectMsg</code>.</li> <li>It updates the <code>isconnected</code> flag.</li> </ul> <p>3. Handling the \"Create Topic\" Action:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public void createTopic(String topic) {\n        // Only proceed if we are currently connected\n        if (isconnected) {\n            // Delegate the task to the Client object\n            client.createTopic(topic);\n        }\n    }\n</code></pre> <ul> <li>This is the method called by the <code>CommandArea</code>'s button handler.</li> <li>It first checks the <code>isconnected</code> flag.</li> <li>If <code>true</code>, it simply calls the corresponding method on the <code>client</code> object: <code>client.createTopic(topic)</code>. The <code>Controller</code> doesn't need to know the details of how the <code>Client</code> does this.</li> </ul> <p>Methods like <code>deleteTopic</code>, <code>subscribe</code>, <code>unsubscribe</code>, and <code>publish</code> follow the exact same pattern: check <code>isconnected</code>, then call the corresponding method on the <code>client</code>.</p> <p>4. Receiving Messages: How does the <code>Controller</code> get messages from the <code>Client</code> to eventually show in the <code>MessageArea</code>?</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public String receive() {\n        String message = null; // Start with no message\n\n        // Only try to receive if connected\n        if (isconnected) {\n            // Ask the client to check for incoming messages\n            // client.receive() waits for and reconstructs a message\n            // We expect PublishMsg specifically for chat content\n            PublishMsg msg = (PublishMsg) client.receive();\n\n            // If the client actually returned a message (not null)\n            if (msg != null) {\n                // Format it nicely for display\n                message = \"[\" + msg.getUser() + \"] \" + msg.getMessage();\n            }\n        }\n        // Return the formatted message string, or null if none arrived\n        return message;\n    }\n</code></pre> <ul> <li>This <code>receive()</code> method is called periodically by the <code>MessageHandler</code> (which belongs to the <code>MessageArea</code>).</li> <li>It checks <code>isconnected</code>.</li> <li>It calls <code>client.receive()</code>. This method in the <code>Client</code> waits for data, reconstructs it into a <code>Message</code> object (using helpers we'll see later), and returns it. We expect incoming chat messages to be <code>PublishMsg</code> type.</li> <li>If a <code>PublishMsg</code> is received (<code>msg != null</code>), the <code>Controller</code> extracts the user and the actual message content.</li> <li>It formats this information into a user-friendly string (e.g., <code>[Alice] Hello Bob!</code>).</li> <li>This string is then returned to the <code>MessageHandler</code>, which appends it to the <code>MessageArea</code>'s <code>TextArea</code>.</li> </ul>"},{"location":"05_controller__ui_logic_coordinator__/#the-central-hub","title":"The Central Hub","text":"<p>The <code>Controller</code> truly acts as the central hub or coordinator:</p> <ul> <li>It receives requests triggered by user actions in the <code>CommandArea</code>.</li> <li>It validates these requests (e.g., checking <code>isconnected</code>).</li> <li>It translates these requests into calls to the <code>Client</code>'s methods.</li> <li>It receives processed data (incoming messages) from the <code>Client</code>.</li> <li>It formats this data and makes it available for the <code>MessageArea</code> to display.</li> </ul> <p>It ensures that the UI components (Chapter 4) don't need to know about the complexities of network communication (Chapter 2), and the <code>Client</code> doesn't need to know about the specific UI elements like buttons or text areas.</p>"},{"location":"05_controller__ui_logic_coordinator__/#conclusion","title":"Conclusion","text":"<p>We've learned that the <code>Controller</code> is the essential UI Logic Coordinator in our chat application. It acts like a director or a switchboard operator, connecting user interface events to the underlying client logic and relaying incoming information back to the UI for display.</p> <p>Key takeaways: *   It decouples the UI (<code>CommandArea</code>, <code>MessageArea</code>) from the network logic (<code>Client</code>). *   It handles UI events by calling appropriate methods on the <code>Client</code>. *   It provides a way (<code>receive()</code>) for the UI to get incoming messages processed by the <code>Client</code>. *   It maintains the application's state, like the connection status (<code>isconnected</code>).</p> <p>Now that we understand how the UI and the <code>Client</code> interact via the <code>Controller</code>, let's look deeper into how messages are prepared for network transmission. How does our <code>PublishMsg</code> object actually get turned into bytes that can be sent over the internet?</p> <p>In the next chapter, we'll explore Chapter 6: TransportMessage (Network Data Framing) to understand how messages are packaged for their journey across the network.</p>"},{"location":"06_transportmessage__network_data_framing__/","title":"Chapter 6: TransportMessage (Network Data Framing)","text":"<p>In the previous chapter, we saw how the <code>Controller</code> acts as the application's director, taking requests from the UI (like sending a message) and telling the <code>Client</code> (Chapter 2) what to do. The <code>Client</code> then prepares to send a message object (like a <code>PublishMsg</code> from Chapter 1) over the network.</p> <p>But how does that message object actually travel across the internet? Computers connected via a network send data as streams of raw bytes (ones and zeroes). If our <code>Client</code> just dumped all the bytes for <code>ConnectMsg</code>, then <code>PublishMsg</code>, then another <code>PublishMsg</code> into the stream, how would the <code>Server</code> know where one message ends and the next one starts?</p>"},{"location":"06_transportmessage__network_data_framing__/#the-problem-finding-message-boundaries-in-a-stream","title":"The Problem: Finding Message Boundaries in a Stream","text":"<p>Imagine you're receiving a very long letter, but instead of arriving in an envelope, it arrives as one continuous ticker tape of letters with no spaces or punctuation. It would be impossible to read!</p> <pre><code>HELLOWORLDHOWAREYOUIMFINEGOODBYE\n</code></pre> <p>Network communication is similar. Data arrives as a continuous stream of bytes. The receiver needs a way to figure out: \"Okay, these specific bytes make up the first message, and these next bytes make up the second message.\" Without clear boundaries, the data is just a jumbled mess.</p>"},{"location":"06_transportmessage__network_data_framing__/#the-solution-data-framing","title":"The Solution: Data Framing","text":"<p>To solve this, we use Data Framing. Think of it like putting each message into its own standard-sized envelope or small shipping box before sending it. This \"frame\" not only holds the message content (the \"payload\") but also adds some extra information, like a label on the outside.</p> <p>In our chat application, the most important piece of information we add is the length of the payload.</p> <p>Analogy: The Standard Envelope</p> <p>Imagine you have messages of different lengths (a short note, a long letter). 1.  You get a standard-sized envelope (maybe it can hold up to 100 characters). 2.  You write your message (the payload). Let's say it's \"Hi Bob!\" (7 characters). 3.  You put the message inside the envelope. 4.  Crucially, on the outside of the envelope, you write: \"Payload Length: 7\". 5.  You send the envelope.</p> <p>When your friend receives the standard-sized envelope, they don't need to guess where your message ends. They look at the label (\"Payload Length: 7\"), open the envelope, and read exactly the first 7 characters. They know those 7 characters constitute the complete message. Anything else in the envelope is just padding, and the next envelope they receive will contain the next message.</p>"},{"location":"06_transportmessage__network_data_framing__/#our-standard-envelope-transportmessagejava","title":"Our Standard Envelope: <code>TransportMessage.java</code>","text":"<p>In our project, the <code>TransportMessage</code> class acts as this standard envelope or frame. Its main job is to hold the raw data bytes of the actual message we want to send (like the bytes representing a <code>ConnectMsg</code> or <code>PublishMsg</code>) and provide methods to wrap (frame) and unwrap (unframe) this data.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\npublic class TransportMessage {\n\n    // The actual message content (raw bytes)\n    private byte[] payload;\n\n    // Constructor: Creates a TransportMessage holding the payload\n    public TransportMessage(byte[] payload) {\n        // We need to make sure the payload isn't too big for our 'envelope'\n        if (payload == null || (payload.length + 1 &gt; MessageConfig.SEGMENTSIZE)) {\n            // (+1 because we need space for the length byte itself)\n            throw new RuntimeException(\"Payload too large for segment!\");\n        }\n        this.payload = payload;\n    }\n\n    // Method to get the payload data back out\n    public byte[] getData() {\n        return this.payload;\n    }\n\n    // ... (encapsulate and decapsulate methods coming next) ...\n}\n</code></pre> <ul> <li><code>private byte[] payload;</code>: This is where the raw data of the original message (e.g., the serialized <code>PublishMsg</code>) is stored. How we get these bytes from a <code>PublishMsg</code> object is the job of Chapter 8: MessageUtils (Serialization/Deserialization). For now, just know that <code>payload</code> holds the core message content as bytes.</li> <li><code>TransportMessage(byte[] payload)</code>: The constructor takes these payload bytes and stores them. It also checks if the payload, plus the one extra byte we need for the length, will fit into our standard network packet size (<code>MessageConfig.SEGMENTSIZE</code>).</li> </ul>"},{"location":"06_transportmessage__network_data_framing__/#fixed-packet-size-messageconfigsegmentsize","title":"Fixed Packet Size: <code>MessageConfig.SEGMENTSIZE</code>","text":"<p>Our network communication uses fixed-size packets, like using only one size of shipping box. This size is defined in <code>MessageConfig.java</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/MessageConfig.java\n\npublic class MessageConfig {\n\n    // All our network 'envelopes' will be exactly 128 bytes long\n    public static final int SEGMENTSIZE = 128;\n\n    // Other network config (ignore for now)\n    public static final int MESSAGINGPORT = 8080;\n    public static final String MESSAGINGHOST = \"localhost\";\n}\n</code></pre> <ul> <li><code>SEGMENTSIZE = 128</code>: This means every chunk of data sent or received over the network using our <code>TransportMessage</code> framing will be exactly 128 bytes.</li> </ul>"},{"location":"06_transportmessage__network_data_framing__/#packing-the-envelope-encapsulate","title":"Packing the Envelope: <code>encapsulate()</code>","text":"<p>How do we take our <code>payload</code> and put it into the standard 128-byte frame, adding the length information? This process is called encapsulation.</p> <p>The <code>encapsulate()</code> method in <code>TransportMessage</code> does this:</p> <ol> <li>Creates a new, empty byte array of exactly <code>SEGMENTSIZE</code> (128 bytes).</li> <li>Calculates the length of the <code>payload</code>.</li> <li>Writes this length value into the very first byte (index 0) of the 128-byte array.</li> <li>Copies the actual <code>payload</code> bytes into the array, starting right after the length byte (at index 1).</li> <li>Returns the filled 128-byte array. The rest of the array (after the payload) is just padding and doesn't matter.</li> </ol> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\npublic byte[] encapsulate() {\n\n    byte[] encoded; // This will be our 128-byte framed message\n\n    // Create the empty 128-byte array\n    encoded = new byte[MessageConfig.SEGMENTSIZE];\n\n    // --- The Framing Magic ---\n    // 1. Put the length of the payload into the first byte\n    encoded[0] = (byte) (payload.length);\n\n    // 2. Copy the payload bytes starting from the second byte (index 1)\n    for (int i = 0; i &lt; payload.length; i++) {\n        encoded[i + 1] = payload[i];\n    }\n    // --- End of Framing ---\n\n    // Return the fully prepared 128-byte segment\n    return encoded;\n}\n</code></pre> <ul> <li><code>encoded = new byte[MessageConfig.SEGMENTSIZE];</code>: Makes the 128-byte \"envelope\".</li> <li><code>encoded[0] = (byte) (payload.length);</code>: Writes the payload length into the first byte. We cast to <code>byte</code> because the length must fit in a single byte (0-255), which is why <code>SEGMENTSIZE</code> (128) limits the maximum payload size (to 127 bytes + 1 length byte).</li> <li><code>encoded[i + 1] = payload[i];</code>: Copies the payload bytes one by one into the <code>encoded</code> array, starting at index 1.</li> </ul> <p>Visual Example: If our payload is <code>[72, 101, 108, 108, 111]</code> (bytes for \"Hello\"), its length is 5. <code>encapsulate()</code> produces a 128-byte array like this:</p> <pre><code>Byte Index:   0    1    2    3    4    5    6   ...   127\nValue:      [ 5 | 72 |101 |108 |108 |111 | 0 | ... |  0 ]\n             \\-/ \\---------------------/ \\-------------/\n            Length    Actual Payload       Padding (unused)\n</code></pre> <p>This 128-byte <code>encoded</code> array is what gets sent over the network by the Connection.</p>"},{"location":"06_transportmessage__network_data_framing__/#opening-the-envelope-decapsulate","title":"Opening the Envelope: <code>decapsulate()</code>","text":"<p>When the receiver gets a 128-byte chunk of data from the network, how does it extract the original <code>payload</code>? This is called decapsulation.</p> <p>The <code>decapsulate()</code> method does the reverse of <code>encapsulate()</code>:</p> <ol> <li>Takes the received 128-byte array (<code>received</code>) as input.</li> <li>Reads the first byte (index 0) to find out the <code>length</code> of the original payload.</li> <li>Uses this <code>length</code> to know exactly which bytes in the <code>received</code> array constitute the payload (from index 1 up to index <code>length</code>).</li> <li>Copies only these payload bytes into the <code>TransportMessage</code> object's own <code>payload</code> field.</li> </ol> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\nimport java.util.Arrays; // Needed for Arrays.copyOfRange\n\npublic void decapsulate(byte[] received) { // 'received' is the 128-byte array from network\n\n    // --- The Un-Framing Magic ---\n    // 1. Read the payload length from the first byte\n    int len = received[0];\n\n    // 2. Extract the payload bytes from the received array\n    //    Starts at index 1, and copies 'len' bytes.\n    payload = Arrays.copyOfRange(received, 1, len + 1);\n    // --- End of Un-Framing ---\n\n    // Now, 'this.payload' holds the original message bytes again!\n}\n</code></pre> <ul> <li><code>int len = received[0];</code>: Gets the length stored in the first byte.</li> <li><code>payload = Arrays.copyOfRange(received, 1, len + 1);</code>: This is a handy Java utility. It copies a portion of the <code>received</code> array.<ul> <li><code>1</code>: Start copying from index 1 (where the payload begins).</li> <li><code>len + 1</code>: Copy up to (but not including) this index. Since we start at 1 and want <code>len</code> bytes, the end index is <code>1 + len</code>.</li> </ul> </li> <li>After this, the <code>payload</code> field of the <code>TransportMessage</code> object holds the extracted data.</li> </ul>"},{"location":"06_transportmessage__network_data_framing__/#how-it-fits-together","title":"How It Fits Together","text":"<p>Here's a simplified view of how <code>TransportMessage</code> is used when sending a message:</p> <pre><code>sequenceDiagram\n    participant Ctrl as Controller\n    participant Cl as Client\n    participant MU as MessageUtils\n    participant TM as TransportMessage\n    participant Conn as Connection\n    participant Net as Network\n\n    Note over Ctrl, Cl: User wants to publish \"Hello\" to \"general\"\n    Ctrl-&gt;&gt;Cl: client.publish(\"general\", \"Hello\")\n    Cl-&gt;&gt;Cl: Create PublishMsg(user, \"general\", \"Hello\")\n    Cl-&gt;&gt;MU: MessageUtils.toTransportMessage(publishMsg)\n    MU-&gt;&gt;MU: Serialize PublishMsg into byte[] payload (e.g., [72, 101, ...])\n    MU-&gt;&gt;TM: new TransportMessage(payload)\n    TM--&gt;&gt;MU: TransportMessage object created (holds payload)\n    MU--&gt;&gt;Cl: Return TransportMessage object\n    Cl-&gt;&gt;Conn: connection.send(transportMessage)\n    Conn-&gt;&gt;TM: transportMessage.encapsulate()\n    TM-&gt;&gt;TM: Create 128-byte array: [length | payload | padding]\n    TM--&gt;&gt;Conn: Return 128-byte encoded array\n    Conn-&gt;&gt;Net: Send 128 bytes over TCP stream\n</code></pre> <ol> <li>The <code>Client</code> gets a <code>Message</code> object (like <code>PublishMsg</code>).</li> <li>It asks <code>MessageUtils</code> (Chapter 8) to convert this object into a <code>TransportMessage</code>.</li> <li><code>MessageUtils</code> first turns the <code>PublishMsg</code> into its raw byte <code>payload</code>.</li> <li><code>MessageUtils</code> creates a <code>TransportMessage</code> containing this <code>payload</code>.</li> <li>The <code>Client</code> tells the <code>Connection</code> (Chapter 7) to send this <code>TransportMessage</code>.</li> <li>The <code>Connection</code> calls <code>transportMessage.encapsulate()</code> to get the framed 128-byte array.</li> <li>The <code>Connection</code> sends these 128 bytes over the network.</li> </ol> <p>Receiving works in reverse, with the <code>Connection</code> reading 128 bytes, creating an empty <code>TransportMessage</code>, calling <code>decapsulate()</code> on it, and then passing the <code>TransportMessage</code> (now containing the extracted payload) to <code>MessageUtils</code> to turn it back into a <code>PublishMsg</code>.</p>"},{"location":"06_transportmessage__network_data_framing__/#conclusion","title":"Conclusion","text":"<p>We've learned that sending raw data over a network stream is problematic because the receiver doesn't know where messages start and end. Data Framing solves this by wrapping the message data (payload) in a structure that includes metadata, like the payload's length.</p> <p>The <code>TransportMessage</code> class implements this framing in our project: *   It holds the raw message <code>payload</code> (as bytes). *   It uses a fixed <code>SEGMENTSIZE</code> (128 bytes) for all network transmissions. *   The <code>encapsulate()</code> method creates the 128-byte frame by writing the <code>payload</code> length in the first byte, followed by the <code>payload</code> itself. *   The <code>decapsulate()</code> method extracts the original <code>payload</code> from a received 128-byte frame by reading the length from the first byte.</p> <p>This framing ensures that the receiver can reliably reconstruct messages even when they arrive as part of a continuous byte stream.</p> <p>Now that we understand how a single message is packaged into a <code>TransportMessage</code> frame, how are these frames actually sent and received over the network connection itself? In the next chapter, we'll explore Chapter 7: Connection (Network Stream Handling) to see how the application manages the input and output streams for network communication.</p>"},{"location":"07_connection__network_stream_handling__/","title":"Chapter 7: Connection (Network Stream Handling)","text":"<p>In Chapter 6: TransportMessage (Network Data Framing), we learned how to package our messages (like <code>PublishMsg</code>) into standard-sized 128-byte \"envelopes\" called <code>TransportMessage</code>s. We know how to put the message length and the message data inside this envelope using <code>encapsulate()</code>.</p> <p>But how does this digital envelope actually get sent across the internet wires? And how do we receive similar envelopes coming back from the server? Simply creating the <code>TransportMessage</code> frame isn't enough; we need something to handle the actual pickup and delivery over the network.</p>"},{"location":"07_connection__network_stream_handling__/#the-delivery-truck-handling-network-streams","title":"The Delivery Truck: Handling Network Streams","text":"<p>Think back to our analogy: *   Your application wants to send a message (<code>PublishMsg</code>). *   <code>MessageUtils</code> (Chapter 8) turns it into raw bytes (the package content). *   <code>TransportMessage</code> (Chapter 6) puts these bytes into a standard 128-byte frame (the shipping box with a length label).</p> <p>Now we need the delivery truck and driver. This is the part that knows the network \"roads\" (the underlying TCP/IP connection) and how to physically load the box (<code>TransportMessage</code> bytes) onto the truck, drive it to the destination (server), and unload incoming boxes.</p> <p>In our project, the <code>Connection</code> class (<code>Connection.java</code>) is this delivery truck and driver. It manages the low-level details of sending and receiving streams of bytes over an established network connection. It doesn't need to understand what is inside the <code>TransportMessage</code> box; it just needs to know how to send the box reliably and receive incoming boxes.</p>"},{"location":"07_connection__network_stream_handling__/#key-parts-of-the-delivery-system","title":"Key Parts of the Delivery System","text":"<p>Before we look at the <code>Connection</code> class itself, let's understand two key concepts it uses:</p> <ol> <li> <p>Socket: When the <code>Client</code> (Chapter 2) connects to the server, it establishes a TCP Socket connection. Think of the socket as a specific, numbered docking bay at the post office dedicated to communication between your application and the server. It's the endpoint of the network link.</p> </li> <li> <p>Input/Output Streams: How does Java code actually put data onto the socket (send) or get data from the socket (receive)? It uses Streams. Imagine these as conveyor belts attached to the docking bay:</p> <ul> <li><code>OutputStream</code> (specifically <code>DataOutputStream</code>): This is the \"outgoing\" conveyor belt. You put bytes onto it, and they get sent out through the socket. <code>DataOutputStream</code> is helpful because it has methods designed for sending primitive Java data types, like raw bytes.</li> <li><code>InputStream</code> (specifically <code>DataInputStream</code>): This is the \"incoming\" conveyor belt. Bytes arriving at the socket come in on this stream, and you can read them. <code>DataInputStream</code> helps read primitive data, including raw bytes.</li> </ul> </li> </ol> <p>The <code>Connection</code> class manages the <code>Socket</code> and these two streams.</p>"},{"location":"07_connection__network_stream_handling__/#creating-a-connection","title":"Creating a <code>Connection</code>","text":"<p>We don't usually create the <code>Connection</code> object directly in our main application logic. Remember from Chapter 2, the <code>Client</code> uses a helper called <code>MessagingClient</code> to establish the initial network connection. This helper creates the <code>Socket</code> and then immediately wraps it in a <code>Connection</code> object.</p> <p>Here's the constructor of the <code>Connection</code> class:</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class Connection {\n\n    private DataOutputStream outStream; // Outgoing conveyor belt\n    private DataInputStream inStream;   // Incoming conveyor belt\n    private Socket socket;              // The docking bay\n\n    public Connection(Socket socket) { // Takes the established connection point\n\n        try {\n            this.socket = socket; // Store the socket\n\n            // Attach the outgoing stream to the socket\n            outStream = new DataOutputStream(socket.getOutputStream());\n\n            // Attach the incoming stream to the socket\n            inStream = new DataInputStream(socket.getInputStream());\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Error: \" + ex.getMessage());\n            // In a real app, handle this error more gracefully\n        }\n    }\n\n    // ... methods for sending, receiving, closing ...\n}\n</code></pre> <ul> <li>The constructor receives an already connected <code>Socket</code>.</li> <li>It creates a <code>DataOutputStream</code> linked to the socket's output, storing it in <code>outStream</code>.</li> <li>It creates a <code>DataInputStream</code> linked to the socket's input, storing it in <code>inStream</code>.</li> <li>Now the <code>Connection</code> object is ready to send and receive data using these streams.</li> </ul>"},{"location":"07_connection__network_stream_handling__/#sending-a-package-connectionsend","title":"Sending a Package: <code>Connection.send()</code>","text":"<p>How does the <code>Client</code> tell the <code>Connection</code> to send one of our prepared <code>TransportMessage</code> boxes? It calls the <code>send()</code> method.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    public void send(TransportMessage message) {\n\n        try {\n            // 1. Get the 128-byte framed data from the TransportMessage\n            //    (This uses the encapsulate() method from Chapter 6)\n            byte[] sendbuf = message.encapsulate();\n\n            // 2. Write the entire 128-byte buffer to the output stream\n            outStream.write(sendbuf);\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Send Error: \" + ex.getMessage());\n            // Handle errors\n        }\n    }\n</code></pre> <ul> <li>The method takes a <code>TransportMessage</code> object as input (this object already contains the payload bytes).</li> <li>Step 1: It calls <code>message.encapsulate()</code>. As we learned in Chapter 6, this creates the standard 128-byte array with the length byte followed by the payload bytes.</li> <li>Step 2: It uses <code>outStream.write(sendbuf)</code> to put the entire 128-byte array onto the outgoing conveyor belt (the <code>DataOutputStream</code>). The underlying network system takes care of sending these bytes through the <code>Socket</code> to the server.</li> </ul> <p>Simple! The <code>Connection</code> doesn't need to know what's inside <code>message</code>, only how to get the framed bytes from it and write them to the stream.</p>"},{"location":"07_connection__network_stream_handling__/#receiving-a-package-connectionreceive","title":"Receiving a Package: <code>Connection.receive()</code>","text":"<p>When data arrives from the server, how does the <code>Client</code> get it? It asks the <code>Connection</code> object by calling the <code>receive()</code> method. Since we know (from Chapter 6) that all data is sent in 128-byte frames, the <code>receive()</code> method expects to read exactly 128 bytes.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    public TransportMessage receive() {\n\n        TransportMessage message = null; // Where we'll store the result\n        byte[] recvbuf; // A temporary buffer to hold the incoming 128 bytes\n\n        try {\n            // 1. Create an empty byte array exactly 128 bytes long\n            recvbuf = new byte[MessageConfig.SEGMENTSIZE];\n\n            // 2. Read exactly 128 bytes from the input stream into the buffer\n            //    This will wait ('block') if data isn't available yet.\n            int read = inStream.read(recvbuf, 0, MessageConfig.SEGMENTSIZE);\n\n            // Basic check if we actually read the expected amount\n            if (read != MessageConfig.SEGMENTSIZE) {\n                throw new IOException(\"Receive - did not read full segment\");\n            }\n\n            // 3. Create a new, empty TransportMessage object\n            message = new TransportMessage();\n\n            // 4. Tell the TransportMessage to extract the payload\n            //    from the received 128 bytes using decapsulate() (Chapter 6)\n            message.decapsulate(recvbuf);\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Receive Error: \" + ex.getMessage());\n            // Handle errors (e.g., connection closed)\n            // Returning null indicates failure\n            message = null;\n        }\n\n        // 5. Return the TransportMessage, now containing the extracted payload\n        return message;\n    }\n</code></pre> <ul> <li>Step 1: An empty byte array <code>recvbuf</code> of size 128 is created. This is where the incoming data will be temporarily stored.</li> <li>Step 2: <code>inStream.read(recvbuf, 0, MessageConfig.SEGMENTSIZE)</code> is the crucial part. This command tells the <code>DataInputStream</code> to read bytes from the network and fill the <code>recvbuf</code>. It will wait until exactly 128 bytes have been received.</li> <li>Step 3: A new, empty <code>TransportMessage</code> object is created.</li> <li>Step 4: <code>message.decapsulate(recvbuf)</code> is called. As we saw in Chapter 6, this method looks at the first byte of <code>recvbuf</code> to find the length, then copies the actual payload bytes from <code>recvbuf</code> into the <code>message</code> object's internal <code>payload</code> field.</li> <li>Step 5: The <code>message</code> object, now containing the extracted payload bytes, is returned. The caller (usually the <code>Client</code>) now has the raw data of the message that was sent by the server.</li> </ul>"},{"location":"07_connection__network_stream_handling__/#how-sending-works-under-the-hood","title":"How Sending Works: Under the Hood","text":"<p>Let's visualize the <code>send()</code> process:</p> <pre><code>sequenceDiagram\n    participant Cl as Client\n    participant Conn as Connection\n    participant TM as TransportMessage\n    participant DOS as DataOutputStream\n    participant Sock as Socket\n\n    Cl-&gt;&gt;Conn: connection.send(myTransportMessage)\n    Conn-&gt;&gt;TM: myTransportMessage.encapsulate()\n    TM--&gt;&gt;Conn: Return 128-byte framedData\n    Conn-&gt;&gt;DOS: outStream.write(framedData)\n    DOS-&gt;&gt;Sock: Write bytes to Socket\n    Sock-&gt;&gt;Sock: Send bytes over Network\n</code></pre> <p>The <code>Client</code> asks the <code>Connection</code> to send. The <code>Connection</code> gets the framed bytes from the <code>TransportMessage</code> and writes them to the <code>DataOutputStream</code>, which sends them through the <code>Socket</code>.</p>"},{"location":"07_connection__network_stream_handling__/#closing-the-docking-bay-connectionclose","title":"Closing the Docking Bay: <code>Connection.close()</code>","text":"<p>When the user disconnects or the application shuts down, it's important to clean up the network resources. This means closing the streams and the socket.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    // Close the connection by closing streams and the underlying socket\n    public void close() {\n        try {\n            // Close the outgoing stream\n            outStream.close();\n            // Close the incoming stream\n            inStream.close();\n            // Close the network socket itself\n            socket.close();\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Close Error: \" + ex.getMessage());\n            // Handle errors\n        }\n    }\n</code></pre> <p>This method simply calls <code>close()</code> on both streams and the socket to release the network connection gracefully.</p>"},{"location":"07_connection__network_stream_handling__/#conclusion","title":"Conclusion","text":"<p>The <code>Connection</code> class is our application's \"delivery truck,\" responsible for the low-level task of sending and receiving byte streams over the network.</p> <ul> <li>It wraps a <code>Socket</code> (the connection endpoint) and manages <code>DataInputStream</code> and <code>DataOutputStream</code> (the conveyor belts).</li> <li><code>send(TransportMessage message)</code> uses <code>message.encapsulate()</code> to get the 128-byte frame and writes it to the <code>DataOutputStream</code>.</li> <li><code>receive()</code> reads exactly 128 bytes from the <code>DataInputStream</code>, creates a <code>TransportMessage</code>, and uses <code>message.decapsulate()</code> to extract the payload.</li> <li>It relies on the framing strategy defined in <code>TransportMessage</code> (Chapter 6) to know how much data to read and how to extract the payload.</li> <li><code>close()</code> cleans up the network resources.</li> </ul> <p>The <code>Connection</code> deals only with the framed bytes. It successfully delivers the <code>TransportMessage</code> box, but the box still contains raw payload bytes. How do we turn those bytes back into the meaningful <code>Message</code> objects (like <code>PublishMsg</code> or <code>ConnectMsg</code>) that our application logic understands?</p> <p>That's the final piece of the puzzle! In the next chapter, we'll explore Chapter 8: MessageUtils (Serialization/Deserialization), the utility that converts our Java message objects to bytes (for sending) and converts received bytes back into objects.</p>"},{"location":"08_messageutils__serialization_deserialization__/","title":"Chapter 8: MessageUtils (Serialization/Deserialization)","text":"<p>Welcome to the final chapter of our core tutorial! In Chapter 7: Connection (Network Stream Handling), we saw how the <code>Connection</code> class acts like a delivery truck, sending and receiving standard-sized 128-byte packages (<code>TransportMessage</code> from Chapter 6) over the network.</p> <p>However, there's a crucial step we haven't fully explored. Inside those 128-byte packages are the raw payload bytes. When we send a message, how do we convert our meaningful Java <code>Message</code> objects (like <code>PublishMsg</code> from Chapter 1) into those raw bytes? And when we receive a package, how do we turn the payload bytes back into a usable <code>Message</code> object that our application logic (Chapter 5: Controller) can understand?</p> <p>This conversion process is like translating between languages \u2013 the language of our Java application (objects) and the language of the network (bytes).</p>"},{"location":"08_messageutils__serialization_deserialization__/#the-translator-and-packager-messageutils","title":"The Translator and Packager: <code>MessageUtils</code>","text":"<p>Imagine you want to send a detailed instruction manual (our <code>Message</code> object) to someone overseas. You can't just beam the manual directly! 1.  Translate: You might first translate it into a universally understood format, like simple English or maybe a standard code (like JSON). 2.  Package: Then, you need to write this translated version down onto paper (convert to bytes) and put it in a standard shipping box (<code>TransportMessage</code>).</p> <p>When the person receives the box, they do the reverse: 1.  Unpack: They take the paper out of the box. 2.  Translate Back: They read the standard format and reconstruct the original instruction manual in their own language.</p> <p>The <code>MessageUtils</code> class (<code>MessageUtils.java</code>) acts as our application's translator and packager. It's a collection of helper tools (static methods) specifically designed to:</p> <ul> <li>Serialize: Convert a <code>Message</code> object into a standard format (JSON string) and then into raw bytes, ready to be put into a <code>TransportMessage</code> for sending.</li> <li>Deserialize: Take raw bytes received from a <code>TransportMessage</code>, convert them back into the standard format (JSON string), and then reconstruct the original <code>Message</code> object.</li> </ul>"},{"location":"08_messageutils__serialization_deserialization__/#why-json-a-universal-language","title":"Why JSON? A Universal Language","text":"<p>Instead of inventing our own complex way to represent message objects as bytes, we use a popular, standard format called JSON (JavaScript Object Notation).</p> <p>JSON is human-readable text that uses key-value pairs. A <code>PublishMsg</code> object might look like this in JSON:</p> <pre><code>{\n  \"type\": \"PUBLISH\",\n  \"user\": \"Alice\",\n  \"topic\": \"general\",\n  \"message\": \"Hello there!\"\n}\n</code></pre> <p>Why use JSON? *   Readable: Humans can easily read and understand it (great for debugging!). *   Standard: Many programming languages and systems understand JSON, making it great for communication. *   Simple: It's relatively easy to convert Java objects to and from JSON.</p>"},{"location":"08_messageutils__serialization_deserialization__/#using-gson-our-json-translator-tool","title":"Using GSON: Our JSON Translator Tool","text":"<p>To handle the conversion between our Java <code>Message</code> objects and JSON strings, we use a popular Java library called GSON (from Google). Think of GSON as a specialized translator that knows how to read Java object fields (like <code>user</code>, <code>topic</code>) and write them into JSON format, and vice-versa.</p> <p>You'll notice <code>import com.google.gson.*;</code> at the top of <code>MessageUtils.java</code> - that's us bringing in the GSON library.</p>"},{"location":"08_messageutils__serialization_deserialization__/#serialization-object-json-bytes","title":"Serialization: Object -&gt; JSON -&gt; Bytes","text":"<p>Let's see how <code>MessageUtils</code> handles serialization when we want to send a message.</p> <p>Step 1: Object to JSON String (<code>toJson</code>)</p> <p>This method takes any <code>Message</code> object and uses GSON to turn it into a JSON string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport com.google.gson.Gson; // Import the GSON library\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    public static String toJson(Message msg) {\n        // Create a GSON translator instance\n        Gson gson = new Gson();\n        // Tell GSON to convert the Message object into a JSON string\n        String json = gson.toJson(msg);\n        // Return the resulting JSON string\n        return json;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object (e.g., <code>new PublishMsg(\"Alice\", \"general\", \"Hello!\")</code>). *   Output: A JSON string (e.g., <code>{\"type\":\"PUBLISH\",\"user\":\"Alice\",\"topic\":\"general\",\"message\":\"Hello there!\"}</code>). *   How: It simply uses <code>gson.toJson(msg)</code>. GSON automatically looks at the fields in the <code>msg</code> object and creates the corresponding JSON structure.</p> <p>Step 2: JSON String to Bytes (<code>getBytes</code>)</p> <p>Now that we have the JSON string, we need to convert it into the raw bytes that can be sent over the network. Java strings have a built-in method for this.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... toJson method ...\n\n    public static byte[] getBytes(Message msg) {\n        // First, convert the Message object to a JSON string\n        String jsonString = toJson(msg);\n        // Then, convert the string into an array of bytes\n        // using the default character encoding (usually UTF-8)\n        byte[] bytes = jsonString.getBytes();\n        // Return the byte array\n        return bytes;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object. *   Output: A <code>byte[]</code> array representing the JSON string. *   How: It calls <code>toJson()</code> first, then calls the standard Java <code>.getBytes()</code> method on the resulting string.</p> <p>Step 3: Bytes into a TransportMessage (<code>toTransportMessage</code>)</p> <p>Finally, we take these bytes and put them into the <code>TransportMessage</code> frame we learned about in Chapter 6.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport no.hvl.dat110.messagetransport.TransportMessage; // Import TransportMessage\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... toJson, getBytes methods ...\n\n    public static TransportMessage toTransportMessage(Message msg) {\n        // 1. Convert the Message object to bytes (via JSON)\n        byte[] payloadBytes = getBytes(msg);\n        // 2. Create a new TransportMessage containing these bytes as payload\n        TransportMessage transportMsg = new TransportMessage(payloadBytes);\n        // Return the prepared TransportMessage\n        return transportMsg;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object. *   Output: A <code>TransportMessage</code> object ready to be sent by the <code>Connection</code>. *   How: It calls <code>getBytes()</code> to get the payload, then creates a <code>new TransportMessage()</code> using those bytes.</p> <p>This <code>toTransportMessage</code> method is the primary serialization helper used by the <code>Client</code> before sending.</p>"},{"location":"08_messageutils__serialization_deserialization__/#deserialization-bytes-json-object","title":"Deserialization: Bytes -&gt; JSON -&gt; Object","text":"<p>Now let's look at the reverse process when we receive data. The <code>Connection</code> gives us a <code>TransportMessage</code> containing payload bytes.</p> <p>Step 1: Extract Bytes from TransportMessage (<code>fromTransportMessage</code>)</p> <p>This method takes the received <code>TransportMessage</code> and extracts the raw payload bytes.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... serialization methods ...\n\n    public static Message fromTransportMessage(TransportMessage msg) {\n        // 1. Get the raw payload bytes from the TransportMessage\n        byte[] payloadBytes = msg.getData();\n        // 2. Convert these bytes back into a Message object\n        Message originalMessage = fromBytes(payloadBytes);\n        // Return the reconstructed Message object\n        return originalMessage;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>TransportMessage</code> received from the <code>Connection</code>. *   Output: The reconstructed <code>Message</code> object. *   How: It calls <code>msg.getData()</code> to get the payload bytes, then passes these bytes to the <code>fromBytes</code> method (explained next).</p> <p>Step 2: Bytes to JSON String (<code>fromBytes</code>)</p> <p>This method takes the raw bytes and converts them back into a JSON string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... fromTransportMessage method ...\n\n    public static Message fromBytes(byte[] payload) {\n        // Convert the byte array back into a String\n        String jsonString = new String(payload);\n        // Convert the JSON string into a Message object\n        Message message = fromJson(jsonString);\n        // Return the reconstructed object\n        return message;\n    }\n\n    // ... fromJson method ...\n}\n</code></pre> *   Input: A <code>byte[]</code> array (the payload). *   Output: A <code>Message</code> object. *   How: It uses <code>new String(payload)</code> to turn the bytes back into a string (assuming the same character encoding, usually UTF-8). Then, it calls <code>fromJson()</code> (explained next) to parse this string.</p> <p>Step 3: JSON String to Object (<code>fromJson</code>)</p> <p>This is the core of deserialization where GSON reconstructs the specific <code>Message</code> object. Since the JSON only tells us the <code>type</code> (like \"PUBLISH\"), we need to help GSON figure out which Java class to create (<code>PublishMsg</code>, <code>ConnectMsg</code>, etc.).</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport com.google.gson.*; // Need more GSON classes here\nimport no.hvl.dat110.messages.MessageType; // Need the enum\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... fromBytes method ...\n\n    public static Message fromJson(String msgJson) {\n\n        // 1. Parse the raw JSON string into a generic JSON object structure\n        JsonParser jsonParser = new JsonParser();\n        JsonObject json = jsonParser.parse(msgJson).getAsJsonObject();\n\n        // 2. Look inside the JSON to find the \"type\" field's value\n        String typestr = json.get(\"type\").getAsString(); // e.g., \"PUBLISH\"\n\n        // 3. Convert the type string into our MessageType enum\n        MessageType type = MessageType.valueOf(typestr); // e.g., MessageType.PUBLISH\n\n        // 4. Create a GSON instance\n        Gson gson = new Gson();\n        Message message = null; // Variable to hold the final object\n\n        // 5. Use a switch based on the type to tell GSON which class to build\n        switch (type) {\n            case CONNECT:\n                message = gson.fromJson(json, ConnectMsg.class);\n                break;\n            case PUBLISH:\n                message = gson.fromJson(json, PublishMsg.class);\n                break;\n            case SUBSCRIBE:\n                message = gson.fromJson(json, SubscribeMsg.class);\n                break;\n            // ... cases for all other MessageTypes ...\n            default:\n                System.out.println(\"fromJson - unknown message type: \" + typestr);\n                break;\n        }\n\n        // Return the specific Message object (e.g., a PublishMsg instance)\n        return message;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A JSON string (e.g., <code>{\"type\":\"PUBLISH\",\"user\":\"Alice\",...}</code>). *   Output: A specific <code>Message</code> object (e.g., a <code>PublishMsg</code> instance). *   How:     *   It first parses the string into a general <code>JsonObject</code>.     *   It extracts the value of the <code>\"type\"</code> field.     *   It uses a <code>switch</code> statement based on this type.     *   Inside the correct <code>case</code>, it calls <code>gson.fromJson(json, SpecificMsgClass.class)</code>. This tells GSON: \"Take the data from this <code>json</code> object and use it to create an instance of this specific class (e.g., <code>PublishMsg.class</code>)\". GSON automatically matches JSON fields to the Java class fields.</p> <p>This <code>fromTransportMessage</code> (which uses <code>fromBytes</code> and <code>fromJson</code>) is the primary deserialization helper used by the <code>Client</code> after receiving data.</p>"},{"location":"08_messageutils__serialization_deserialization__/#convenience-methods-send-and-receive","title":"Convenience Methods: <code>send</code> and <code>receive</code>","text":"<p><code>MessageUtils</code> also provides two high-level convenience methods that combine the translation step with the actual network sending/receiving.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport no.hvl.dat110.messagetransport.Connection; // Need Connection\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... all the conversion methods ...\n\n    // Sends a Message object over a Connection\n    public static void send (Connection connection, Message message) {\n        // 1. Convert the Message object to a TransportMessage\n        TransportMessage transportMsg = toTransportMessage(message);\n        // 2. Tell the connection to send it\n        connection.send(transportMsg);\n    }\n\n    // Receives the next Message object from a Connection\n    public static Message receive (Connection connection) {\n        // 1. Tell the connection to receive the next 128-byte frame\n        TransportMessage transportMsg = connection.receive();\n        // 2. If successful, convert the TransportMessage back to a Message object\n        Message message = null;\n        if (transportMsg != null) {\n            message = fromTransportMessage(transportMsg);\n        }\n        // Return the reconstructed Message object (or null if receive failed)\n        return message;\n    }\n}\n</code></pre> *   <code>send(connection, message)</code>: A shortcut that takes your <code>Message</code> object, serializes it into a <code>TransportMessage</code> using <code>toTransportMessage</code>, and then calls <code>connection.send()</code> to send it over the network. *   <code>receive(connection)</code>: A shortcut that calls <code>connection.receive()</code> to get the next <code>TransportMessage</code>, and if successful, deserializes it back into the original <code>Message</code> object using <code>fromTransportMessage</code>.</p> <p>The <code>Client</code> primarily uses these <code>send</code> and <code>receive</code> methods for cleaner code.</p>"},{"location":"08_messageutils__serialization_deserialization__/#under-the-hood-gson-at-work","title":"Under the Hood: GSON at Work","text":"<p>Let's visualize the core GSON translation steps.</p> <p>Serialization (<code>toJson</code>):</p> <pre><code>sequenceDiagram\n    participant Client as Client Code\n    participant MU as MessageUtils\n    participant GSON as GSON Library\n    participant PubMsg as PublishMsg Object\n\n    Client-&gt;&gt;MU: toJson(myPublishMsg)\n    Note right of Client: myPublishMsg has user=\"Alice\", topic=\"news\", ...\n    MU-&gt;&gt;GSON: gson.toJson(myPublishMsg)\n    GSON-&gt;&gt;PubMsg: Read field 'type' (PUBLISH)\n    GSON-&gt;&gt;PubMsg: Read field 'user' (\"Alice\")\n    GSON-&gt;&gt;PubMsg: Read field 'topic' (\"news\")\n    GSON-&gt;&gt;PubMsg: Read field 'message' (\"Hello\")\n    GSON--&gt;&gt;MU: Return JSON String: \"{\\\"type\\\":\\\"PUBLISH\\\",\\\"user\\\":\\\"Alice\\\",...}\"\n    MU--&gt;&gt;Client: Return JSON String\n</code></pre> <p>Deserialization (<code>fromJson</code> for a PublishMsg):</p> <pre><code>sequenceDiagram\n    participant Client as Client Code\n    participant MU as MessageUtils\n    participant Parser as JsonParser\n    participant GSON as GSON Library\n\n    Client-&gt;&gt;MU: fromJson(\"{\\\"type\\\":\\\"PUBLISH\\\",\\\"user\\\":\\\"Alice\\\",...}\")\n    MU-&gt;&gt;Parser: parser.parse(jsonString)\n    Parser--&gt;&gt;MU: Return JsonObject 'json'\n    MU-&gt;&gt;MU: Get type from json (\"PUBLISH\")\n    MU-&gt;&gt;MU: Switch -&gt; case PUBLISH:\n    MU-&gt;&gt;GSON: gson.fromJson(json, PublishMsg.class)\n    GSON-&gt;&gt;GSON: Create new empty PublishMsg object\n    GSON-&gt;&gt;GSON: Find \"user\" in json, set object.user = \"Alice\"\n    GSON-&gt;&gt;GSON: Find \"topic\" in json, set object.topic = \"news\"\n    GSON-&gt;&gt;GSON: Find \"message\" in json, set object.message = \"Hello\"\n    GSON--&gt;&gt;MU: Return populated PublishMsg object\n    MU--&gt;&gt;Client: Return Message object (as PublishMsg)\n</code></pre>"},{"location":"08_messageutils__serialization_deserialization__/#conclusion","title":"Conclusion","text":"<p>The <code>MessageUtils</code> class is the essential translator between our application's Java <code>Message</code> objects and the raw bytes needed for network transmission.</p> <ul> <li>It uses the JSON format as a standard, readable intermediate representation.</li> <li>It relies on the GSON library to perform the actual conversion between Java objects and JSON strings.</li> <li>Serialization (<code>toTransportMessage</code>): Converts <code>Message</code> -&gt; JSON String -&gt; <code>byte[]</code> -&gt; <code>TransportMessage</code>.</li> <li>Deserialization (<code>fromTransportMessage</code>): Converts <code>TransportMessage</code> -&gt; <code>byte[]</code> -&gt; JSON String -&gt; <code>Message</code>.</li> <li>The <code>fromJson</code> method uses the <code>\"type\"</code> field within the JSON to determine which specific <code>Message</code> subclass to create.</li> <li>Helper methods <code>send</code> and <code>receive</code> simplify the process for the <code>Client</code>.</li> </ul> <p>With <code>MessageUtils</code>, we complete the communication pipeline. We can now create message objects, translate and package them, send them over the network using the connection, receive packages, and translate them back into objects the application can understand.</p> <p>This concludes our tour of the core components of the <code>dat110-project2-javafx-chatapp</code> client! We've covered the message structure, client logic, application entry point, UI areas, controller, network framing, connection handling, and finally, the serialization/deserialization mechanism. You now have a foundational understanding of how these pieces work together to create a functional chat client.</p>"}]}