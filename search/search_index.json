{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li>DAT110 - Project 1: Socket Programming and RPC middleware</li> <li>DAT110 - Project 2: JavaFX-chatapp</li> <li>DAT110 - Project 3: DHT</li> </ul>"},{"location":"oblig1/01_rpc_client_stub_/","title":"Chapter 1: RPC Client Stub","text":"<p>Welcome to the first chapter of our tutorial for <code>dat110-project1-gruppe69</code>! We're going to build a small system where different parts talk to each other over a network. Let's start with a common problem: How can one program ask another program, possibly running on a different computer, to do something for it?</p> <p>Imagine you have a Controller application that needs to know the current temperature. This temperature reading comes from a Sensor application, which might be running on a separate device. How does the Controller ask the Sensor for the temperature? It sounds complicated, involving networks and sending data back and forth.</p> <p>This is where the RPC Client Stub comes in. RPC stands for Remote Procedure Call. The RPC Client Stub makes this network communication look like a simple, normal function call within your Controller program.</p>"},{"location":"oblig1/01_rpc_client_stub_/#what-is-an-rpc-client-stub","title":"What is an RPC Client Stub?","text":"<p>Think of an RPC Client Stub like a helpful local travel agent. You want to book a flight to another country (call a function on another computer). Instead of figuring out international phone lines, different time zones, and booking systems yourself (dealing with network details), you just talk to your local travel agent (the stub).</p> <p>You tell the agent, \"I want to fly to London on this date.\" (You call a method like <code>sensor.read()</code>). The agent takes your request, handles all the complex booking details with the airline (sends the request over the network), waits for confirmation (waits for the response), and then gives you your ticket (returns the result, like the temperature).</p> <p>So, the RPC Client Stub is:</p> <ol> <li>A Local Object: It lives inside your client application (e.g., the Controller).</li> <li>A Proxy/Stand-in: It pretends to be the remote service (e.g., the Sensor).</li> <li>A Network Hider: It takes care of packaging your request (marshalling), sending it over the network using the underlying RPC Client, receiving the response, and unpacking it (unmarshalling) for you.</li> </ol> <p>This makes your life as a programmer much easier!</p>"},{"location":"oblig1/01_rpc_client_stub_/#using-the-stub-making-remote-calls-look-local","title":"Using the Stub: Making Remote Calls Look Local","text":"<p>Let's look at how the Controller application uses a stub to get the temperature from the Sensor.</p> <pre><code>// Inside Controller.java (Simplified)\n\npublic class Controller {\n    public static void main(String[] args) {\n        // ... setup code ...\n\n        // Assume 'sensorclient' is an RPCClient connected to the Sensor server\n        RPCClient sensorclient = new RPCClient(Common.SENSORHOST, Common.SENSORPORT);\n        sensorclient.connect();\n\n        // Create the stub, giving it the RPCClient to use for communication\n        SensorStub sensor = new SensorStub(sensorclient);\n\n        // Now, call the 'read' method ON THE STUB as if it were local!\n        int currentTemperature = sensor.read();\n\n        System.out.println(\"Controller received temperature: \" + currentTemperature);\n\n        // ... cleanup code ...\n    }\n}\n</code></pre> <p>In this code: *   We create a <code>SensorStub</code> called <code>sensor</code>. *   We call <code>sensor.read()</code>. This looks exactly like calling a method on a normal Java object. *   The <code>SensorStub</code> handles all the networking behind the scenes. *   We get the temperature back as an integer, just like a regular method call.</p>"},{"location":"oblig1/01_rpc_client_stub_/#how-the-stub-works-under-the-hood","title":"How the Stub Works (Under the Hood)","text":"<p>So, what actually happens inside the <code>sensor.read()</code> call? Let's peek inside the <code>SensorStub.java</code> file.</p> <p>First, all client stubs in our project extend a base class called <code>RPCLocalStub</code>. This base class simply holds a reference to the RPC Client which is responsible for the actual network communication.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCLocalStub.java\npackage no.hvl.dat110.rpc;\n\n// Base class for all client-side stubs\npublic abstract class RPCLocalStub {\n\n    protected RPCClient rpcclient; // Holds the client that handles network calls\n\n    public RPCLocalStub(RPCClient rpcclient) {\n        this.rpcclient = rpcclient; // Store the RPCClient when stub is created\n    }\n}\n</code></pre> <p>Now, let's look at the <code>SensorStub</code> itself and its <code>read()</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/system/controller/SensorStub.java\npackage no.hvl.dat110.system.controller;\n\nimport no.hvl.dat110.rpc.*; // Import necessary RPC classes\n\npublic class SensorStub extends RPCLocalStub { // Extends the base stub class\n\n    // Constructor: receives the RPCClient and passes it to the base class\n    public SensorStub(RPCClient rpcclient) {\n        super(rpcclient);\n    }\n\n    // The method our Controller calls\n    public int read() {\n\n        // 1. Marshall parameters: 'read' takes no arguments (void).\n        // We still need to marshal this lack of arguments.\n        byte[] request = RPCUtils.marshallVoid();\n\n        // 2. Make the remote call: Tell the RPCClient to call the method\n        // identified by READ_RPCID, sending the marshalled 'void' parameter.\n        // The rpcclient handles sending/receiving over the network.\n        byte[] response = rpcclient.call((byte)Common.READ_RPCID, request);\n\n        // 3. Unmarshall the return value: The response byte array contains\n        // the marshalled integer (temperature). We need to convert it back.\n        int temp = RPCUtils.unmarshallInteger(response);\n\n        // 4. Return the result to the Controller\n        return temp;\n    }\n}\n</code></pre> <p>Let's break down the <code>read()</code> method step-by-step:</p> <ol> <li>Marshall Parameters: The <code>read()</code> method on the remote Sensor doesn't need any input data. However, the RPC system needs something to send. <code>RPCUtils.marshallVoid()</code> creates a standardized empty byte array representing \"no parameters\". We'll learn more about marshalling in RPC Data Marshalling/Unmarshalling.</li> <li>Invoke <code>rpcclient.call()</code>: This is the core step where the stub delegates the network communication. It calls the <code>call</code> method on the <code>rpcclient</code> object (which was passed into the stub's constructor).<ul> <li><code>Common.READ_RPCID</code>: This is a unique number (like an ID) that tells the server which method we want to run (in this case, the <code>read</code> method).</li> <li><code>request</code>: This is the marshalled data (the empty bytes for <code>void</code>) to send.</li> <li>The <code>rpcclient.call()</code> method (covered in RPC Client) handles sending the request ID and the data over the network and waits until it receives a response back from the server. It returns the raw bytes of the response.</li> </ul> </li> <li>Unmarshall Return Value: The server executed the <code>read</code> method, got the temperature (an integer), marshalled it into bytes, and sent it back. The <code>response</code> variable now holds these bytes. <code>RPCUtils.unmarshallInteger(response)</code> converts these bytes back into a Java <code>int</code>. Again, see RPC Data Marshalling/Unmarshalling for details.</li> <li>Return Result: The final integer <code>temp</code> is returned to the code that called <code>sensor.read()</code> (our <code>Controller</code>).</li> </ol> <p>Here's a simplified diagram showing the flow: <pre><code>sequenceDiagram\n    participant C as Controller\n    participant SS as SensorStub\n    participant RC as RPCClient\n    participant N as Network\n    participant RS as \"Remote Sensor (Server Side)\"\n\n    C-&gt;&gt;SS: read()\n    Note over SS: Prepare request (Marshall void)\n    SS-&gt;&gt;RC: call(READ_RPCID, requestBytes)\n    Note over RC: Handle network sending\n    RC-&gt;&gt;N: Send Request (ID + data)\n    N-&gt;&gt;RS: Receive Request\n    Note over RS: Find and run real read() method\n    RS-&gt;&gt;N: Send Response (Marshalled temperature)\n    Note over RC: Handle network receiving\n    N-&gt;&gt;RC: Receive Response\n    RC--&gt;&gt;SS: return responseBytes\n    Note over SS: Unpack response (Unmarshall integer)\n    SS--&gt;&gt;C: return temperature</code></pre></p>"},{"location":"oblig1/01_rpc_client_stub_/#conclusion","title":"Conclusion","text":"<p>The RPC Client Stub is a powerful abstraction. It acts as a local representative for a remote service, allowing your application code (like the <code>Controller</code>) to call methods on remote objects (like the <code>Sensor</code>) as if they were right there in the same program. It hides the complexities of marshalling data, network communication, and unmarshalling results.</p> <p>You've now seen how the client side initiates a remote call using a stub. But how does the server side receive this request and actually run the code? That's where the server-side counterpart comes in. In the next chapter, we'll look at the basic structure needed on the server to handle these incoming requests.</p> <p>Next up: RPC Server Implementation (Skeleton)</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/","title":"Chapter 2: RPC Server Implementation (Skeleton)","text":"<p>In the previous chapter, we saw how the RPC Client Stub acts like a local travel agent, making a request to a remote service (like getting the temperature from a Sensor) look like a simple local function call (<code>sensor.read()</code>).</p> <p>But what happens on the other side? When the request travels across the network and arrives at the Sensor application (the RPC Server), who actually handles it? How does the server know what to do and how to perform the requested action?</p> <p>That's where the RPC Server Implementation (Skeleton) comes in.</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#what-is-an-rpc-server-implementation-skeleton","title":"What is an RPC Server Implementation (Skeleton)?","text":"<p>Think back to our travel agent analogy from Chapter 1. You (the Controller) told your local agent (the Client Stub) you wanted the temperature. The agent sent the request over the network. Now, the request arrives at the \"remote travel agency\" (the RPC Server).</p> <p>The agency manager (the RPC Server) receives the request, which says \"Execute action #1\" (the <code>READ_RPCID</code>). The manager doesn't handle temperature readings directly. Instead, they look up who specializes in action #1 and forward the request to that specific department.</p> <p>This specialist department is the RPC Server Implementation (Skeleton). In our case, it's the <code>SensorImpl</code> object.</p> <p>So, the RPC Server Implementation (Skeleton) is:</p> <ol> <li>A Server-Side Object: It lives inside the server application (e.g., the Sensor application).</li> <li>A Specialist: It contains the actual code to perform a specific remote procedure (e.g., the real <code>read()</code> method that gets the temperature).</li> <li>An Action Handler: It knows how to unpack the request details (unmarshalling), run the correct code, and package the result (marshalling) to send back.</li> </ol> <p>It's the component that bridges the gap between a generic network request and the specific application logic that needs to run.</p>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#the-invoke-method-where-the-magic-happens","title":"The <code>invoke</code> Method: Where the Magic Happens","text":"<p>Every \"specialist department\" (Skeleton) needs a standard way for the manager (RPC Server) to give it work. In our project, this standard way is a method called <code>invoke</code>.</p> <p>Every Skeleton class (like <code>SensorImpl</code>) must:</p> <ol> <li>Extend <code>RPCRemoteImpl</code>: This is a base class that provides some common setup. We'll see it briefly later.</li> <li>Implement the <code>invoke</code> method: This method is the entry point for the RPC Server. When the server receives a request matching this skeleton's ID (like <code>READ_RPCID</code>), it calls this <code>invoke</code> method.</li> </ol> <p>What does the <code>invoke</code> method do?</p> <ol> <li>Receives Raw Data: It gets the parameters sent by the client stub as a chunk of raw bytes (<code>byte[]</code>).</li> <li>Unmarshalls Parameters: It uses helper functions (from RPC Data Marshalling/Unmarshalling) to convert these bytes back into meaningful data (like knowing the client wants to call <code>read</code> which takes no arguments).</li> <li>Calls the Real Method: It calls the actual application logic method within the same class (e.g., it calls the <code>read()</code> method inside <code>SensorImpl</code>).</li> <li>Gets the Result: It receives the return value from the real method (e.g., the integer temperature).</li> <li>Marshalls Return Value: It uses helper functions again to convert the return value back into raw bytes.</li> <li>Returns Raw Data: It gives the marshalled bytes back to the RPC Server, which will send them back over the network to the client.</li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#example-handling-the-read-request-in-sensorimpl","title":"Example: Handling the <code>read()</code> Request in <code>SensorImpl</code>","text":"<p>Let's look at how <code>SensorImpl.java</code> acts as the skeleton for the Sensor's <code>read</code> method.</p> <p>First, the base class <code>RPCRemoteImpl</code>: All skeletons extend this. Its main job in the constructor is to tell the main RPC Server \"Hey, I exist, and I handle requests with this specific ID.\"</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCRemoteImpl.java\npackage no.hvl.dat110.rpc;\n\npublic abstract class RPCRemoteImpl {\n\n    // Constructor called by subclasses (like SensorImpl)\n    public RPCRemoteImpl(byte rpcid, RPCServer rpcserver) {\n        // Register this implementation with the server,\n        // associating it with the given rpcid\n        rpcserver.register(rpcid, this);\n    }\n\n    // The method subclasses MUST implement to handle requests\n    public abstract byte[] invoke(byte[] params);\n}\n</code></pre> This code tells us that any class extending <code>RPCRemoteImpl</code> needs to provide its own <code>invoke</code> method. The constructor ensures the RPC Server knows which skeleton handles which ID.</p> <p>Now, the <code>SensorImpl</code> itself:</p> <pre><code>// File: src/main/java/no/hvl/dat110/system/sensor/SensorImpl.java\npackage no.hvl.dat110.system.sensor;\n\nimport no.hvl.dat110.rpc.*; // Import necessary RPC classes\n\npublic class SensorImpl extends RPCRemoteImpl { // Extends the base class\n\n    // Constructor: tells the base class its ID (READ_RPCID)\n    // and which RPCServer it belongs to.\n    public SensorImpl(byte rpcid, RPCServer rpcserver) {\n        super(rpcid, rpcserver); // Calls the RPCRemoteImpl constructor\n    }\n\n    // The ACTUAL application logic for reading the sensor\n    public int read() {\n        // Simulate getting a temperature reading\n        int temp = (int) Math.ceil(20 * Math.sin(System.currentTimeMillis() / 1000.0));\n        System.out.println(\"Sensor read temperature: \" + temp);\n        return temp;\n    }\n\n    // The invoke method called by the RPCServer for READ_RPCID\n    @Override\n    public byte[] invoke(byte[] param) {\n        // 1. Unmarshall Parameters: 'read' expects no arguments (void).\n        RPCUtils.unmarshallVoid(param); // Check param is correctly 'void'\n\n        // 2. Call the Real Method: Execute the actual sensor reading logic.\n        int temperature = read();\n\n        // 3. Marshall Return Value: Convert the integer result into bytes.\n        byte[] returnval = RPCUtils.marshallInteger(temperature);\n\n        // 4. Return marshalled bytes to the RPC Server\n        return returnval;\n    }\n}\n</code></pre> <p>Let's break down <code>SensorImpl</code>:</p> <ol> <li><code>extends RPCRemoteImpl</code>: Marks this as a server-side implementation skeleton.</li> <li>Constructor: When a <code>SensorImpl</code> object is created, it registers itself with the main RPC Server using the RPC ID provided (e.g., <code>Common.READ_RPCID</code>).</li> <li><code>read()</code> method: This is the actual Java method that performs the sensor reading. This is the core application logic. It returns a simple integer.</li> <li><code>invoke(byte[] param)</code> method: This is the method the RPC Server calls when a request with <code>Common.READ_RPCID</code> arrives.<ul> <li>It first unmarshalls the <code>param</code> byte array. Since <code>read()</code> takes no arguments, <code>RPCUtils.unmarshallVoid</code> just checks that the received parameters represent \"nothing\".</li> <li>It then calls the local <code>read()</code> method within the same <code>SensorImpl</code> object to get the actual temperature.</li> <li>It takes the integer <code>temperature</code> returned by <code>read()</code>.</li> <li>It marshalls this integer into a byte array using <code>RPCUtils.marshallInteger</code>. (More on this in RPC Data Marshalling/Unmarshalling).</li> <li>Finally, it returns the marshalled byte array. The RPC Server will take these bytes and send them back as the response.</li> </ul> </li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#how-the-rpc-server-uses-the-skeleton","title":"How the RPC Server Uses the Skeleton","text":"<p>Imagine the RPC Server receives a network message. It unpacks it and finds it's an RPC request with ID <code>1</code> (let's say <code>Common.READ_RPCID</code> is 1) and some parameter bytes.</p> <pre><code>sequenceDiagram\n    participant ClientStub as Client Stub\n    participant Network\n    participant RpcServer as RPC Server\n    participant Skeleton as SensorImpl (Skeleton)\n    participant AppLogic as SensorImpl.read()\n\n    ClientStub-&gt;&gt;Network: Send Request (ID=1, void_bytes)\n    Network-&gt;&gt;RpcServer: Receive Request (ID=1, void_bytes)\n    Note over RpcServer: Look up ID=1 -&gt; finds SensorImpl\n    RpcServer-&gt;&gt;Skeleton: invoke(void_bytes)\n    Note over Skeleton: Unmarshall void_bytes\n    Skeleton-&gt;&gt;AppLogic: Call real read() method\n    AppLogic--&gt;&gt;Skeleton: return temperature (e.g., 17)\n    Note over Skeleton: Marshall integer 17 -&gt; temp_bytes\n    Skeleton--&gt;&gt;RpcServer: return temp_bytes\n    RpcServer-&gt;&gt;Network: Send Response (temp_bytes)\n    Network-&gt;&gt;ClientStub: Receive Response (temp_bytes)</code></pre> <p>The RPC Server maintains a registry (a map) where it stored the <code>SensorImpl</code> object when it was created, associating it with <code>READ_RPCID</code>.</p> <ol> <li>The server sees the ID <code>1</code>.</li> <li>It looks in its registry and finds the <code>SensorImpl</code> object associated with ID <code>1</code>.</li> <li>It calls the <code>invoke</code> method on that specific <code>SensorImpl</code> object, passing the parameter bytes (<code>void_bytes</code>).</li> <li>The <code>SensorImpl.invoke</code> method does its work (unmarshall, call <code>read</code>, marshall result) and returns the result bytes (<code>temp_bytes</code>).</li> <li>The server takes these <code>temp_bytes</code> and sends them back over the network.</li> </ol>"},{"location":"oblig1/02_rpc_server_implementation__skeleton__/#conclusion","title":"Conclusion","text":"<p>The RPC Server Implementation (Skeleton), like <code>SensorImpl</code>, is the server-side specialist that handles a specific remote procedure call. It extends <code>RPCRemoteImpl</code> and implements the crucial <code>invoke</code> method. Inside <code>invoke</code>, it acts as a bridge: unmarshalling incoming request parameters, calling the actual application logic (like the real <code>read()</code> method), and marshalling the result to be sent back. It ensures that when a request arrives at the server, the correct piece of code is executed.</p> <p>We've now seen the client-side stub that initiates the call and the server-side skeleton that executes the call. But how does the message actually get from the stub to the server? We need components that manage the network connection and the sending/receiving of these requests and replies.</p> <p>Next up, we'll look at the client-side component responsible for managing this network communication: the RPC Client.</p>"},{"location":"oblig1/03_rpc_client_/","title":"Chapter 3: RPC Client","text":"<p>In the previous chapters, we met the RPC Client Stub (like <code>SensorStub</code>), which acts as a local stand-in for a remote service, making remote function calls look easy like <code>sensor.read()</code>. We also saw the RPC Server Implementation (Skeleton) (like <code>SensorImpl</code>), which contains the actual code on the server that performs the requested action.</p> <p>But there's a missing piece! How does the request from the Stub actually travel across the network to reach the server, and how does the response get back? The Stub itself doesn't handle the nitty-gritty network details. It delegates this task to another component: the RPC Client.</p>"},{"location":"oblig1/03_rpc_client_/#whats-the-problem-sending-the-message","title":"What's the Problem? Sending the Message!","text":"<p>Imagine our <code>SensorStub</code> wants to call the <code>read</code> method on the remote Sensor server. The Stub knows what to call (the <code>read</code> method, identified by <code>READ_RPCID</code>) and it prepares the \"no parameters\" message (<code>RPCUtils.marshallVoid()</code>). But how does it:</p> <ol> <li>Find the right server computer on the network?</li> <li>Establish a reliable communication channel?</li> <li>Send the request data (<code>READ_RPCID</code> + marshalled parameters)?</li> <li>Wait patiently for the server to process the request and send back a result?</li> <li>Receive the result data?</li> </ol> <p>This sounds like a lot of work involving network addresses, ports, sending/receiving bytes, and handling potential network issues. The Stub shouldn't worry about this; it just wants to make the call look simple.</p>"},{"location":"oblig1/03_rpc_client_/#the-rpc-client-your-personal-network-courier","title":"The RPC Client: Your Personal Network Courier","text":"<p>This is where the RPC Client comes in. Think of it as a dedicated network courier service that the RPC Client Stub uses.</p> <ul> <li>The Stub (Customer): Decides what needs to be done remotely (e.g., \"get temperature\"). It prepares the order form (marshalled request: RPC ID + parameters).</li> <li>The RPC Client (Courier Service): Takes the order form from the Stub. It knows the address of the remote shop (RPC Server). It handles establishing the delivery route (network connection), sends the order form (request), waits for the shop to prepare the item, picks up the packaged item (marshalled response), and delivers it back to the Stub.</li> <li>The Network (Roads/Mail System): The underlying infrastructure used by the courier.</li> <li>The RPC Server (Remote Shop): Receives the order, processes it, and gives the result back to the courier.</li> </ul> <p>So, the RPC Client is:</p> <ol> <li>A Connection Manager: It's responsible for connecting to a specific RPC Server at a known network address and port.</li> <li>A Request/Reply Handler: It provides a <code>call</code> method that takes the details from the Stub, sends them over the network, waits for the response, and returns it.</li> <li>A Messaging Layer User: It doesn't handle raw network sockets directly. Instead, it relies on the lower-level Messaging Connection to do the actual sending and receiving of byte sequences.</li> </ol>"},{"location":"oblig1/03_rpc_client_/#how-the-stub-uses-the-rpc-client","title":"How the Stub Uses the RPC Client","text":"<p>Remember this line from <code>SensorStub.java</code>?</p> <pre><code>// Inside SensorStub.read()\n// ... marshall parameters ...\nbyte[] response = rpcclient.call((byte)Common.READ_RPCID, request);\n// ... unmarshall response ...\n</code></pre> <p>Here's what's happening:</p> <ol> <li>The <code>SensorStub</code> has an instance of <code>RPCClient</code> (named <code>rpcclient</code>) that was given to it when it was created. This <code>rpcclient</code> object is already configured to talk to the Sensor server.</li> <li>The stub calls the <code>call</code> method on its <code>rpcclient</code> object.</li> <li>It passes two things to <code>call</code>:<ul> <li><code>Common.READ_RPCID</code>: The unique number identifying the remote <code>read</code> method.</li> <li><code>request</code>: The marshalled parameters (in this case, the bytes representing \"no parameters\").</li> </ul> </li> <li>The stub then waits. The <code>rpcclient.call()</code> method will not return until it gets a response back from the server.</li> <li>When <code>rpcclient.call()</code> finally returns, it gives back the raw byte array (<code>response</code>) containing the marshalled result (the temperature) sent by the server.</li> </ol> <p>The <code>RPCClient</code> object handles all the communication steps in between.</p>"},{"location":"oblig1/03_rpc_client_/#inside-the-rpc-client-connecting-and-calling","title":"Inside the RPC Client: Connecting and Calling","text":"<p>Let's peek inside <code>RPCClient.java</code> to see how it works.</p> <p>1. Connecting to the Server (<code>connect</code>)</p> <p>Before the Stub can make any calls, the <code>RPCClient</code> needs to establish a connection to the RPC Server. This usually happens once when the client application starts up.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCClient.java (Simplified)\npackage no.hvl.dat110.rpc;\n\nimport no.hvl.dat110.messaging.*;\n\npublic class RPCClient {\n\n    // Holds the connection details and methods for sending/receiving messages\n    private MessagingClient msgclient;\n    private MessageConnection connection;\n\n    // Constructor: remembers server address and port\n    public RPCClient(String server, int port) {\n        // Creates a client object from the messaging layer\n        msgclient = new MessagingClient(server, port);\n    }\n\n    // Establishes the actual network connection\n    public void connect() {\n        // Use the messaging client to connect and store the connection\n        connection = msgclient.connect();\n        // Now we have an active link to the server!\n    }\n\n    // ... call method is next ...\n\n    // Closes the network connection\n    public void disconnect() {\n        // Close the underlying messaging connection\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}\n</code></pre> <ul> <li>The constructor just stores the server's address (<code>server</code>, <code>port</code>) by creating a <code>MessagingClient</code> (from the Messaging Connection layer).</li> <li>The <code>connect()</code> method is the important part here. It calls <code>msgclient.connect()</code>. This tells the underlying messaging layer to actually create a network connection (like a TCP socket connection) to the specified server and port.</li> <li>The established connection is stored in the <code>connection</code> variable. This <code>connection</code> object is what we'll use to send and receive messages.</li> </ul> <p>2. Making the Remote Call (<code>call</code>)</p> <p>This is the core method used by the Stubs. It orchestrates the request-reply interaction.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCClient.java (Simplified call method)\n\npublic class RPCClient {\n    // ... constructor, connect, disconnect, connection variable ...\n\n    public byte[] call(byte rpcid, byte[] params) {\n\n        // 1. Package the request: Combine RPC ID and parameters into\n        //    a single byte array using a standard format.\n        //    (See RPC Data Marshalling/Unmarshalling chapter for details)\n        byte[] requestData = RPCUtils.encapsulate(rpcid, params);\n\n        // 2. Create a Message object (from the messaging layer)\n        Message requestMessage = new Message(requestData);\n\n        // 3. Send the message over the established connection\n        connection.send(requestMessage);\n\n        // 4. Wait to receive the reply message from the server\n        Message replyMessage = connection.receive();\n\n        // 5. Unpack the reply: Extract the actual result bytes\n        //    from the received message format.\n        //    (See RPC Data Marshalling/Unmarshalling chapter for details)\n        byte[] returnval = RPCUtils.decapsulate(replyMessage.getData());\n\n        // 6. Return the marshalled result bytes to the Stub\n        return returnval;\n    }\n}\n</code></pre> <p>Let's break down the <code>call</code> method:</p> <ol> <li>Encapsulate Request: It takes the <code>rpcid</code> (e.g., <code>READ_RPCID</code>) and the marshalled <code>params</code> (e.g., the \"void\" bytes) and combines them into a single byte array (<code>requestData</code>) using <code>RPCUtils.encapsulate</code>. This follows a specific format that the server will understand (we'll cover this format in RPC Data Marshalling/Unmarshalling).</li> <li>Create Message: It wraps the <code>requestData</code> into a <code>Message</code> object. This is required by the underlying Messaging Connection layer.</li> <li>Send Message: It uses the <code>connection.send()</code> method (from the messaging layer) to transmit the <code>requestMessage</code> over the network to the server.</li> <li>Receive Reply: It calls <code>connection.receive()</code>. This method blocks \u2013 it waits until data arrives back from the server on the same connection. When data arrives, <code>receive()</code> returns it as a <code>Message</code> object (<code>replyMessage</code>).</li> <li>Decapsulate Reply: It extracts the payload data from the <code>replyMessage</code> using <code>replyMessage.getData()</code> and then uses <code>RPCUtils.decapsulate</code> to remove the RPC protocol framing, leaving just the marshalled return value (<code>returnval</code>) sent by the server. (Again, see RPC Data Marshalling/Unmarshalling).</li> <li>Return Result: It returns the <code>returnval</code> (the raw bytes of the result) back to the calling code (the <code>SensorStub</code>).</li> </ol>"},{"location":"oblig1/03_rpc_client_/#the-flow-from-stub-to-server-and-back","title":"The Flow: From Stub to Server and Back","text":"<p>Here's a diagram showing the RPC Client's role in the communication:</p> <pre><code>sequenceDiagram\n    participant Stub as SensorStub\n    participant RPC_Client as RPCClient\n    participant MsgConn as Messaging Connection\n    participant Network\n    participant RPC_Server as RPC Server (High Level)\n\n    Stub-&gt;&gt;RPC_Client: call(READ_RPCID, void_params)\n    Note over RPC_Client: Encapsulate(READ_RPCID, void_params) -&gt; request_bytes\n    RPC_Client-&gt;&gt;MsgConn: send(new Message(request_bytes))\n    Note over MsgConn: Send request_bytes over TCP socket\n    MsgConn-&gt;&gt;Network: Send request data\n    Network-&gt;&gt;RPC_Server: Request arrives\n    Note over RPC_Server: Server processes request (unpacks, calls SensorImpl.invoke, gets result)\n    Note over RPC_Server: Server encapsulates result -&gt; reply_bytes\n    RPC_Server-&gt;&gt;Network: Send reply data (reply_bytes)\n    Note over MsgConn: Receive reply_bytes via TCP socket\n    Network-&gt;&gt;MsgConn: Receive reply data\n    MsgConn--&gt;&gt;RPC_Client: return new Message(reply_bytes)\n    Note over RPC_Client: Decapsulate(reply_bytes) -&gt; result_bytes (temp)\n    RPC_Client--&gt;&gt;Stub: return result_bytes\nend</code></pre> <p>This shows the <code>RPCClient</code> acting as the middleman between the high-level <code>Stub</code> and the lower-level <code>Messaging Connection</code>. It packages the request, sends it, waits for the reply, and unpacks it.</p>"},{"location":"oblig1/03_rpc_client_/#conclusion","title":"Conclusion","text":"<p>The RPC Client is the engine that powers the client-side of our RPC system. It manages the network connection to a specific server and implements the core <code>call</code> method used by stubs. This <code>call</code> method handles the full cycle: packaging the request (encapsulation), sending it using the underlying Messaging Connection, waiting for the reply, and unpacking the result (decapsulation). It effectively hides the complexities of network communication from the RPC Client Stub, allowing the stub to focus on providing a simple, local-like interface for remote procedures.</p> <p>Now that we understand how the client side sends requests and receives replies, we need to look at the server component that listens for these incoming connections and dispatches the requests to the correct RPC Server Implementation (Skeleton).</p> <p>Next up: RPC Server</p>"},{"location":"oblig1/04_rpc_server_/","title":"Chapter 4: RPC Server","text":"<p>In the previous chapter, we saw how the RPC Client acts like a courier, taking a request from the RPC Client Stub (like \"get temperature\"), sending it across the network, and bringing back the response.</p> <p>But who is on the other side receiving these requests? When the <code>RPCClient</code> sends a message to the Sensor application's address, who is listening? And once the message arrives, how does the Sensor application know which piece of code (like the <code>read()</code> method in <code>SensorImpl</code>) should handle it?</p> <p>This is the job of the RPC Server.</p>"},{"location":"oblig1/04_rpc_server_/#whats-the-problem-receiving-and-directing-traffic","title":"What's the Problem? Receiving and Directing Traffic","text":"<p>Imagine our Sensor application. It has the <code>SensorImpl</code> object, which knows how to actually read the temperature (as discussed in RPC Server Implementation (Skeleton)). However, <code>SensorImpl</code> itself doesn't know anything about network connections or listening for incoming messages.</p> <p>We need a central component within the Sensor application that acts like a receptionist or a shop manager:</p> <ol> <li>Listens: Constantly waits for new clients (like the Controller's <code>RPCClient</code>) to connect.</li> <li>Receives Orders: Accepts incoming request messages sent by clients.</li> <li>Understands the Order: Looks at the request message to figure out which specific action the client wants (e.g., \"execute action #1\", which corresponds to <code>READ_RPCID</code>).</li> <li>Delegates: Finds the correct specialist (the <code>SensorImpl</code> object registered for <code>READ_RPCID</code>) to handle the request.</li> <li>Forwards Request: Gives the request details (parameters) to the specialist's <code>invoke</code> method.</li> <li>Collects Result: Gets the result (the temperature bytes) back from the specialist.</li> <li>Sends Back Reply: Packages the result into a reply message and sends it back to the client who made the request.</li> </ol> <p>This central receptionist is the RPC Server.</p>"},{"location":"oblig1/04_rpc_server_/#the-rpc-server-the-shop-manager","title":"The RPC Server: The Shop Manager","text":"<p>Think of the RPC Server like the manager of our remote Sensor \"shop\".</p> <ul> <li>The Shop Entrance: The RPC Server opens the shop doors (starts listening on a specific network port using the underlying Messaging Connection layer).</li> <li>Receiving Customers: When a customer (an <code>RPCClient</code>) arrives, the manager establishes a connection.</li> <li>Taking Orders: The customer hands over an order form (an RPC request message containing an ID like <code>READ_RPCID</code> and any parameters).</li> <li>Finding the Right Department: The manager looks at the order ID (<code>READ_RPCID</code>) and knows that the \"Temperature Reading Department\" (<code>SensorImpl</code> object) handles this.</li> <li>Dispatching: The manager takes the order details (parameters) to the <code>SensorImpl</code> department and asks it to process the order (calls its <code>invoke</code> method).</li> <li>Getting the Product: The <code>SensorImpl</code> department finishes its work and gives the packaged product (marshalled temperature bytes) back to the manager.</li> <li>Returning to Customer: The manager sends the product (the reply message) back to the waiting customer (<code>RPCClient</code>).</li> </ul> <p>The RPC Server orchestrates the entire process on the server side, ensuring requests are received, routed correctly, executed, and the results are returned.</p>"},{"location":"oblig1/04_rpc_server_/#how-the-rpc-server-works","title":"How the RPC Server Works","text":"<p>The <code>RPCServer</code> relies heavily on the lower-level Messaging Connection layer to handle the actual network communication (listening for connections, sending/receiving bytes). Its main job is to manage the RPC logic on top of that.</p> <p>1. Registration: Knowing Who Does What</p> <p>Before the server can handle any requests, it needs to know which \"specialist department\" (RPC Server Implementation (Skeleton)) handles which task (RPC ID). This happens through a <code>register</code> method.</p> <p>When the Sensor application starts, it creates the <code>SensorImpl</code> object. The <code>SensorImpl</code> constructor calls the <code>RPCServer</code>'s <code>register</code> method.</p> <pre><code>// Inside SensorDevice.java (Simplified Startup)\npublic static void main(String[] args) {\n    // Create the main RPC Server listening on the Sensor port\n    RPCServer sensorserver = new RPCServer(Common.SENSORPORT);\n\n    // Create the SensorImpl specialist. Its constructor will register it.\n    // It tells the server: \"I handle requests with ID = READ_RPCID\"\n    SensorImpl sensor = new SensorImpl((byte)Common.READ_RPCID, sensorserver);\n\n    // Start the server's main loop\n    sensorserver.run();\n    // ... stop server ...\n}\n</code></pre> <p>Let's look at the <code>RPCServer</code>'s <code>register</code> method and how it stores this information:</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCServer.java (Partial)\npackage no.hvl.dat110.rpc;\n\nimport java.util.HashMap;\nimport no.hvl.dat110.messaging.*; // Import messaging classes\n\npublic class RPCServer {\n\n    private MessagingServer msgserver; // From the Messaging Layer\n    private MessageConnection connection; // Represents a client connection\n\n    // A map to store the registered specialists (Skeletons)\n    // Key: RPC ID (byte), Value: The Skeleton object (RPCRemoteImpl)\n    private HashMap&lt;Byte, RPCRemoteImpl&gt; services;\n\n    // Constructor: Creates the underlying messaging server and the map\n    public RPCServer(int port) {\n        this.msgserver = new MessagingServer(port); // Setup listener\n        this.services = new HashMap&lt;Byte, RPCRemoteImpl&gt;(); // Prepare the registry\n    }\n\n    // Called by Skeletons (like SensorImpl) to register themselves\n    public void register(byte rpcid, RPCRemoteImpl impl) {\n        System.out.println(\"Registering service: RPC ID = \" + rpcid);\n        services.put(rpcid, impl); // Store: ID -&gt; Specialist Object\n    }\n\n    // ... run method is next ...\n    // ... stop method ...\n}\n</code></pre> <ul> <li>The <code>RPCServer</code> keeps a <code>HashMap</code> called <code>services</code>. Think of this map as the manager's directory.</li> <li>The <code>register</code> method takes the <code>rpcid</code> (like <code>Common.READ_RPCID</code>) and the actual specialist object (<code>impl</code>, which is the <code>SensorImpl</code> instance) and puts them into the <code>services</code> map. Now, the server knows that requests for <code>READ_RPCID</code> should go to that specific <code>SensorImpl</code> object.</li> </ul> <p>2. Running the Server: The Main Loop</p> <p>The <code>run()</code> method is where the RPC Server starts its main job of listening and processing requests.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCServer.java (Simplified run method)\npublic class RPCServer {\n    // ... constructor, register, services map, msgserver ...\n\n    public void run() {\n        // Special case: Register the built-in \"stop\" service (RPC ID 0)\n        RPCRemoteImpl rpcstop = new RPCServerStopImpl(RPCCommon.RPIDSTOP, this);\n\n        System.out.println(\"RPC SERVER starting to listen...\");\n\n        // 1. Wait for a client to connect (using the messaging layer)\n        connection = msgserver.accept(); // Blocks until a client connects\n        System.out.println(\"RPC SERVER accepted connection\");\n\n        boolean stop = false; // Flag to control the loop\n        while (!stop) {\n            Message requestmsg = null;\n            byte rpcid = 0;\n\n            try {\n                // 2. Receive a request message from the connected client\n                requestmsg = connection.receive(); // Blocks until message arrives\n\n                // 3. Extract the RPC ID (the first byte of the message data)\n                byte[] requestData = requestmsg.getData();\n                rpcid = requestData[0]; // Peek at the first byte for the ID\n\n                // 4. Decapsulate: Get the parameters (remove the ID byte)\n                // (Details in RPC Data Marshalling/Unmarshalling chapter)\n                byte[] params = RPCUtils.decapsulate(requestData);\n\n                // 5. Lookup: Find the specialist for this RPC ID\n                RPCRemoteImpl specialist = services.get(rpcid);\n\n                // 6. Invoke: Ask the specialist to handle the request\n                byte[] result = specialist.invoke(params); // The specialist does the real work!\n\n                // 7. Encapsulate: Package the result with the RPC ID\n                // (Details in RPC Data Marshalling/Unmarshalling chapter)\n                byte[] replyData = RPCUtils.encapsulate(rpcid, result);\n\n                // 8. Send Reply: Send the result back to the client\n                Message replymsg = new Message(replyData);\n                connection.send(replymsg);\n\n            } catch (Exception e) {\n                System.err.println(\"RPC Server Error: \" + e.getMessage());\n                e.printStackTrace();\n                stop = true; // Stop on error\n            }\n\n            // Check if the received RPC ID was the special \"stop\" command\n            if (rpcid == RPCCommon.RPIDSTOP) {\n                System.out.println(\"RPC SERVER received stop command.\");\n                stop = true;\n            }\n        }\n    }\n    // ... stop method ...\n}\n</code></pre> <p>Let's break down the <code>run()</code> loop:</p> <ol> <li>Accept Connection: <code>msgserver.accept()</code> tells the underlying Messaging Connection layer to wait for a client to connect. This call blocks (pauses) until a connection is made. The resulting <code>connection</code> object represents the communication link to that specific client.</li> <li>Receive Request: Inside the <code>while</code> loop, <code>connection.receive()</code> waits for a message to arrive from the connected client. This also blocks. When a message arrives, it's stored in <code>requestmsg</code>.</li> <li>Extract RPC ID: The first byte of the data within the message (<code>requestmsg.getData()</code>) is assumed to be the <code>rpcid</code> identifying the desired remote procedure.</li> <li>Decapsulate Parameters: <code>RPCUtils.decapsulate()</code> takes the raw message data and extracts the actual parameters meant for the remote method, removing the <code>rpcid</code> byte. (We'll cover <code>decapsulate</code> in the RPC Data Marshalling/Unmarshalling chapter).</li> <li>Lookup Specialist: <code>services.get(rpcid)</code> uses the extracted <code>rpcid</code> to look up the corresponding specialist object (e.g., the <code>SensorImpl</code> instance) in the <code>services</code> map we filled during registration.</li> <li>Invoke Specialist: The crucial step! <code>specialist.invoke(params)</code> calls the <code>invoke</code> method on the found specialist object (e.g., <code>SensorImpl.invoke(...)</code>), passing the extracted parameters. This is where the skeleton unmarshalls the parameters, calls the real application logic (<code>SensorImpl.read()</code>), gets the result, marshalls it, and returns the marshalled result bytes.</li> <li>Encapsulate Reply: <code>RPCUtils.encapsulate()</code> takes the result bytes returned by <code>invoke</code> and packages them back into the standard RPC message format, adding the original <code>rpcid</code> back. (Covered in RPC Data Marshalling/Unmarshalling).</li> <li>Send Reply: A new <code>Message</code> is created with the encapsulated reply data, and <code>connection.send()</code> sends it back to the client over the network.</li> <li>Stop Condition: The loop continues receiving and processing requests until the special <code>RPIDSTOP</code> command (RPC ID 0) is received, which sets the <code>stop</code> flag to <code>true</code> and ends the loop.</li> </ol>"},{"location":"oblig1/04_rpc_server_/#the-big-picture-request-flow","title":"The Big Picture: Request Flow","text":"<p>Here's a diagram showing the RPC Server's role in handling a <code>read()</code> request:</p> <pre><code>sequenceDiagram\n    participant Client as RPC Client (Controller)\n    participant Network\n    participant MsgServer as MessagingServer (Sensor)\n    participant RpcSrv as RPC Server (Sensor)\n    participant Skeleton as SensorImpl (Sensor)\n\n    Client-&gt;&gt;Network: Send Request (ID=READ_RPCID, void_params)\n    Network-&gt;&gt;MsgServer: Data arrives on listening socket\n    MsgServer-&gt;&gt;RpcSrv: accept() returns connection\n    Note over RpcSrv: Starts run() loop\n    MsgServer-&gt;&gt;RpcSrv: receive() returns Message(requestData)\n    Note over RpcSrv: Extracts ID=READ_RPCID\n    Note over RpcSrv: Decapsulates void_params\n    Note over RpcSrv: Looks up ID -&gt; finds SensorImpl\n    RpcSrv-&gt;&gt;Skeleton: invoke(void_params)\n    Note over Skeleton: Unmarshalls, calls read(), Marshalls result\n    Skeleton--&gt;&gt;RpcSrv: return temp_bytes\n    Note over RpcSrv: Encapsulates temp_bytes with ID\n    RpcSrv-&gt;&gt;MsgServer: send(Message(replyData))\n    MsgServer-&gt;&gt;Network: Send reply data\n    Network-&gt;&gt;Client: Receive Reply (temp_bytes)\nend</code></pre> <p>The <code>RPCServer</code> acts as the central dispatcher, taking incoming network messages facilitated by the <code>MessagingServer</code>, understanding the RPC request within, delegating the work to the correct <code>Skeleton</code>, and ensuring the reply gets sent back.</p>"},{"location":"oblig1/04_rpc_server_/#conclusion","title":"Conclusion","text":"<p>The RPC Server is the heart of the server-side RPC mechanism. It listens for incoming client connections using the underlying Messaging Connection layer. For each connected client, it enters a loop where it receives request messages, identifies the target procedure using the RPC ID, looks up the registered RPC Server Implementation (Skeleton), calls its <code>invoke</code> method, and sends the marshalled result back in a reply message. It's the essential coordinator that makes remote procedure calls possible from the server's perspective.</p> <p>We've seen how the RPC Client and Server use <code>encapsulate</code> and <code>decapsulate</code>, and how Stubs and Skeletons use <code>marshall</code> and <code>unmarshall</code>. But what do these functions actually do? How is data like integers, strings, or even \"nothing\" (void) converted into bytes and back again? That's the topic of our next chapter.</p> <p>Next up: RPC Data Marshalling/Unmarshalling</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/","title":"Chapter 5: RPC Data Marshalling/Unmarshalling","text":"<p>In the previous chapter, we saw how the RPC Server acts as the central receptionist on the server side, receiving requests and dispatching them to the correct specialist (like <code>SensorImpl</code>). We noticed that both the RPC Client and RPC Server, as well as the Stubs and Skeletons, frequently use helper functions from <code>RPCUtils</code> like <code>marshallInteger</code>, <code>unmarshallString</code>, <code>encapsulate</code>, and <code>decapsulate</code>.</p> <p>But what do these functions actually do? When the <code>SensorStub</code> wants to send a request to read the temperature, it doesn't need any parameters. It calls <code>RPCUtils.marshallVoid()</code>. When it gets the response, it calls <code>RPCUtils.unmarshallInteger()</code> to get the temperature value. How does Java data like an <code>int</code> or even \"nothing\" (void) get turned into bytes that can be sent over the network, and how are bytes turned back into useful Java data?</p> <p>This process of converting data between its friendly Java form and a network-friendly byte form is called Marshalling and Unmarshalling.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#what-is-marshallingunmarshalling-its-like-packing-boxes","title":"What is Marshalling/Unmarshalling? It's Like Packing Boxes!","text":"<p>Imagine you want to send a fragile vase (your Java data, like an <code>int</code> or a <code>String</code>) through the mail (the network). You can't just slap a stamp on the vase and hope for the best!</p> <ol> <li>Marshalling (Packing): You need to carefully wrap the vase in bubble wrap and put it into a standard-sized cardboard box (a <code>byte[]</code> array). This process of converting your specific item (Java data) into a standardized package (byte array) suitable for shipping is marshalling.</li> <li>Unmarshalling (Unpacking): When the box arrives at its destination, the recipient opens the box and carefully unwraps the bubble wrap to get the original vase back. This process of converting the standardized package (byte array) back into the specific item (Java data) is unmarshalling.</li> </ol> <p>So, in our RPC world: *   Marshalling: Converts Java data types (like <code>int</code>, <code>String</code>, <code>boolean</code>, or even <code>void</code>) into a sequence of bytes (<code>byte[]</code>). *   Unmarshalling: Converts a sequence of bytes (<code>byte[]</code>) back into the original Java data type.</p> <p>This is essential because networks primarily understand how to send and receive streams of raw bytes, not complex Java objects directly.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#marshallingunmarshalling-specific-data-types-rpcutils","title":"Marshalling/Unmarshalling Specific Data Types (<code>RPCUtils</code>)","text":"<p>The <code>RPCUtils.java</code> class provides helper functions to pack (marshall) and unpack (unmarshall) the specific data types we support in our simple RPC system: <code>int</code>, <code>String</code>, <code>boolean</code>, and <code>void</code>.</p> <p>Let's look at a couple of examples:</p> <p>Integers:</p> <p>An integer (<code>int</code>) in Java usually takes up 4 bytes of memory. Marshalling converts this 4-byte representation into a <code>byte[]</code> array of length 4. Unmarshalling does the reverse.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Integer Marshalling)\n\nimport java.nio.ByteBuffer; // Used for easy conversion\n\npublic class RPCUtils {\n\n    // integer to byte array representation\n    public static byte[] marshallInteger(int x) {\n        // Create a buffer that can hold exactly 4 bytes (size of an int)\n        ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);\n        // Put the integer into the buffer\n        buffer.putInt(x);\n        // Get the underlying byte array from the buffer\n        byte[] encoded = buffer.array();\n        return encoded;\n    }\n\n    // byte array representation to integer\n    public static int unmarshallInteger(byte[] data) {\n        // Wrap the incoming byte array into a buffer\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        // Read an integer from the buffer\n        int decoded = buffer.getInt();\n        return decoded;\n    }\n    // ... other marshall/unmarshall methods ...\n}\n</code></pre> *   <code>marshallInteger</code>: Uses Java's <code>ByteBuffer</code> to easily convert the <code>int</code> into a 4-byte array. *   <code>unmarshallInteger</code>: Uses <code>ByteBuffer</code> again to read 4 bytes from the input <code>data</code> array and interpret them as an <code>int</code>.</p> <p>Strings:</p> <p>Strings are sequences of characters. Marshalling converts the string into a byte array using a standard character encoding (like UTF-8). Unmarshalling converts the byte array back into a string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified String Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    // convert String to byte array\n    public static byte[] marshallString(String str) {\n        // Use the built-in String method to get bytes (usually UTF-8)\n        byte[] encoded = str.getBytes();\n        return encoded;\n    }\n\n    // convert byte array to a String\n    public static String unmarshallString(byte[] data) {\n        // Use the String constructor that takes bytes\n        String decoded = new String(data);\n        return decoded;\n    }\n    // ... other methods ...\n}\n</code></pre> *   <code>marshallString</code>: Simply uses the <code>getBytes()</code> method available on all Java strings. *   <code>unmarshallString</code>: Uses the <code>String</code> constructor that accepts a byte array.</p> <p>Void (Nothing):</p> <p>Sometimes, a remote method doesn't need any parameters (like <code>read()</code>) or doesn't return anything (like <code>write()</code>). How do we marshall \"nothing\"? We represent it as an empty byte array (<code>new byte[0]</code>).</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Void Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    public static byte[] marshallVoid() {\n        // Return an array with zero bytes\n        return new byte[0];\n    }\n\n    public static void unmarshallVoid(byte[] data) {\n        // Just check that the received data is indeed empty\n        if (data.length != 0) {\n            throw new IllegalArgumentException(\"Expected void (empty data), but received data.\");\n        }\n        // No value to return!\n    }\n    // ... other methods ...\n}\n</code></pre> *   <code>marshallVoid</code>: Creates and returns a zero-length byte array. *   <code>unmarshallVoid</code>: Doesn't return anything, but it checks if the received byte array is empty, throwing an error if it's not.</p> <p>Booleans:</p> <p>A boolean (<code>true</code> or <code>false</code>) can be represented by a single byte. For example, <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Boolean Marshalling)\n\npublic class RPCUtils {\n    // ... other methods ...\n\n    // convert boolean to a byte array representation\n    public static byte[] marshallBoolean(boolean b) {\n        byte[] encoded = new byte[1];\n        encoded[0] = (b ? (byte)1 : (byte)0); // 1 if true, 0 if false\n        return encoded;\n    }\n\n    // convert byte array to a boolean representation\n    public static boolean unmarshallBoolean(byte[] data) {\n        // True if the byte is not 0\n        return (data[0] != 0);\n    }\n    // ... other methods ...\n}\n</code></pre> <p>These marshalling/unmarshalling functions are used by the RPC Client Stub and the RPC Server Implementation (Skeleton) to prepare parameters and interpret return values.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#rpc-message-structure-encapsulationdecapsulation","title":"RPC Message Structure: Encapsulation/Decapsulation","text":"<p>Okay, so we know how to pack the \"vase\" (our data like an <code>int</code>) into a box (<code>byte[]</code>). But when we send this box over the network, the receiver needs to know what this box is for. Is it the result of a <code>read</code> call? Is it the parameter for a <code>write</code> call?</p> <p>The raw marshalled data (like the 4 bytes for an integer) isn't enough. We need to add a label to the box: the RPC ID. This ID tells the server which remote method the message relates to (e.g., <code>Common.READ_RPCID</code> or <code>Common.WRITE_RPCID</code>).</p> <p>Encapsulation (Adding the Label): Before sending the message, the RPC Client (or the RPC Server sending a reply) needs to combine the RPC ID and the marshalled data (payload) into a single byte array. This is encapsulation. Our format is simple: the first byte is the RPC ID, and the rest of the bytes are the marshalled payload.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Encapsulation)\n\npublic class RPCUtils {\n    // ... marshall/unmarshall methods ...\n\n    public static byte[] encapsulate(byte rpcid, byte[] payload) {\n        // Create a new array large enough for the ID (1 byte) + payload\n        byte[] rpcmsg = new byte[1 + payload.length];\n\n        // Put the RPC ID in the first position\n        rpcmsg[0] = rpcid;\n\n        // Copy the payload bytes into the rest of the array\n        System.arraycopy(payload, 0, rpcmsg, 1, payload.length);\n\n        return rpcmsg;\n    }\n    // ... decapsulate method ...\n}\n</code></pre> *   <code>encapsulate</code>: Creates a new byte array one byte larger than the <code>payload</code>. It puts the <code>rpcid</code> at the beginning and copies the <code>payload</code> bytes immediately after it.</p> <p>Decapsulation (Reading the Label and Opening the Box): When the RPC Server (or RPC Client receiving a reply) receives a message, it needs to perform the reverse: extract the RPC ID and the marshalled payload. This is decapsulation.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/rpc/RPCUtils.java (Simplified Decapsulation)\n\nimport java.util.Arrays; // Used for easy array copying\n\npublic class RPCUtils {\n    // ... marshall/unmarshall/encapsulate methods ...\n\n    public static byte[] decapsulate(byte[] rpcmsg) {\n        // Check if the message is valid (must have at least the ID byte)\n        if (rpcmsg == null || rpcmsg.length &lt; 1) {\n            throw new IllegalArgumentException(\"Invalid RPC message for decapsulation\");\n        }\n\n        // The payload is everything *except* the first byte (the RPC ID)\n        byte[] payload = Arrays.copyOfRange(rpcmsg, 1, rpcmsg.length);\n\n        return payload;\n        // Note: The caller needs to get the RPC ID separately (rpcmsg[0])\n        // before calling decapsulate.\n    }\n}\n</code></pre> *   <code>decapsulate</code>: Takes the full received message (<code>rpcmsg</code>). It extracts and returns a new byte array containing everything from the second byte onwards (the payload). The code that calls <code>decapsulate</code> (like in <code>RPCServer.run()</code> or <code>RPCClient.call()</code>) is responsible for looking at the first byte (<code>rpcmsg[0]</code>) separately to get the RPC ID.</p> <p>Here's what the encapsulated message looks like:</p> <pre><code>[ RPC ID (1 byte) | Marshalled Parameter/Result Bytes (Payload) ]\n</code></pre>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#putting-it-all-together-the-data-flow","title":"Putting It All Together: The Data Flow","text":"<p>Let's trace how data is transformed during a <code>sensor.read()</code> call:</p> <pre><code>sequenceDiagram\n    participant Stub as SensorStub\n    participant RPCClient\n    participant Network\n    participant RPCServer\n    participant Skeleton as SensorImpl\n\n    Note over Stub: Wants to call read(). No parameters.\n    Stub-&gt;&gt;Stub: Calls RPCUtils.marshallVoid() -&gt; gets empty byte[] (param_bytes)\n    Stub-&gt;&gt;RPCClient: call(READ_RPCID, param_bytes)\n    Note over RPCClient: Needs to send message.\n    RPCClient-&gt;&gt;RPCClient: Calls RPCUtils.encapsulate(READ_RPCID, param_bytes) -&gt; gets [READ_RPCID] (msg_bytes)\n    RPCClient-&gt;&gt;Network: Sends msg_bytes\n    Network-&gt;&gt;RPCServer: Receives msg_bytes ([READ_RPCID])\n    Note over RPCServer: Needs to process message.\n    RPCServer-&gt;&gt;RPCServer: Extracts ID = msg_bytes[0] (READ_RPCID)\n    RPCServer-&gt;&gt;RPCServer: Calls RPCUtils.decapsulate(msg_bytes) -&gt; gets empty byte[] (param_bytes')\n    RPCServer-&gt;&gt;Skeleton: invoke(param_bytes')\n    Note over Skeleton: Needs parameters.\n    Skeleton-&gt;&gt;Skeleton: Calls RPCUtils.unmarshallVoid(param_bytes') -&gt; Checks it's empty. OK.\n    Skeleton-&gt;&gt;Skeleton: Calls internal read() -&gt; gets temperature (e.g., 17)\n    Note over Skeleton: Needs to return result.\n    Skeleton-&gt;&gt;Skeleton: Calls RPCUtils.marshallInteger(17) -&gt; gets 4 bytes for 17 (result_bytes)\n    Skeleton--&gt;&gt;RPCServer: Returns result_bytes\n    Note over RPCServer: Needs to send reply.\n    RPCServer-&gt;&gt;RPCServer: Calls RPCUtils.encapsulate(READ_RPCID, result_bytes) -&gt; gets [READ_RPCID | 4 bytes for 17] (reply_bytes)\n    RPCServer-&gt;&gt;Network: Sends reply_bytes\n    Network-&gt;&gt;RPCClient: Receives reply_bytes\n    Note over RPCClient: Needs to process reply.\n    RPCClient-&gt;&gt;RPCClient: Calls RPCUtils.decapsulate(reply_bytes) -&gt; gets 4 bytes for 17 (result_bytes')\n    RPCClient--&gt;&gt;Stub: Returns result_bytes'\n    Note over Stub: Needs result value.\n    Stub-&gt;&gt;Stub: Calls RPCUtils.unmarshallInteger(result_bytes') -&gt; gets 17\n    Stub--&gt;&gt;Controller: Returns 17\nend</code></pre> <p>This diagram shows the journey: 1.  Stub marshalls parameters. 2.  RPCClient encapsulates the ID and marshalled parameters. 3.  RPCServer decapsulates the received message to get the ID and marshalled parameters. 4.  Skeleton unmarshalls the parameters to use them. 5.  Skeleton marshalls the result. 6.  RPCServer encapsulates the ID and marshalled result for the reply. 7.  RPCClient decapsulates the reply to get the marshalled result. 8.  Stub unmarshalls the result to return it to the caller.</p>"},{"location":"oblig1/05_rpc_data_marshalling_unmarshalling_/#conclusion","title":"Conclusion","text":"<p>Marshalling/Unmarshalling is the crucial process of converting Java data into byte arrays for network travel and back again, like packing and unpacking a box. Encapsulation/Decapsulation is the process of adding (and removing) the necessary RPC ID label to this box so the receiver knows what the message is for.</p> <p>The <code>RPCUtils</code> class provides the tools for both: *   <code>marshallX</code>/<code>unmarshallX</code> methods for packing/unpacking specific data types (used by Stubs and Skeletons). *   <code>encapsulate</code>/<code>decapsulate</code> methods for adding/removing the RPC ID label to the packed data (used by RPC Client and RPC Server).</p> <p>Without these steps, our RPC components wouldn't be able to exchange meaningful information over the network.</p> <p>Now that we understand how data is prepared for sending, how is it actually sent and received as a reliable message? That's the job of the layer below RPC: the Messaging Layer.</p> <p>Next up: Messaging Connection</p>"},{"location":"oblig1/06_messaging_connection_/","title":"Chapter 6: Messaging Connection","text":"<p>Welcome to Chapter 6! In the previous chapter, we learned how to pack our Java data (like integers or strings) into boxes of bytes (<code>byte[]</code>) using marshalling, and how to label those boxes with an RPC ID using encapsulation. We have our neatly packaged request (like \"get temperature\") ready to go!</p> <p>But how does this box of bytes actually get from our program (the client) to the other program (the server) across the unpredictable network? How do we make sure the whole box arrives, and not just parts of it? And how does the receiver know when one box ends and the next one begins if we send multiple boxes?</p> <p>Dealing directly with raw network connections (called sockets) involves managing streams of bytes, handling potential errors, and figuring out message boundaries. This can be quite tricky, especially for beginners. We need a simpler, more reliable way to just \"send this message\" and \"receive the next message\".</p>"},{"location":"oblig1/06_messaging_connection_/#the-problem-sending-bytes-reliably","title":"The Problem: Sending Bytes Reliably","text":"<p>Imagine you have your packed box (<code>byte[]</code>) containing the RPC request. You want to send it to the server. Sending it over the network is like sending raw data down a pipe.</p> <ul> <li>How does the receiver know exactly how many bytes belong to this specific box? If you send two boxes back-to-back, the receiver might just see a continuous stream of bytes.</li> <li>What if the network is slow or temporarily interrupted? How do you ensure the complete message is sent and received?</li> </ul> <p>We need a layer that handles these details for us.</p>"},{"location":"oblig1/06_messaging_connection_/#introducing-the-messaging-connection-your-reliable-network-postman","title":"Introducing the Messaging Connection: Your Reliable Network Postman","text":"<p>This is where the Messaging Connection layer comes in. Think of it as a super reliable postal service designed specifically for sending our pre-packaged <code>Message</code> objects.</p> <ul> <li>You (RPC Client/Server): Prepare your message (the <code>byte[]</code> from marshalling/encapsulation) and put it inside a standard envelope \u2013 the <code>Message</code> object.</li> <li>Messaging Connection (Postal Service): You give this <code>Message</code> envelope to the <code>MessageConnection</code>. It takes care of:<ul> <li>Knowing the recipient's address (established via TCP socket).</li> <li>Adding special markings (framing information, covered in the next chapter) so the receiver knows exactly how big the message is.</li> <li>Using a reliable delivery method (TCP) to ensure the bytes arrive in order.</li> <li>Delivering one whole message at a time.</li> <li>Receiving one whole message at a time.</li> </ul> </li> </ul> <p>So, the Messaging Connection:</p> <ol> <li>Represents the Channel: It's the established communication link (a TCP socket) between a client and a server.</li> <li>Abstracts Streams: It hides the raw <code>InputStream</code> and <code>OutputStream</code> of the socket.</li> <li>Deals in Messages: It provides methods to <code>send</code> and <code>receive</code> complete <code>Message</code> objects, not just loose bytes.</li> </ol> <p>This makes network communication much cleaner for the layers above it (like the RPC Client and RPC Server).</p>"},{"location":"oblig1/06_messaging_connection_/#key-components-of-the-messaging-layer","title":"Key Components of the Messaging Layer","text":"<p>This \"postal service\" has a few key parts working together:</p> <ol> <li> <p><code>Message</code> Class: The standard envelope. It's a simple object that holds the data (<code>byte[]</code>) you want to send.</p> <p><pre><code>// Simplified representation\npackage no.hvl.dat110.messaging;\n\npublic class Message {\n    private byte[] data; // The payload (your packed bytes)\n\n    public Message(byte[] data) {\n        this.data = data;\n    }\n\n    public byte[] getData() {\n        return data;\n    }\n}\n</code></pre> This class just acts as a wrapper around the byte array we want to transmit.</p> </li> <li> <p><code>MessageConnection</code> Class: Represents an active, established connection between two points. Once connected, you use this object to send and receive <code>Message</code> envelopes. It's like having a direct phone line open.</p> <p><pre><code>// Simplified representation\npackage no.hvl.dat110.messaging;\n\nimport java.net.Socket;\n// ... other imports ...\n\npublic class MessageConnection {\n    private Socket socket; // The underlying network connection\n    // ... Input/Output streams needed for sending/receiving ...\n\n    public MessageConnection(Socket socket) {\n        this.socket = socket;\n        // ... setup input/output streams from socket ...\n    }\n\n    public void send(Message message) {\n        // ... magic happens here to send the message reliably ...\n        // (Uses MessageUtils.encapsulate)\n    }\n\n    public Message receive() {\n        // ... magic happens here to receive one complete message ...\n        // (Uses MessageUtils.decapsulate)\n        Message receivedMessage = null;\n        // ... read from socket, figure out message boundaries ...\n        return receivedMessage;\n    }\n\n    public void close() {\n        // ... close streams and the socket ...\n    }\n}\n</code></pre> The <code>send</code> and <code>receive</code> methods are the core here. They handle the details of transmitting <code>Message</code> objects over the underlying <code>socket</code>.</p> </li> <li> <p><code>MessagingClient</code> Class: Used by the client application (like the <code>Controller</code>) to initiate a connection to a server. It's like dialing the server's phone number.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessagingClient.java (Simplified)\npackage no.hvl.dat110.messaging;\n\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class MessagingClient {\n    private String server;\n    private int port;\n\n    public MessagingClient(String server, int port) {\n        this.server = server;\n        this.port = port;\n    }\n\n    // Connect to the server and return the established connection\n    public MessageConnection connect() {\n        try {\n            // Create a TCP socket connection to the server address/port\n            Socket clientSocket = new Socket(server, port);\n            // Wrap the socket in our MessageConnection object\n            return new MessageConnection(clientSocket);\n        } catch (IOException e) {\n            System.err.println(\"Error connecting to server: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre> Its main job is the <code>connect()</code> method, which creates the network <code>Socket</code> and returns the usable <code>MessageConnection</code>.</p> </li> <li> <p><code>MessagingServer</code> Class: Used by the server application (like the <code>Sensor</code>) to listen for incoming connection attempts from clients. It's like the operator waiting for the phone to ring.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessagingServer.java (Simplified)\npackage no.hvl.dat110.messaging;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class MessagingServer {\n    private ServerSocket welcomeSocket; // Listens for connections\n\n    public MessagingServer(int port) {\n        try {\n            // Create a socket that listens on the specified port\n            this.welcomeSocket = new ServerSocket(port);\n        } catch (IOException e) {\n             System.err.println(\"Error starting server: \" + e.getMessage());\n             throw new RuntimeException(e);\n        }\n    }\n\n    // Wait for a client to connect, then return the connection\n    public MessageConnection accept() {\n        try {\n            System.out.println(\"MessagingServer waiting for connection...\");\n            // Wait here until a client tries to connect\n            Socket connectionSocket = welcomeSocket.accept();\n            System.out.println(\"MessagingServer accepted connection.\");\n            // Wrap the new client socket in a MessageConnection\n            return new MessageConnection(connectionSocket);\n        } catch (IOException e) {\n            System.err.println(\"Error accepting connection: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void stop() { /* ... close welcomeSocket ... */ }\n}\n</code></pre> Its main job is the <code>accept()</code> method, which blocks (waits) until a client connects, then returns a <code>MessageConnection</code> representing the link to that specific client.</p> </li> </ol>"},{"location":"oblig1/06_messaging_connection_/#how-the-rpc-layer-uses-the-messaging-layer","title":"How the RPC Layer Uses the Messaging Layer","text":"<p>Remember the RPC Client's <code>call</code> method?</p> <p><pre><code>// Inside RPCClient.call() (Simplified)\npublic byte[] call(byte rpcid, byte[] params) {\n    byte[] requestData = RPCUtils.encapsulate(rpcid, params);\n    Message requestMessage = new Message(requestData); // Create the envelope\n\n    // Use the Messaging Layer to send\n    connection.send(requestMessage); // Hand off to the \"postman\"\n\n    // Use the Messaging Layer to receive\n    Message replyMessage = connection.receive(); // Wait for the return mail\n\n    byte[] returnval = RPCUtils.decapsulate(replyMessage.getData());\n    return returnval;\n}\n</code></pre> And the RPC Server's <code>run</code> loop?</p> <p><pre><code>// Inside RPCServer.run() (Simplified loop)\npublic void run() {\n    connection = msgserver.accept(); // Wait for a client connection\n\n    while (!stop) {\n        // Use Messaging Layer to receive request\n        Message requestmsg = connection.receive();\n\n        // ... process request (decapsulate, lookup, invoke) ...\n        byte[] result = specialist.invoke(params);\n        byte[] replyData = RPCUtils.encapsulate(rpcid, result);\n        Message replymsg = new Message(replyData); // Create reply envelope\n\n        // Use Messaging Layer to send reply\n        connection.send(replymsg);\n\n        // ... check for stop condition ...\n    }\n}\n</code></pre> Notice how the RPC layer only deals with <code>Message</code> objects and the <code>send</code>/<code>receive</code> methods of the <code>MessageConnection</code>. It doesn't worry about sockets or byte streams directly. The <code>MessagingClient</code> and <code>MessagingServer</code> handle the initial setup (<code>connect</code>/<code>accept</code>).</p>"},{"location":"oblig1/06_messaging_connection_/#under-the-hood-sockets-and-message-boundaries","title":"Under the Hood: Sockets and Message Boundaries","text":"<p>So how does <code>MessageConnection</code> actually achieve this \"send one message, receive one message\" magic?</p> <ol> <li>TCP Sockets: Underneath, <code>MessageConnection</code> uses standard Java <code>Socket</code> objects. TCP (Transmission Control Protocol) provides a reliable, ordered stream of bytes between the client and server. This means bytes sent arrive in the same order, and TCP handles retransmitting lost data. However, TCP itself doesn't know about message boundaries \u2013 it just sees a stream.</li> <li>Input/Output Streams: The <code>MessageConnection</code> gets the <code>InputStream</code> and <code>OutputStream</code> from the <code>Socket</code>. It typically wraps these in <code>DataInputStream</code> and <code>DataOutputStream</code> which provide helpful methods for reading and writing primitive Java types and byte arrays.</li> <li>Framing (The Secret Sauce!): This is the crucial part. Before writing the <code>Message</code>'s payload bytes to the <code>OutputStream</code>, the <code>send</code> method uses a helper function (from <code>MessageUtils</code>, covered in the next chapter) to add framing information. The simplest form of framing is adding the length of the payload before the payload itself.</li> <li>Sending: The <code>send</code> method writes the framing information (e.g., the length) followed by the actual payload bytes to the <code>DataOutputStream</code>.</li> <li>Receiving: The <code>receive</code> method uses another helper function (from <code>MessageUtils</code>) that first reads the framing information (e.g., the length) from the <code>DataInputStream</code>. Once it knows the length, it reads exactly that many bytes from the stream \u2013 this is the payload.</li> <li>Reconstructing the Message: It takes the received payload bytes and puts them into a new <code>Message</code> object, which is then returned.</li> </ol> <p>This process of adding and reading the length (or other boundary markers) is called the Message Framing Protocol.</p> <p>Here's a diagram showing the flow when <code>RPCClient</code> sends a message via <code>MessageConnection</code>:</p> <pre><code>sequenceDiagram\n    participant RPC_Client as RPC Client\n    participant MsgConn as MessageConnection\n    participant MsgUtils as MessageUtils\n    participant Stream as DataOutputStream\n    participant Network\n\n    RPC_Client-&gt;&gt;MsgConn: send(myMessage)\n    Note over MsgConn: Get payload bytes from myMessage\n    MsgConn-&gt;&gt;MsgUtils: encapsulate(payload_bytes)\n    Note over MsgUtils: Add framing (e.g., length) to payload\n    MsgUtils--&gt;&gt;MsgConn: return framed_bytes (length + payload)\n    MsgConn-&gt;&gt;Stream: write(framed_bytes)\n    Stream-&gt;&gt;Network: Send framed_bytes over TCP socket</code></pre> <p>And when the <code>RPCServer</code> receives it:</p> <pre><code>sequenceDiagram\n    participant Network\n    participant Stream as DataInputStream\n    participant MsgUtils as MessageUtils\n    participant MsgConn as MessageConnection\n    participant RPC_Server as RPC Server\n\n    Network-&gt;&gt;Stream: Receive framed_bytes (length + payload)\n    RPC_Server-&gt;&gt;MsgConn: receive()\n    MsgConn-&gt;&gt;MsgUtils: decapsulate(Stream)\n    Note over MsgUtils: Read length from Stream\n    Note over MsgUtils: Read 'length' bytes of payload from Stream\n    MsgUtils--&gt;&gt;MsgConn: return received_payload_bytes\n    MsgConn-&gt;&gt;MsgConn: Create newMessage(received_payload_bytes)\n    MsgConn--&gt;&gt;RPC_Server: return newMessage\nend</code></pre> <p>The <code>MessageUtils.encapsulate</code> and <code>MessageUtils.decapsulate</code> methods (which implement the framing protocol) are the key to making <code>MessageConnection.send</code> and <code>MessageConnection.receive</code> work with whole messages.</p>"},{"location":"oblig1/06_messaging_connection_/#conclusion","title":"Conclusion","text":"<p>The Messaging Connection layer provides a vital abstraction over raw network sockets. It establishes a connection (<code>MessagingClient</code>, <code>MessagingServer</code>) and allows the sending and receiving of discrete <code>Message</code> objects (<code>MessageConnection.send</code>, <code>MessageConnection.receive</code>).</p> <p>It hides the complexity of byte streams and error handling by leveraging TCP and, crucially, by implementing a framing protocol (via helper functions) to define message boundaries. This allows the higher-level RPC components to communicate reliably without getting bogged down in networking details. They simply work with <code>Message</code> objects.</p> <p>But how exactly does this framing work? How do we add the length information and read it back correctly? That's the topic of our final chapter.</p> <p>Next up: Message Framing Protocol</p>"},{"location":"oblig1/07_message_framing_protocol_/","title":"Chapter 7: Message Framing Protocol","text":"<p>Welcome to the final chapter! In the previous chapter, we explored the Messaging Connection layer. We saw how it acts like a reliable postal service, providing <code>send</code> and <code>receive</code> methods to exchange <code>Message</code> objects between a client and server. We briefly mentioned that there's some \"magic\" happening inside <code>send</code> and <code>receive</code> to make sure whole messages are sent and received correctly, even though the underlying network connection (TCP) just sees a continuous stream of bytes.</p> <p>It's time to reveal that magic! It's called the Message Framing Protocol.</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-problem-just-a-stream-of-bytes","title":"The Problem: Just a Stream of Bytes","text":"<p>Imagine you're reading a very long scroll of text that has no punctuation or spaces between words. It would be incredibly difficult to figure out where one word ends and the next begins, let alone understand the sentences!</p> <p>TCP network connections are a bit like that scroll. They provide a reliable stream of bytes from the sender to the receiver. If the sender sends \"HELLO\" (5 bytes) and then immediately sends \"WORLD\" (5 bytes), the receiver might just get a stream like \"HELLOWORLD\" (10 bytes). The receiver doesn't automatically know that this was originally two separate messages.</p> <p>Our Messaging Connection needs to send and receive distinct <code>Message</code> objects. If the RPC Client sends a request message, and then maybe another one later, the RPC Server needs to be able to receive the first message completely, process it, and then receive the second message completely. How can we add structure to this byte stream?</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-solution-message-framing-protocol-standard-envelopes","title":"The Solution: Message Framing Protocol - Standard Envelopes!","text":"<p>The solution is to agree on a set of rules \u2013 a protocol \u2013 for how messages are packaged, or framed, before being sent over the stream. This ensures the receiver can identify the boundaries of each message.</p> <p>Think of it like agreeing to always send letters using standard-sized envelopes. Even if you put multiple envelopes into the mailbag one after another, the recipient can easily pick out one envelope, open it, read the letter inside, and then pick out the next envelope.</p> <p>Our Message Framing Protocol defines the \"standard envelope\" for our system.</p> <p>Our Specific Protocol:</p> <p>In this project (<code>dat110-project1-gruppe69</code>), we use a simple framing protocol:</p> <ol> <li>Fixed-Size Segments: All data is sent in fixed-size chunks called segments. Each segment is exactly 128 bytes long.</li> <li>Length Header: The very first byte of each 128-byte segment is special. It acts as a header and tells the receiver the length of the actual payload data contained within that segment. This length can be anywhere from 0 to 127 bytes.</li> <li>Payload: The actual message data (the bytes from the <code>Message</code> object) follows the length byte.</li> <li>Padding: Since the segment must be 128 bytes, but the payload might be shorter (e.g., only 10 bytes), the remaining bytes in the segment after the payload are just padding. They are sent but ignored by the receiver.</li> </ol> <p>Here's what our 128-byte \"envelope\" (segment) looks like:</p> <pre><code>graph LR\n    A[Segment (128 bytes total)] --&gt; B(Byte 1: Length L);\n    A --&gt; C(Bytes 2 to L+1: Payload Data);\n    A --&gt; D(Bytes L+2 to 128: Padding);\n    subgraph Fixed Size Frame\n        direction LR\n        B --- C --- D;\n    end\n    style A fill:#f9f,stroke:#333,stroke-width:2px</code></pre> <ul> <li>The first byte tells us <code>L</code>, the length of the real data.</li> <li>The next <code>L</code> bytes are the actual payload we care about.</li> <li>The rest of the 128 bytes are just filler (padding).</li> </ul>"},{"location":"oblig1/07_message_framing_protocol_/#implementing-the-framing-messageutils","title":"Implementing the Framing: <code>MessageUtils</code>","text":"<p>The rules of our protocol are implemented in the helper methods of the <code>MessageUtils.java</code> class, specifically <code>encapsulate</code> and <code>decapsulate</code>. These are the methods used internally by <code>MessageConnection</code>'s <code>send</code> and <code>receive</code>.</p> <p>1. Packing the Envelope (<code>encapsulate</code>)</p> <p>When <code>MessageConnection.send(message)</code> is called, it needs to take the <code>message</code>'s data and put it into our standard 128-byte envelope format. It uses <code>MessageUtils.encapsulate</code> for this.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessageUtils.java (Encapsulate)\n\npublic class MessageUtils {\n\n    public static final int SEGMENTSIZE = 128; // Our fixed envelope size\n\n    // Takes the message payload and puts it into a 128-byte segment\n    public static byte[] encapsulate(Message message) {\n        byte[] data = message.getData(); // Get the raw payload bytes (0-127 bytes)\n        byte[] segment = new byte[SEGMENTSIZE]; // Create the 128-byte empty envelope\n\n        // Rule 1: Put the length of the payload in the first byte\n        segment[0] = (byte) data.length;\n\n        // Rule 2: Copy the payload data into the segment, starting from byte 1\n        System.arraycopy(data, 0, segment, 1, data.length);\n\n        // Rule 3: The rest of 'segment' is padding (already 0s)\n        return segment; // Return the filled 128-byte envelope\n    }\n\n    // ... decapsulate method ...\n}\n</code></pre> <p>Let's break it down: *   It gets the payload <code>data</code> from the <code>Message</code> object. Remember from <code>Message.java</code>, this <code>data</code> is guaranteed to be 127 bytes or less. *   It creates a brand new byte array called <code>segment</code> that is exactly 128 bytes long. *   <code>segment[0] = (byte) data.length;</code> This crucial step writes the length of the payload into the very first byte of the segment. *   <code>System.arraycopy(...)</code> copies the actual payload <code>data</code> into the <code>segment</code>, but it starts copying at index 1 (the second byte), leaving the first byte for the length. *   The method returns the 128-byte <code>segment</code>. This is what <code>MessageConnection</code> actually writes to the network stream.</p> <p>2. Unpacking the Envelope (<code>decapsulate</code>)</p> <p>When <code>MessageConnection.receive()</code> is called, it first reads exactly 128 bytes from the network stream (because it knows all messages arrive in 128-byte segments). It then needs to extract the actual payload from this 128-byte segment. It uses <code>MessageUtils.decapsulate</code> for this.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messaging/MessageUtils.java (Decapsulate)\n\nimport java.util.Arrays; // Used for array copying\n\npublic class MessageUtils {\n    // ... SEGMENTSIZE constant and encapsulate method ...\n\n    // Takes a 128-byte segment and extracts the original payload data\n    public static Message decapsulate(byte[] segment) {\n\n        // Basic checks for valid segment\n        if (segment == null || segment.length != SEGMENTSIZE) {\n           throw new IllegalArgumentException(\"Invalid segment received\");\n        }\n\n        // Rule 1: Read the payload length from the first byte\n        // (&amp; 0xFF ensures we treat the byte as unsigned, 0-255)\n        int length = segment[0] &amp; 0xFF;\n\n        // Sanity check: Length shouldn't exceed allowed payload size\n        if (length &gt; SEGMENTSIZE - 1) { // Max payload is 127\n             throw new IllegalArgumentException(\"Segment length field is too large\");\n        }\n\n        // Rule 2: Extract the payload data\n        // Create a new array of the correct size ('length')\n        byte[] data = new byte[length];\n        // Copy 'length' bytes from the segment, starting from byte 1\n        System.arraycopy(segment, 1, data, 0, length);\n\n        // Rule 3: The padding is ignored!\n\n        // Create and return a new Message containing only the extracted data\n        return new Message(data);\n    }\n}\n</code></pre> <p>Here's how it works: *   It receives the 128-byte <code>segment</code> that was read from the network. *   <code>int length = segment[0] &amp; 0xFF;</code> reads the first byte to figure out how long the actual payload is. (The <code>&amp; 0xFF</code> is a technical detail to handle Java's byte representation correctly). *   It creates a new byte array called <code>data</code> that is exactly <code>length</code> bytes long \u2013 just big enough for the payload. *   <code>System.arraycopy(...)</code> copies <code>length</code> bytes from the received <code>segment</code> (starting at index 1) into the new <code>data</code> array. *   Finally, it creates a new <code>Message</code> object using only the extracted <code>data</code> and returns it. This <code>Message</code> now contains only the original payload sent by the sender, with the framing and padding removed.</p>"},{"location":"oblig1/07_message_framing_protocol_/#the-whole-picture","title":"The Whole Picture","text":"<p>So, the Messaging Connection layer uses this framing protocol like this:</p> <ol> <li> <p>Sender (<code>MessageConnection.send</code>):</p> <ul> <li>Gets the <code>Message</code> object (containing payload from, say, RPC Data Marshalling/Unmarshalling).</li> <li>Calls <code>MessageUtils.encapsulate</code> to wrap the payload in a 128-byte segment with the length header.</li> <li>Writes the entire 128-byte segment to the TCP output stream.</li> </ul> </li> <li> <p>Receiver (<code>MessageConnection.receive</code>):</p> <ul> <li>Reads exactly 128 bytes from the TCP input stream (because it expects a segment).</li> <li>Calls <code>MessageUtils.decapsulate</code> on the received 128-byte segment.</li> <li><code>decapsulate</code> reads the length header, extracts the payload bytes, and ignores the padding.</li> <li><code>decapsulate</code> returns a new <code>Message</code> object containing only the original payload.</li> <li><code>receive</code> returns this payload-only <code>Message</code> object to the caller (e.g., the RPC Server).</li> </ul> </li> </ol> <p>This ensures that even though TCP is just a stream, the <code>MessageConnection</code> layer can reliably send and receive distinct messages because the Message Framing Protocol provides the necessary structure.</p>"},{"location":"oblig1/07_message_framing_protocol_/#conclusion","title":"Conclusion","text":"<p>The Message Framing Protocol is a fundamental concept in network programming. It defines the rules for how to structure data sent over a stream-based connection so that the receiver can distinguish individual messages. In our project, we use a simple fixed-size segment protocol: every message travels inside a 128-byte \"envelope,\" where the first byte declares the length of the actual content inside (0-127 bytes), and the rest is potential padding.</p> <p>The <code>MessageUtils.encapsulate</code> and <code>MessageUtils.decapsulate</code> methods implement this protocol, allowing our Messaging Connection layer to provide a clean <code>send(Message)</code> and <code>receive()</code> interface to the higher RPC layers.</p> <p>With this final piece, we've explored the entire stack, from the high-level convenience of RPC Stubs down to the details of packaging bytes for reliable network transmission. Congratulations on completing the tutorial for <code>dat110-project1-gruppe69</code>!</p>"},{"location":"oblig1/oblig1_index/","title":"Tutorial: dat110-project1-gruppe69","text":"<p>This project implements a simple Remote Procedure Call (RPC) system for an IoT application (Sensor, Controller, Display). It builds the RPC functionality on top of a custom messaging layer, which itself uses standard TCP sockets for network communication. The goal is to allow different parts of the application (like the Controller calling the Sensor) to communicate over the network as if they were just making local method calls, hiding the underlying network details through layered abstractions.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Messaging Connection\n\"]\n    A1[\"Message Framing Protocol\n\"]\n    A2[\"RPC Client\n\"]\n    A3[\"RPC Server\n\"]\n    A4[\"RPC Data Marshalling/Unmarshalling\n\"]\n    A5[\"RPC Client Stub\n\"]\n    A6[\"RPC Server Implementation (Skeleton)\n\"]\n    A5 -- \"Uses to make remote call\" --&gt; A2\n    A2 -- \"Uses for network send/receive\" --&gt; A0\n    A3 -- \"Uses for network receive/send\" --&gt; A0\n    A0 -- \"Uses for message structure\" --&gt; A1\n    A5 -- \"Uses to marshal/unmarshal data\" --&gt; A4\n    A6 -- \"Uses to unmarshal/marshal data\" --&gt; A4\n    A3 -- \"Dispatches call to\" --&gt; A6</code></pre>"},{"location":"oblig1/oblig1_index/#chapters","title":"Chapters","text":"<ol> <li>RPC Client Stub </li> <li>RPC Server Implementation (Skeleton) </li> <li>RPC Client </li> <li>RPC Server </li> <li>RPC Data Marshalling/Unmarshalling </li> <li>Messaging Connection </li> <li>Message Framing Protocol </li> </ol>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/","title":"Chapter 1: Message Hierarchy (Communication Protocol)","text":"<p>Welcome to the <code>dat110-project2-javafx-chatapp</code> tutorial! We're going to build a chat application, and the very first thing we need to figure out is how different parts of our application will talk to each other.</p> <p>Imagine you want to send different kinds of information through the postal mail. You wouldn't use the same format for a quick postcard as you would for a formal registration form, right? Each serves a different purpose and needs different information.</p> <p>Our chat application faces a similar challenge. The Client (your chat window) needs to talk to the Server (the central hub managing the chat). They need to exchange various types of information:</p> <ul> <li>A user wanting to join the chat.</li> <li>A user wanting to send a message to a specific chat topic.</li> <li>A user wanting to start receiving messages from a topic (subscribing).</li> <li>A user wanting to leave the chat.</li> </ul> <p>If the client just sent raw text, how would the server know what the client wants to do? Is \"hello\" a message to publish, or is it the name of a topic the user wants to create? It's confusing!</p> <p>To solve this, we need a Communication Protocol \u2013 a set of rules and standardized formats for messages. In our project, this is achieved through a Message Hierarchy.</p>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#what-is-the-message-hierarchy","title":"What is the Message Hierarchy?","text":"<p>Think of it like creating standardized templates for different kinds of postal mail:</p> <ul> <li>A basic template (<code>Message</code>) with common fields like the sender's name (<code>user</code>).</li> <li>A specialized template for connecting (<code>ConnectMsg</code>).</li> <li>A specialized template for sending a message (<code>PublishMsg</code>).</li> <li>A specialized template for joining a topic (<code>SubscribeMsg</code>).</li> <li>And so on...</li> </ul> <p>This way, when the server receives a message, it can look at its type (like looking at the type of envelope or form) and immediately understand its purpose and what information to expect inside.</p>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#the-base-messagejava","title":"The Base: <code>Message.java</code>","text":"<p>Everything starts with the <code>Message</code> class. This is the most basic building block, like a generic envelope.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/Message.java\npackage no.hvl.dat110.messages;\n\npublic abstract class Message { // 'abstract' means you can't create a plain 'Message', only specific types\n\n    private MessageType type; // What kind of message is this? (e.g., CONNECT, PUBLISH)\n    private String user;      // Which user sent this message?\n\n    // Constructor to set the type and user when creating a specific message\n    public Message(MessageType type, String user) {\n        this.type = type;\n        this.user = user;\n    }\n\n    public MessageType getType() { return this.type; }\n    public String getUser() { return user; }\n\n    @Override\n    public String toString() { // A helpful way to print message info for debugging\n        return \"Message [type=\" + type + \", user=\" + user + \"]\";\n    }\n}\n</code></pre> <ul> <li><code>MessageType type</code>: This is crucial! It tells us exactly what kind of action this message represents (Connect? Publish? Subscribe?). We'll see <code>MessageType</code> in a moment.</li> <li><code>String user</code>: Stores the username associated with the message.</li> <li><code>abstract class</code>: This means we can't just make a generic <code>Message</code> object. We must use one of the specific types (like <code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) that extend this base class.</li> </ul>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#message-types-messagetypejava","title":"Message Types: <code>MessageType.java</code>","text":"<p>To keep track of the different kinds of messages, we use an <code>enum</code> (a special type for defining a set of constants).</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageType.java\npackage no.hvl.dat110.messages;\n\n// Defines all possible types of messages in our system\npublic enum MessageType {\n    CONNECT,      // User wants to connect\n    DISCONNECT,   // User wants to disconnect\n    SUBSCRIBE,    // User wants to subscribe to a topic\n    UNSUBSCRIBE,  // User wants to unsubscribe from a topic\n    PUBLISH,      // User wants to send a message to a topic\n    CREATETOPIC,  // User wants to create a new topic\n    DELETETOPIC;  // User wants to delete a topic\n    // STATUS; // (Note: STATUS might be used by the server, omitted for client focus here)\n}\n</code></pre> <p>This <code>enum</code> provides clear, readable names for each message type used in the <code>Message</code> class's <code>type</code> field.</p>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#specialized-messages-adding-specific-details","title":"Specialized Messages: Adding Specific Details","text":"<p>Now, let's look at how we create specific message types based on the <code>Message</code> template.</p> <p>1. Connecting (<code>ConnectMsg.java</code>)</p> <p>When a user wants to connect, they just need to tell the server their username.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/ConnectMsg.java\npackage no.hvl.dat110.messages;\n\n// Inherits from the base Message class\npublic class ConnectMsg extends Message {\n\n    // Constructor for a Connect message\n    public ConnectMsg (String user) {\n        // Calls the base Message constructor, setting the type to CONNECT\n        // and passing along the username.\n        super(MessageType.CONNECT, user);\n        // No extra information needed for connecting, just the user.\n    }\n}\n</code></pre> <ul> <li><code>extends Message</code>: This means <code>ConnectMsg</code> is a type of <code>Message</code> and gets the <code>type</code> and <code>user</code> fields automatically.</li> <li><code>super(MessageType.CONNECT, user)</code>: This calls the constructor of the base <code>Message</code> class, setting the <code>type</code> specifically to <code>CONNECT</code> and storing the provided <code>user</code>.</li> </ul> <p>2. Publishing a Message (<code>PublishMsg.java</code>)</p> <p>When a user wants to send (\"publish\") a message, they need to specify which topic it belongs to and what the message content is, in addition to their username.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messages/PublishMsg.java\npackage no.hvl.dat110.messages;\n\npublic class PublishMsg extends Message {\n\n    // Additional fields specific to publishing\n    private String topic;   // Which topic to publish to?\n    private String message; // What is the actual message content?\n\n    public PublishMsg(String user, String topic, String message) {\n        // Set the type to PUBLISH and store the user\n        super(MessageType.PUBLISH, user);\n        // Store the topic and message specific to this type\n        this.topic = topic;\n        this.message = message;\n    }\n\n    // Methods to get the topic and message (Getters)\n    public String getTopic() { return topic; }\n    public String getMessage() { return message; }\n\n    // ... (Setters and toString methods are also usually here)\n}\n</code></pre> <ul> <li><code>extends Message</code>: Again, it inherits from <code>Message</code>.</li> <li><code>private String topic;</code>, <code>private String message;</code>: These are new fields added specifically for <code>PublishMsg</code>.</li> <li><code>super(MessageType.PUBLISH, user)</code>: Sets the type to <code>PUBLISH</code>.</li> <li><code>this.topic = topic;</code>, <code>this.message = message;</code>: Stores the extra information needed for publishing.</li> </ul> <p>Other message types like <code>SubscribeMsg</code>, <code>UnsubscribeMsg</code>, <code>CreateTopicMsg</code>, <code>DeleteTopicMsg</code>, and <code>DisconnectMsg</code> follow the same pattern: they extend <code>Message</code>, set the appropriate <code>MessageType</code>, and add any extra fields they need (like <code>topic</code> for most topic-related actions).</p>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#how-it-works-in-practice-conceptual","title":"How It Works in Practice (Conceptual)","text":"<p>Imagine you are the <code>Client</code> and want to connect to the <code>Server</code> as user \"Alice\".</p> <ol> <li>Client: Creates a <code>ConnectMsg</code> object: <code>new ConnectMsg(\"Alice\")</code>. This object internally has <code>type = MessageType.CONNECT</code> and <code>user = \"Alice\"</code>.</li> <li>Client: Sends this <code>ConnectMsg</code> object over the network to the Server. (We'll cover how it's sent in later chapters about TransportMessage and Connection).</li> <li>Server: Receives the message data. It reconstructs the <code>ConnectMsg</code> object (using helpers from MessageUtils).</li> <li>Server: Checks the message's type: <code>message.getType()</code>. It sees <code>MessageType.CONNECT</code>.</li> <li>Server: Ah! This is a connection request. It gets the username: <code>message.getUser()</code> which returns \"Alice\".</li> <li>Server: Performs the actions needed to register Alice as a connected user.</li> </ol> <p>Here's a simplified diagram of this flow:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;C: Create ConnectMsg(\"Alice\")\n    Note right of C: type=CONNECT, user=\"Alice\"\n    C-&gt;&gt;S: Send ConnectMsg data\n    S-&gt;&gt;S: Reconstruct ConnectMsg from data\n    S-&gt;&gt;S: Check message.getType() -&gt; CONNECT\n    S-&gt;&gt;S: Get message.getUser() -&gt; \"Alice\"\n    S-&gt;&gt;S: Process connection for \"Alice\"</code></pre> <p>By using this hierarchy, the Server can easily understand the Client's intentions without ambiguity. Each message type clearly defines the required information for a specific action.</p>"},{"location":"oblig2/01_message_hierarchy__communication_protocol__/#conclusion","title":"Conclusion","text":"<p>We've seen how the Message Hierarchy acts as a communication protocol for our chat application.</p> <ul> <li>It defines a base <code>Message</code> with common information (<code>type</code>, <code>user</code>).</li> <li>It uses specific message classes (<code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) that extend the base class and add action-specific data.</li> <li>It uses the <code>MessageType</code> enum to clearly identify the purpose of each message.</li> </ul> <p>This structured approach ensures that the Client and Server can communicate effectively and understand each other's requests and information.</p> <p>In the next chapter, we'll dive into the Client (Network Interaction Logic) and see how it actually uses these message objects to interact with the network and the server.</p>"},{"location":"oblig2/02_client__network_interaction_logic__/","title":"Chapter 2: Client (Network Interaction Logic)","text":"<p>In Chapter 1: Message Hierarchy (Communication Protocol), we learned how to create different types of messages (<code>ConnectMsg</code>, <code>PublishMsg</code>, etc.) to represent specific actions. This is like having different kinds of pre-printed forms for different requests.</p> <p>But how do we actually send these forms (messages) to the central server? And how do we receive replies or messages from others? We need someone \u2013 or something \u2013 dedicated to handling the communication with the server over the network. That's where the <code>Client</code> class comes in!</p>"},{"location":"oblig2/02_client__network_interaction_logic__/#what-is-the-client-our-applications-messenger","title":"What is the <code>Client</code>? Our Application's Messenger","text":"<p>Imagine you live in a big apartment building (your application) and want to communicate with the building manager (the server) who lives in a separate office. You wouldn't shout across the courtyard! You'd probably have a dedicated way to send and receive mail or messages.</p> <p>The <code>Client</code> class (<code>Client.java</code>) is like your application's personal messenger. Its main job is to manage the communication link between your chat application and the central chat server (often called a \"broker\").</p> <p>Here's what it does:</p> <ol> <li>Knows the Server's Address: It stores the server's network address (like <code>localhost</code> or an IP address) and the specific \"door number\" (port number, e.g., <code>9091</code>) it needs to connect to.</li> <li>Establishes the Connection: It handles the process of creating a network connection (like establishing a phone line) to the server.</li> <li>Sends Messages: It takes the message objects we learned about in Chapter 1 (like <code>ConnectMsg</code>, <code>PublishMsg</code>) and sends them over the network to the server.</li> <li>Receives Messages: It listens for incoming messages from the server and makes them available to the rest of the application.</li> </ol> <p>Essentially, the <code>Client</code> hides the messy details of network programming and gives the rest of our application simple commands like <code>connect()</code>, <code>publish(\"news\", \"hello everyone!\")</code>, <code>subscribe(\"news\")</code>.</p>"},{"location":"oblig2/02_client__network_interaction_logic__/#how-to-use-the-client","title":"How to Use the <code>Client</code>","text":"<p>Let's see how we would use our messenger (<code>Client</code>) to connect to the server and then publish a message.</p> <p>1. Creating the Messenger (<code>Client</code> object)</p> <p>First, we need to create an instance of the <code>Client</code>, telling it who we are (our username) and where the server is.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\nString username = \"Alice\";\nString serverHost = \"localhost\"; // Often the same machine for testing\nint serverPort = 9091;         // The port the server is listening on\n\n// Create a new Client instance\nClient chatClient = new Client(username, serverHost, serverPort);\n\nSystem.out.println(\"Chat client created for user: \" + username);\n</code></pre> <ul> <li>We provide the <code>username</code>, the <code>serverHost</code> (where the server is located), and the <code>serverPort</code>.</li> <li>This creates our <code>chatClient</code> object, ready to communicate but not yet connected.</li> </ul> <p>2. Connecting to the Server</p> <p>Now, we tell our messenger to establish the connection.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\n// Tell the client to connect to the server\nboolean success = chatClient.connect();\n\nif (success) {\n    System.out.println(\"Successfully connected to the server!\");\n} else {\n    System.out.println(\"Failed to connect to the server.\");\n}\n</code></pre> <ul> <li>Calling <code>chatClient.connect()</code> initiates the network connection process.</li> <li>It returns <code>true</code> if the connection was successful, <code>false</code> otherwise. Behind the scenes, this involves sending a <code>ConnectMsg</code> (from Chapter 1) to the server.</li> </ul> <p>3. Publishing a Message</p> <p>Once connected, we can send messages to topics.</p> <pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java (Conceptual Usage)\n\nString topic = \"general\";\nString messageContent = \"Hello from Alice!\";\n\n// Tell the client to publish a message to the 'general' topic\nchatClient.publish(topic, messageContent);\n\nSystem.out.println(\"Sent message to topic '\" + topic + \"'\");\n</code></pre> <ul> <li>We call <code>chatClient.publish()</code> with the desired <code>topic</code> and the <code>messageContent</code>.</li> <li>The <code>Client</code> takes care of creating the correct <code>PublishMsg</code> object (using our username \"Alice\") and sending it over the established connection.</li> </ul> <p>4. Other Actions</p> <p>The <code>Client</code> provides similar simple methods for other actions:</p> <ul> <li><code>subscribe(String topic)</code>: To start receiving messages from a topic.</li> <li><code>unsubscribe(String topic)</code>: To stop receiving messages.</li> <li><code>createTopic(String topic)</code>: To ask the server to create a new topic.</li> <li><code>deleteTopic(String topic)</code>: To ask the server to delete a topic.</li> <li><code>disconnect()</code>: To gracefully close the connection and inform the server.</li> <li><code>receive()</code>: To check for and retrieve any incoming messages sent from the server.</li> </ul> <p>All these methods use the appropriate message types from Chapter 1 under the hood.</p>"},{"location":"oblig2/02_client__network_interaction_logic__/#under-the-hood-how-does-connect-work","title":"Under the Hood: How Does <code>connect()</code> Work?","text":"<p>Let's peek behind the curtain when you call <code>chatClient.connect()</code>. It's a team effort involving a few components:</p> <ol> <li><code>Client</code> (<code>Client.java</code>): Your main messenger object.</li> <li><code>MessagingClient</code> (<code>MessagingClient.java</code>): A helper specifically focused on the initial network socket setup.</li> <li><code>Connection</code> (<code>Connection.java</code>): An object that wraps the actual network socket and handles reading/writing raw byte data. (We'll learn more in the Connection (Network Stream Handling) chapter).</li> <li><code>MessageUtils</code> (<code>MessageUtils.java</code>): A utility to convert our <code>Message</code> objects into raw data suitable for network transport, and vice-versa. (Covered in the MessageUtils (Serialization/Deserialization) chapter).</li> </ol> <p>Here\u2019s a simplified sequence of events:</p> <pre><code>sequenceDiagram\n    participant App as Your Application Code\n    participant Cl as Client (chatClient)\n    participant MC as MessagingClient\n    participant Srv as Server\n    participant Conn as Connection\n\n    App-&gt;&gt;Cl: connect()\n    Cl-&gt;&gt;MC: connect(server, port)\n    MC-&gt;&gt;Srv: Establish TCP Socket\n    Srv--&gt;&gt;MC: Socket established\n    MC-&gt;&gt;Conn: new Connection(socket)\n    Conn--&gt;&gt;MC: Connection object created\n    MC--&gt;&gt;Cl: return Connection object\n    Cl-&gt;&gt;Cl: Create ConnectMsg(\"Alice\")\n    Note right of Cl: Using the username provided earlier\n    Cl-&gt;&gt;Conn: send(ConnectMsg data)\n    Note right of Cl: MessageUtils helps prepare data (details later)\n    Conn-&gt;&gt;Srv: Send ConnectMsg raw data\n    Cl--&gt;&gt;App: return true (if all steps ok)</code></pre> <p>Code Glimpse:</p> <p>Let's look at parts of the <code>Client.java</code> code.</p> <ul> <li> <p>Constructor: Stores the server info using <code>MessagingClient</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\nprivate MessagingClient client; // Helper for initial connection\nprivate Connection connection;   // Handles the active connection\nprivate String user;           // Stores the username\n\npublic Client(String user, String server, int port) {\n    // Creates the MessagingClient helper with server details\n    client = new MessagingClient(server, port);\n    this.user = user;\n}\n</code></pre> *   The constructor just sets up the <code>MessagingClient</code> helper and stores the <code>user</code>.</p> </li> <li> <p><code>connect()</code> Method: Uses <code>MessagingClient</code> to get a <code>Connection</code> and then sends the <code>ConnectMsg</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\npublic boolean connect() {\n    boolean connected = false;\n    // Ask MessagingClient helper to establish the network link\n    connection = client.connect(); // Returns a Connection object\n\n    // Create the specific message for connecting\n    ConnectMsg msg = new ConnectMsg(user);\n\n    if (connection != null) { // Check if connection succeeded\n        // If yes, send the ConnectMsg over the connection\n        send(msg); // Uses the private helper 'send' method\n        connected = true;\n    }\n    return connected;\n}\n</code></pre> *   <code>client.connect()</code> does the low-level network setup and gives us a <code>Connection</code> object. *   A <code>ConnectMsg</code> is created using the stored <code>user</code>. *   The <code>send()</code> helper method (shown next) is used to actually transmit the message.</p> </li> <li> <p><code>send()</code> Helper Method: Prepares and sends any message.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\n// Private helper method to send any type of Message\nprivate void send(Message msg) {\n    // Convert the Message object (e.g., ConnectMsg, PublishMsg)\n    // into a TransportMessage suitable for network sending.\n    // MessageUtils does this magic (details in Chapter 8).\n    TransportMessage transportMsg = MessageUtils.toTransportMessage(msg);\n\n    // Tell the Connection object to send the prepared data.\n    // Connection handles the raw network sending (details in Chapter 7).\n    connection.send(transportMsg);\n}\n</code></pre> *   This method takes any <code>Message</code> (like <code>ConnectMsg</code>, <code>PublishMsg</code>). *   It uses <code>MessageUtils</code> to package the message for network travel (see MessageUtils (Serialization/Deserialization)). The result is a <code>TransportMessage</code> (see TransportMessage (Network Data Framing)). *   It then tells the <code>Connection</code> object to actually send the packaged data over the wire (see Connection (Network Stream Handling)).</p> </li> <li> <p><code>publish()</code> Method: Creates a <code>PublishMsg</code> and uses <code>send()</code>.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/client/Client.java\n\npublic void publish(String topic, String message) {\n    // Create the specific message type for publishing\n    PublishMsg msg = new PublishMsg(user, topic, message);\n\n    // Use the same send helper to transmit it\n    send(msg);\n}\n</code></pre> *   Very straightforward: creates the <code>PublishMsg</code> with the user, topic, and message content. *   Calls the <code>send()</code> helper method to handle the rest.</p> </li> </ul> <p>All other action methods (<code>subscribe</code>, <code>unsubscribe</code>, etc.) work similarly: create the specific <code>Message</code> object and call <code>send()</code>. The <code>receive()</code> method works in reverse, getting data from the <code>Connection</code> and using <code>MessageUtils</code> to turn it back into a <code>Message</code> object.</p>"},{"location":"oblig2/02_client__network_interaction_logic__/#conclusion","title":"Conclusion","text":"<p>The <code>Client</code> class acts as a crucial bridge between the high-level logic of our chat application (like wanting to connect or send a message) and the lower-level details of network communication. It provides simple methods (<code>connect</code>, <code>publish</code>, <code>subscribe</code>, etc.) that internally create the correct message types (from Chapter 1) and use helper components (<code>MessagingClient</code>, <code>Connection</code>, <code>MessageUtils</code>) to handle the actual sending and receiving over the network.</p> <p>You now understand how our application prepares to talk to the server. But how does the application actually start up, create this <code>Client</code>, and manage the user interface? That's the role of the application's entry point.</p> <p>In the next chapter, we'll look at Chapp (Application Entry Point), which ties everything together and launches the chat window.</p>"},{"location":"oblig2/03_chapp__application_entry_point__/","title":"Chapter 3: Chapp (Application Entry Point)","text":"<p>In the previous chapter, we learned about the <code>Client</code> class \u2013 our application's dedicated messenger responsible for talking to the chat server. We saw how it can <code>connect</code>, <code>publish</code> messages, and handle other network tasks using the message types defined in Chapter 1.</p> <p>But having a messenger isn't enough. How does the application even start? How does the chat window appear on the screen? How are the different visual parts (like the place to type messages and the place where messages appear) put together? We need a starting point, a master coordinator for the launch sequence.</p>"},{"location":"oblig2/03_chapp__application_entry_point__/#the-stage-manager-chappjava","title":"The Stage Manager: <code>Chapp.java</code>","text":"<p>Think about putting on a play in a theatre. You have actors (our data and logic), props (buttons, text fields), and maybe even a script (our message protocol). But who turns on the lights, raises the curtain, sets up the stage, and tells everyone when to start? That's the Stage Manager.</p> <p>In our chat application, the <code>Chapp</code> class (<code>Chapp.java</code>) is our Stage Manager. It's the Application Entry Point \u2013 the very first piece of our own code that runs when you launch the chat application.</p> <p>Its main jobs are:</p> <ol> <li>Starting the Show: It contains the special <code>main</code> method that the Java Virtual Machine (JVM) looks for to begin execution.</li> <li>Setting the Stage: It uses JavaFX (a toolkit for building user interfaces) to create the main application window (called a <code>Stage</code> in JavaFX).</li> <li>Bringing in the Scenery: It creates the main visual components, like the area for typing commands and the area for displaying messages.</li> <li>Arranging the Set: It organizes these visual components within the main window so they look right.</li> <li>Raising the Curtain: It makes the application window visible to the user.</li> </ol>"},{"location":"oblig2/03_chapp__application_entry_point__/#how-the-application-starts-the-main-method","title":"How the Application Starts: The <code>main</code> Method","text":"<p>Every Java application needs a starting point, a method called <code>main</code>. Our <code>Chapp</code> class has one too.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n\n// Import necessary JavaFX class\nimport javafx.application.Application;\n\n// Chapp inherits features from JavaFX's Application class\npublic class Chapp extends Application {\n\n    // ... (start method will be here) ...\n\n    // The main entry point when the application is launched\n    public static void main(String[] args) {\n\n        // Tell JavaFX to start the application lifecycle\n        Application.launch(args);\n\n    }\n}\n</code></pre> <ul> <li><code>public static void main(String[] args)</code>: This is the standard signature Java looks for. When you run the application, this method is executed first.</li> <li><code>Application.launch(args);</code>: This is the key line for JavaFX applications. Instead of putting all our setup code directly in <code>main</code>, we tell the JavaFX toolkit to take over. JavaFX then does some internal setup and calls another important method in our <code>Chapp</code> class: <code>start</code>.</li> </ul>"},{"location":"oblig2/03_chapp__application_entry_point__/#setting-up-the-window-the-start-method","title":"Setting Up the Window: The <code>start</code> Method","text":"<p>Because <code>Chapp</code> <code>extends Application</code>, it gets special abilities from JavaFX. One of these is the <code>start</code> method, which JavaFX calls automatically after <code>launch</code> is invoked. This is where we build our user interface.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n\n// Import necessary JavaFX classes\nimport javafx.application.Application;\nimport javafx.stage.Stage; // Represents the main window\nimport javafx.scene.Scene; // Represents the content inside the window\n// ... other imports ...\n\npublic class Chapp extends Application {\n\n    // This method is called by JavaFX after launch()\n    @Override // Indicates we are overriding a method from Application\n    public void start(Stage stage) {\n\n        // 'stage' is the main window, provided by JavaFX\n        stage.setTitle(\"ChApp - Chat Application\"); // Set the title bar text\n\n        // ... (We'll add the content setup here) ...\n\n        // Make the window visible!\n        stage.show(); \n    }\n\n    // ... (main method is also here) ...\n}\n</code></pre> <ul> <li><code>start(Stage stage)</code>: JavaFX creates the main window object (<code>Stage</code>) and passes it to our <code>start</code> method. Think of the <code>Stage</code> as the physical theatre building.</li> <li><code>stage.setTitle(...)</code>: Sets the text that appears in the window's title bar.</li> <li><code>stage.show()</code>: This is like opening the doors and turning on the lights \u2013 it makes the window appear on the screen. If we forget this, the application might be running, but we wouldn't see anything!</li> </ul>"},{"location":"oblig2/03_chapp__application_entry_point__/#bringing-the-ui-parts-together","title":"Bringing the UI Parts Together","text":"<p>Okay, we have a window (<code>Stage</code>), but it's empty. We need to create the actual user interface elements. <code>Chapp</code> is responsible for creating the main building blocks:</p> <ol> <li><code>CommandArea</code>: The section (likely at the bottom or side) where the user types commands like <code>/connect alice</code>, <code>/join general</code>, or just sends messages.</li> <li><code>MessageArea</code>: The main section where incoming chat messages and notifications are displayed.</li> <li><code>Menus</code>: The menu bar at the top (e.g., File, Options).</li> <li><code>Controller</code>: This isn't a visual part, but it's the \"brain\" that connects user actions (like clicking \"Send\") to the underlying logic (like telling the Client to send a message). We'll cover this in detail in the Controller (UI Logic Coordinator) chapter.</li> </ol> <p>Let's create instances of these inside the <code>start</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, before stage.show()\n\n// Create the UI area for user input\nCommandArea carea = new CommandArea(); \n// Create the UI area for displaying messages\nMessageArea marea = new MessageArea(); \n\n// Create the menu bar logic (needs the stage and areas)\nMenus menus = new Menus(stage, carea, marea); \n\n// Create the controller (needs the message area to update it)\nController controller = new Controller(marea); \n</code></pre> <p>At this point, these objects exist in memory, but they aren't arranged visually, nor are they fully connected to each other yet.</p>"},{"location":"oblig2/03_chapp__application_entry_point__/#arranging-the-ui-with-layouts","title":"Arranging the UI with Layouts","text":"<p>How do we place the <code>CommandArea</code> and <code>MessageArea</code> inside the window? JavaFX uses Layout Panes. Think of them like organizers or shelves for your UI elements. We'll use two common ones:</p> <ul> <li><code>HBox</code>: Arranges things horizontally (side-by-side).</li> <li><code>VBox</code>: Arranges things vertically (one above the other).</li> </ul> <p>We want the command area and message area next to each other, so we'll put them in an <code>HBox</code>. We also need to tell these areas about the <code>Controller</code> so they know who to talk to when the user does something.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after creating controller\n\n// Create a horizontal layout pane\nHBox hbox = new HBox(); \n\n// Tell the command area how to set itself up within the hbox\n// and who its controller is.\ncarea.setupCommandArea(hbox, controller, marea); \n// Tell the message area how to set itself up\nmarea.setupMessageAera(hbox, controller); \n\n// Also give the menus access to the controller\nmenus.setController(controller); \n// Get the actual visual menu bar from the Menus object\nMenuBar menuBar = menus.getMenuBar();\n</code></pre> <ul> <li>We create an <code>HBox</code>.</li> <li>We call <code>setup...</code> methods on <code>carea</code> and <code>marea</code>. These methods (defined within <code>CommandArea</code> and <code>MessageArea</code> themselves, which we'll see in Chapter 4) likely add buttons, text fields, etc., into the <code>hbox</code>. They also store a reference to the <code>controller</code>.</li> <li>We link the <code>controller</code> to the <code>menus</code> and get the visual <code>MenuBar</code>.</li> </ul> <p>Now, we want the <code>MenuBar</code> above the <code>HBox</code> containing the command and message areas. So, we put the <code>menuBar</code> and the <code>hbox</code> into a <code>VBox</code>:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after getting the menuBar\n\n// Create a vertical layout pane, putting the menu bar\n// on top of the horizontal box (hbox)\nVBox vbox = new VBox(menuBar, hbox); \n</code></pre>"},{"location":"oblig2/03_chapp__application_entry_point__/#putting-it-all-on-the-stage-the-scene","title":"Putting it All on the Stage: The <code>Scene</code>","text":"<p>We have our neatly arranged layout (<code>vbox</code>), but how do we put it inside the window (<code>Stage</code>)? We need one more JavaFX concept: the <code>Scene</code>.</p> <p>Think of the <code>Stage</code> as the theatre building, and the <code>Scene</code> as the actual stage set, lights, and curtains within that building. The <code>Scene</code> holds the root layout pane (our <code>vbox</code>) and defines the dimensions of the content area.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Chapp.java\n// Inside the start method, after creating vbox\n\n// Create the scene containing our vertical layout (vbox)\n// Set the initial size of the content area to 750x500 pixels\nScene scene = new Scene(vbox, 750, 500); \n\n// Put the scene onto the stage (our main window)\nstage.setScene(scene); \n\n// Now, finally, make the stage visible!\nstage.show(); \n</code></pre> <ul> <li><code>new Scene(vbox, 750, 500)</code>: Creates the scene, telling it that <code>vbox</code> is the main content and specifying the desired width and height.</li> <li><code>stage.setScene(scene)</code>: This connects our carefully constructed scene to the main window.</li> <li><code>stage.show()</code>: Raises the curtain! The window appears with the menu bar, command area, and message area all arranged.</li> </ul>"},{"location":"oblig2/03_chapp__application_entry_point__/#the-launch-sequence-simplified","title":"The Launch Sequence (Simplified)","text":"<p>Here's a simplified view of what happens when you run the application:</p> <pre><code>sequenceDiagram\n    participant OS as Operating System\n    participant JVM as Java Virtual Machine\n    participant Chapp as Chapp.java\n    participant JFX as JavaFX Toolkit\n    participant UI as UI Components (Areas, Menus)\n\n    OS-&gt;&gt;JVM: Run Chapp\n    JVM-&gt;&gt;Chapp: Execute main()\n    Chapp-&gt;&gt;JFX: Application.launch()\n    JFX-&gt;&gt;JFX: Internal Setup\n    JFX-&gt;&gt;Chapp: Create Stage object\n    JFX-&gt;&gt;Chapp: Call start(stage)\n    Chapp-&gt;&gt;UI: Create CommandArea, MessageArea, Menus\n    Chapp-&gt;&gt;Chapp: Create Controller\n    Chapp-&gt;&gt;Chapp: Create HBox, VBox (Layouts)\n    Chapp-&gt;&gt;UI: Call setup methods (add elements to layouts)\n    Chapp-&gt;&gt;JFX: Create Scene(vbox)\n    Chapp-&gt;&gt;JFX: stage.setScene(scene)\n    Chapp-&gt;&gt;JFX: stage.show()\n    JFX-&gt;&gt;OS: Display Application Window</code></pre>"},{"location":"oblig2/03_chapp__application_entry_point__/#conclusion","title":"Conclusion","text":"<p>The <code>Chapp</code> class is the essential starting point for our graphical chat application. As the Application Entry Point, it performs the critical tasks of:</p> <ul> <li>Providing the <code>main</code> method to kick things off.</li> <li>Using JavaFX's <code>Application.launch</code> and <code>start</code> mechanism.</li> <li>Creating the main window (<code>Stage</code>).</li> <li>Instantiating the core UI building blocks (<code>CommandArea</code>, <code>MessageArea</code>, <code>Menus</code>) and the <code>Controller</code>.</li> <li>Arranging these blocks using layout panes (<code>HBox</code>, <code>VBox</code>).</li> <li>Placing the layout into a <code>Scene</code> and displaying it on the <code>Stage</code>.</li> </ul> <p>Think of <code>Chapp</code> as the director who gets everything ready before the main action begins. It sets up the visual structure, but the detailed behavior within those UI areas is handled by other components.</p> <p>Now that we've seen how the application window is built and displayed, we can dive into the details of the visual components themselves. In the next chapter, we'll explore the UI Areas (CommandArea &amp; MessageArea) to see how they are constructed and what elements they contain.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/","title":"Chapter 4: UI Areas (CommandArea &amp; MessageArea)","text":"<p>In the previous chapter, we saw how <code>Chapp</code> acts like a stage manager, setting up the main window (<code>Stage</code>) and creating the initial instances of our UI components. It brought the actors (<code>CommandArea</code>, <code>MessageArea</code>) onto the stage but didn't delve into what those actors actually do or how they are built.</p> <p>Now, let's look closely at two of those main actors: <code>CommandArea</code> and <code>MessageArea</code>. Think about any chat application you've used. You usually have:</p> <ol> <li>A place where you type your messages, maybe choose a topic, and click \"Send\" or \"Connect\".</li> <li>A separate area where you see the messages from other people appearing.</li> </ol> <p>It wouldn't make sense to mix these up, right? Having dedicated areas makes the application much easier to use. Our <code>CommandArea</code> and <code>MessageArea</code> classes define these distinct sections.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/#the-dashboard-analogy","title":"The Dashboard Analogy","text":"<p>Imagine the dashboard of a car. You have one area with controls: the steering wheel, pedals, buttons for lights or wipers. This is where you interact with the car to tell it what to do. This is like our <code>CommandArea</code>.</p> <p>Then, you have another area with displays: the speedometer, fuel gauge, warning lights. This shows you information from the car about its status. This is like our <code>MessageArea</code>.</p> <p><code>CommandArea</code> and <code>MessageArea</code> are Java classes that use JavaFX elements to build these visual panels for our chat application.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/#commandarea-the-control-panel","title":"<code>CommandArea</code>: The Control Panel","text":"<p>The <code>CommandArea</code> class (<code>CommandArea.java</code>) is responsible for creating the part of the user interface where the user gives commands or types messages. It contains all the buttons, text boxes, and labels needed for interaction.</p> <p>What's Inside?</p> <ul> <li>Buttons: For actions like \"Connect\", \"Create Topic\", \"Subscribe\", \"Publish\".</li> <li>Text Fields: For typing in the topic name or the message content.</li> <li>Labels: To display static text or simple information like the connected server or current username.</li> <li>Layout: It uses a layout pane (like <code>GridPane</code>) to arrange these elements neatly.</li> </ul> <p>Setting up the <code>CommandArea</code></p> <p>Remember in <code>Chapp.java</code>, we saw this line:</p> <pre><code>// From Chapp.java's start() method\ncarea.setupCommandArea(hbox, controller, marea);\n</code></pre> <p>This calls the <code>setupCommandArea</code> method inside <code>CommandArea.java</code>. Let's look at a simplified version of what that method does:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Simplified)\npackage no.hvl.dat110.chapp;\n\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.GridPane; // For arranging elements in a grid\nimport javafx.scene.layout.HBox;    // The horizontal box from Chapp\n// ... other imports\n\npublic class CommandArea {\n\n    private Controller controller; // Reference to the application's brain\n\n    public void setupCommandArea(HBox hbox, Controller controller, MessageArea marea) {\n        this.controller = controller; // Store the controller for later use\n\n        // Create a grid layout to organize controls\n        GridPane grid = new GridPane();\n        grid.setHgap(10); // Horizontal spacing\n        grid.setVgap(10); // Vertical spacing\n\n        // --- Example: Connect Button ---\n        Button connectBtn = new Button(\"Connect\");\n        grid.add(connectBtn, 0, 0); // Add button to grid at column 0, row 0\n\n        // --- Example: Topic Text Field ---\n        TextField topicField = new TextField();\n        topicField.setPromptText(\"Enter topic name\"); // Placeholder text\n        grid.add(topicField, 1, 1); // Add text field at column 1, row 1\n\n        // --- Example: Create Topic Button ---\n        Button createTopicBtn = new Button(\"Create Topic\");\n        grid.add(createTopicBtn, 0, 1); // Add button at column 0, row 1\n\n        // ... (Many other buttons and fields are created and added here) ...\n\n        // Finally, add the organized grid to the HBox provided by Chapp\n        hbox.getChildren().add(grid);\n    }\n}\n</code></pre> <ul> <li><code>setupCommandArea</code>: This method takes the main <code>HBox</code> (from <code>Chapp</code>), the central <code>Controller</code> (our application's brain), and the <code>MessageArea</code> as input.</li> <li><code>GridPane</code>: A handy JavaFX layout tool that arranges elements in rows and columns, like a spreadsheet.</li> <li><code>new Button(...)</code>, <code>new TextField()</code>: These lines create the actual visual components.</li> <li><code>grid.add(...)</code>: This places each component into a specific cell in the grid.</li> <li><code>hbox.getChildren().add(grid)</code>: The entire grid, filled with controls, is added to the <code>HBox</code> that <code>Chapp</code> created, making it visible in the main window layout.</li> </ul> <p>Making Buttons Do Things</p> <p>Creating buttons is nice, but they need to do something when clicked! This is where the Controller comes in. Inside <code>setupCommandArea</code>, we also set up event handlers.</p> <p>Think of an event handler as telling the button: \"When someone clicks you, call this specific method in the <code>Controller</code>.\"</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Simplified event handling)\n\n// Inside setupCommandArea, after creating createTopicBtn and topicField\n\ncreateTopicBtn.setOnAction((event) -&gt; {\n    // This code runs when createTopicBtn is clicked\n\n    String topic = topicField.getText(); // Get text from the topic input field\n\n    if (!topic.isEmpty()) { // Make sure the user typed something\n        // Tell the controller to handle the \"create topic\" action\n        controller.createTopic(topic);\n        System.out.println(\"Create Topic button clicked for: \" + topic);\n    }\n});\n\n// Similar setOnAction calls are made for connectBtn, subscribeBtn, publishBtn, etc.\n</code></pre> <ul> <li><code>setOnAction(...)</code>: This is a standard JavaFX way to define what happens when a button (or other control) is interacted with.</li> <li><code>controller.createTopic(topic)</code>: This is the crucial part! The <code>CommandArea</code> doesn't know how to create a topic itself. It just grabs the topic name from the text field and tells the <code>Controller</code> to handle the logic. The <code>Controller</code> will then likely use the <code>Client</code> to send the appropriate message (Chapter 1) to the server.</li> </ul> <p>So, the <code>CommandArea</code> is the user's input panel, collecting information and delegating the actual work to the <code>Controller</code>.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/#messagearea-the-information-display","title":"<code>MessageArea</code>: The Information Display","text":"<p>The <code>MessageArea</code> class (<code>MessageArea.java</code>) builds the other main part of our UI: the section where incoming chat messages, connection confirmations, and other notifications are shown to the user.</p> <p>What's Inside?</p> <ul> <li><code>TextArea</code>: The primary component. This is a multi-line text box designed to display (and optionally edit) text. In our case, we'll mostly use it for displaying incoming messages.</li> <li>Labels: Maybe a title like \"Messages\".</li> <li>Layout: It uses a layout pane (like <code>VBox</code>) to arrange its elements.</li> </ul> <p>Setting up the <code>MessageArea</code></p> <p>Similar to <code>CommandArea</code>, <code>Chapp.java</code> calls a setup method:</p> <pre><code>// From Chapp.java's start() method\nmarea.setupMessageAera(hbox, controller);\n</code></pre> <p>Let's look at a simplified <code>setupMessageAera</code> method:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/MessageArea.java (Simplified)\npackage no.hvl.dat110.chapp;\n\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextArea; // The main display area\nimport javafx.scene.layout.HBox;     // The horizontal box from Chapp\nimport javafx.scene.layout.VBox;     // Vertical layout for this area\n// ... other imports\n\npublic class MessageArea {\n\n    private Controller controller;\n    private TextArea messages; // The field where messages will appear\n\n    public void setupMessageAera(HBox hbox, Controller controller) {\n        this.controller = controller;\n\n        // Create a vertical layout for this panel\n        VBox vbox = new VBox();\n        vbox.setPadding(new Insets(10, 10, 10, 10)); // Add some spacing\n\n        // --- A Title Label ---\n        Label msgLabel = new Label(\"Messages\");\n\n        // --- The Main Message Display Area ---\n        messages = new TextArea(); // Create the text area\n        messages.setPrefHeight(500); // Suggest a height\n        messages.setPrefWidth(300);  // Suggest a width\n        messages.setEditable(false); // User shouldn't type directly here!\n\n        // Add the label and the text area to the vertical box\n        vbox.getChildren().addAll(msgLabel, messages);\n\n        // Add this vertical box to the main HBox from Chapp\n        hbox.getChildren().add(vbox);\n    }\n\n    // ... (methods to start/stop message handling are also here) ...\n}\n</code></pre> <ul> <li><code>setupMessageAera</code>: Takes the main <code>HBox</code> and the <code>Controller</code>.</li> <li><code>VBox</code>: A vertical layout pane. We put the \"Messages\" label above the <code>TextArea</code>.</li> <li><code>new TextArea()</code>: Creates the multi-line text display area.</li> <li><code>messages.setEditable(false)</code>: This is important! It prevents the user from typing directly into the message display area. Only our application logic should add text here.</li> <li><code>vbox.getChildren().addAll(...)</code>: Adds the label and the text area to our vertical layout.</li> <li><code>hbox.getChildren().add(vbox)</code>: Adds the <code>MessageArea</code>'s layout next to the <code>CommandArea</code>'s layout within the main window's <code>HBox</code>.</li> </ul> <p>Receiving and Displaying Messages</p> <p>How does text actually appear in the <code>messages</code> TextArea? The <code>MessageArea</code> itself doesn't directly listen for network messages. That's the job of the Client and the Controller.</p> <p>The <code>MessageArea</code> has a helper mechanism (involving <code>MessageHandler.java</code>, which we won't detail here) that periodically asks the <code>Controller</code> if any new messages have arrived. If the <code>Controller</code> provides a message, the <code>MessageHandler</code> updates the <code>TextArea</code>.</p> <p>A crucial part of this is starting the message handler:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/MessageArea.java\n\n// Reference to the message handler helper task\nprivate MessageHandler msghandler;\n// The TextArea defined in setupMessageAera\nprivate TextArea messages;\n\npublic void startMessageHandler () {\n    // Create the handler, giving it the controller (to ask for messages)\n    // and the messages TextArea (to update it)\n    msghandler = new MessageHandler(controller, messages);\n\n    // Start the handler running in the background\n    msghandler.start();\n}\n\npublic void stopMessageHandler () {\n    // Method to stop the background task gracefully\n    if (msghandler != null) {\n        msghandler.doStop();\n    }\n}\n\n// --- Inside MessageHandler.java (Conceptual) ---\n// public void doProcess() {\n//     String message = controller.receive(); // Ask controller for new message\n//     if (message != null) {\n//         messages.appendText(message + \"\\n-\\n\"); // Add to TextArea!\n//     }\n//     // Wait a bit before checking again\n// }\n</code></pre> <ul> <li><code>startMessageHandler()</code>: This method (called at the right time, often after connecting) creates and starts the <code>MessageHandler</code>.</li> <li><code>MessageHandler</code>: This helper continuously checks with the <code>controller.receive()</code> method.</li> <li><code>messages.appendText(...)</code>: If <code>controller.receive()</code> returns a message string, the handler adds it to the end of the text already in the <code>TextArea</code>.</li> </ul> <p>So, the <code>MessageArea</code> primarily provides the place (<code>TextArea</code>) for messages to be displayed, and relies on a helper mechanism coordinated by the <code>Controller</code> to actually get and display those messages.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/#how-they-fit-together","title":"How They Fit Together","text":"<pre><code>graph TD\n    subgraph User Interface Window\n        CA[CommandArea (GridPane)]\n        MA[MessageArea (VBox)]\n    end\n\n    User --&gt; CA(Clicks Button, Types Text)\n    CA --&gt; CTRL(Controller)\n    CTRL --&gt; Client(Client: Sends Message)\n    Client --&gt; Server\n\n    Server --&gt; Client(Client: Receives Message)\n    Client --&gt; CTRL(Controller: Processes Message)\n    CTRL --&gt; MH(MessageHandler)\n    MH --&gt; MA(Updates TextArea)\n\n    style CA fill:#ccf,stroke:#333,stroke-width:2px\n    style MA fill:#cdf,stroke:#333,stroke-width:2px</code></pre> <p>This diagram shows the flow: 1.  The User interacts with the <code>CommandArea</code>. 2.  <code>CommandArea</code> tells the <code>Controller</code> what the user did. 3.  The <code>Controller</code> uses the <code>Client</code> to talk to the Server. 4.  When messages come back from the Server via the <code>Client</code>, the <code>Controller</code> processes them. 5.  The <code>Controller</code> makes the message available to the <code>MessageHandler</code> (part of <code>MessageArea</code>'s machinery). 6.  The <code>MessageHandler</code> updates the <code>TextArea</code> inside the <code>MessageArea</code> for the user to see.</p>"},{"location":"oblig2/04_ui_areas__commandarea___messagearea__/#conclusion","title":"Conclusion","text":"<p>We've learned that <code>CommandArea</code> and <code>MessageArea</code> are crucial for organizing our chat application's user interface into logical sections:</p> <ul> <li><code>CommandArea</code>: Acts as the control panel, providing buttons and text fields for user input. It delegates actions to the <code>Controller</code>.</li> <li><code>MessageArea</code>: Acts as the display panel, primarily using a <code>TextArea</code> to show incoming messages received via the <code>Controller</code> and its helper <code>MessageHandler</code>.</li> </ul> <p>These classes use standard JavaFX components (<code>Button</code>, <code>TextField</code>, <code>TextArea</code>, <code>GridPane</code>, <code>VBox</code>) to build their respective parts of the UI. They are created by <code>Chapp</code> and rely heavily on the <code>Controller</code> to link user actions and incoming data to the correct behavior.</p> <p>Now that we understand the input and output areas of our UI, it's time to look at the central coordinator that makes them work together. In the next chapter, we'll explore the Controller (UI Logic Coordinator), the brain that connects the user's actions in the <code>CommandArea</code> to the underlying <code>Client</code> logic and updates the <code>MessageArea</code>.</p>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/","title":"Chapter 5: Controller (UI Logic Coordinator)","text":"<p>In the previous chapter, we explored the <code>CommandArea</code> (where you type commands) and the <code>MessageArea</code> (where you see messages). We saw that when you click a button in the <code>CommandArea</code>, it needs to tell something to perform the actual action, like connecting to the server or sending a message. Similarly, when a new message arrives from the network, something needs to take that message and display it in the <code>MessageArea</code>.</p> <p>But who is this \"something\"? The <code>CommandArea</code> shouldn't know the details of network connections, and the <code>MessageArea</code> shouldn't be responsible for listening for incoming data. We need a central coordinator to manage the flow of information between the user interface and the background logic.</p>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#the-director-of-the-play-introducing-the-controller","title":"The Director of the Play: Introducing the Controller","text":"<p>Imagine our chat application is like a stage play: *   The User Interface (<code>CommandArea</code>, <code>MessageArea</code>) are the actors on stage. *   The User is the audience member giving cues (clicking buttons). *   The Client (Chapter 2) is like the backstage crew handling technical things (network communication). *   The Message Protocol (Chapter 1) is the script they follow.</p> <p>Who tells the actors what to do based on the cues, and who tells the backstage crew when to perform their tasks? That's the Director!</p> <p>In our application, the <code>Controller</code> class (<code>Controller.java</code>) acts as this director. It's the UI Logic Coordinator. It sits between the UI elements and the <code>Client</code> logic, directing the flow of actions and information.</p> <p>Its main jobs are:</p> <ol> <li>Listen for Cues: When the user interacts with the <code>CommandArea</code> (e.g., clicks the \"Connect\" button), the <code>CommandArea</code> notifies the <code>Controller</code>.</li> <li>Direct the Action: The <code>Controller</code> interprets the cue and tells the <code>Client</code> what to do (e.g., <code>client.connect()</code>).</li> <li>Handle Incoming Information: When the <code>Client</code> receives something from the server (like a new message), it gives it to the <code>Controller</code>.</li> <li>Update the Stage: The <code>Controller</code> processes the incoming information and makes sure the <code>MessageArea</code> is updated so the user can see it.</li> </ol> <p>Without the <code>Controller</code>, the UI and the network logic would be disconnected, unable to work together.</p>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#how-the-controller-gets-involved-a-button-click-example","title":"How the Controller Gets Involved: A Button Click Example","text":"<p>Let's revisit the \"Create Topic\" button from the <code>CommandArea</code> in Chapter 4.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/CommandArea.java (Event Handling part)\n\n// Inside setupCommandArea, for the 'Create Topic' button\n\ncreateTopicBtn.setOnAction((event) -&gt; {\n    // This code runs when createTopicBtn is clicked\n\n    String topic = topicField.getText(); // Get text from the topic input field\n\n    if (!topic.isEmpty()) {\n        // HERE: CommandArea tells the Controller to do the work!\n        controller.createTopic(topic);\n        System.out.println(\"Create Topic button clicked for: \" + topic);\n    }\n});\n</code></pre> <ol> <li>The user types \"news\" into the <code>topicField</code> and clicks <code>createTopicBtn</code>.</li> <li>The <code>setOnAction</code> code runs.</li> <li>It gets the text \"news\" from <code>topicField</code>.</li> <li>Crucially, it calls <code>controller.createTopic(\"news\")</code>. The <code>CommandArea</code> delegates the task to the <code>Controller</code>. It doesn't know how to create a topic; it just knows it needs to ask the <code>Controller</code> to do it.</li> </ol>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#what-happens-inside-the-controller","title":"What Happens Inside the Controller?","text":"<p>So, what does the <code>Controller</code> do when its <code>createTopic(\"news\")</code> method is called?</p> <ol> <li>Check Status: It first checks if the application is actually connected to the server. It doesn't make sense to create a topic if we're not connected!</li> <li>Delegate to Client: If connected, it tells the <code>Client</code> object (our network messenger from Chapter 2) to handle the request. It calls something like <code>client.createTopic(\"news\")</code>.</li> <li>Client Does the Work: The <code>Client</code> then creates the appropriate <code>CreateTopicMsg</code> (from Chapter 1) and sends it over the network to the server.</li> </ol> <p>Here\u2019s a simplified diagram of this flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant CA as CommandArea\n    participant Ctrl as Controller\n    participant Cl as Client\n    participant Srv as Server\n\n    User-&gt;&gt;CA: Clicks \"Create Topic\" (topic=\"news\")\n    CA-&gt;&gt;Ctrl: controller.createTopic(\"news\")\n    Ctrl-&gt;&gt;Ctrl: Check if connected? (Yes)\n    Ctrl-&gt;&gt;Cl: client.createTopic(\"news\")\n    Cl-&gt;&gt;Cl: Create CreateTopicMsg(\"news\")\n    Cl-&gt;&gt;Srv: Send CreateTopicMsg data\n    Note left of Srv: Server processes the request</code></pre>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#a-look-at-the-controllers-code","title":"A Look at the Controller's Code","text":"<p>Let's peek inside <code>Controller.java</code>.</p> <p>1. Storing Information: The <code>Controller</code> needs to keep track of important details.</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\nimport no.hvl.dat110.client.*; // Needed for the Client class\nimport no.hvl.dat110.messages.PublishMsg; // Needed for receiving messages\n\npublic class Controller {\n\n    // Information about the user and server\n    private String user;\n    private String brokerhost;\n    private int brokerport;\n\n    // The network messenger\n    private Client client;\n    // Flag to track connection status\n    private boolean isconnected = false;\n\n    // Default values if not set via menus\n    private static String DEFAULT_USER = \"me\";\n    private static String DEFAULT_BROKERHOST = \"localhost\";\n    private static int DEFAULT_BROKERPORT = 8080;\n\n    // Constructor - Sets default values initially\n    public Controller (MessageArea messagearea) {\n        this.brokerport = DEFAULT_BROKERPORT;\n        this.brokerhost = DEFAULT_BROKERHOST;\n        this.user = DEFAULT_USER;\n        // Note: The messagearea isn't stored here in this version,\n        // but it's passed to the MessageHandler later.\n    }\n\n    // ... methods to get/set user, host, port ...\n}\n</code></pre> <ul> <li>It stores the <code>user</code> name, <code>brokerhost</code>, and <code>brokerport</code>. These can be changed via the application menus.</li> <li>It holds a reference to the <code>Client</code> object (once connected).</li> <li><code>isconnected</code> is a simple boolean flag to know if we have an active connection.</li> </ul> <p>2. Handling the \"Connect\" Action:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public boolean connect () {\n        boolean success = true; // Assume success initially\n\n        // Create the Client instance with current user/host/port\n        this.client = new Client(user, brokerhost, brokerport);\n\n        // Tell the client to establish the network connection\n        client.connect(); // This internally sends a ConnectMsg\n\n        // In a real app, 'connect()' would return true/false\n        // based on success. Here we assume it worked.\n        if (success) {\n            isconnected = true; // Update our status flag\n        }\n\n        return success;\n    }\n</code></pre> <ul> <li>This method is called (likely by the <code>ConnectBtnHandler</code> we saw linked in <code>CommandArea</code>) when the user wants to connect.</li> <li>It creates a new <code>Client</code> instance using the current settings.</li> <li>It calls <code>client.connect()</code>, which handles the actual network setup and sends the initial <code>ConnectMsg</code>.</li> <li>It updates the <code>isconnected</code> flag.</li> </ul> <p>3. Handling the \"Create Topic\" Action:</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public void createTopic(String topic) {\n        // Only proceed if we are currently connected\n        if (isconnected) {\n            // Delegate the task to the Client object\n            client.createTopic(topic);\n        }\n    }\n</code></pre> <ul> <li>This is the method called by the <code>CommandArea</code>'s button handler.</li> <li>It first checks the <code>isconnected</code> flag.</li> <li>If <code>true</code>, it simply calls the corresponding method on the <code>client</code> object: <code>client.createTopic(topic)</code>. The <code>Controller</code> doesn't need to know the details of how the <code>Client</code> does this.</li> </ul> <p>Methods like <code>deleteTopic</code>, <code>subscribe</code>, <code>unsubscribe</code>, and <code>publish</code> follow the exact same pattern: check <code>isconnected</code>, then call the corresponding method on the <code>client</code>.</p> <p>4. Receiving Messages: How does the <code>Controller</code> get messages from the <code>Client</code> to eventually show in the <code>MessageArea</code>?</p> <pre><code>// File: src/main/java/no/hvl/dat110/chapp/Controller.java\n\n    public String receive() {\n        String message = null; // Start with no message\n\n        // Only try to receive if connected\n        if (isconnected) {\n            // Ask the client to check for incoming messages\n            // client.receive() waits for and reconstructs a message\n            // We expect PublishMsg specifically for chat content\n            PublishMsg msg = (PublishMsg) client.receive();\n\n            // If the client actually returned a message (not null)\n            if (msg != null) {\n                // Format it nicely for display\n                message = \"[\" + msg.getUser() + \"] \" + msg.getMessage();\n            }\n        }\n        // Return the formatted message string, or null if none arrived\n        return message;\n    }\n</code></pre> <ul> <li>This <code>receive()</code> method is called periodically by the <code>MessageHandler</code> (which belongs to the <code>MessageArea</code>).</li> <li>It checks <code>isconnected</code>.</li> <li>It calls <code>client.receive()</code>. This method in the <code>Client</code> waits for data, reconstructs it into a <code>Message</code> object (using helpers we'll see later), and returns it. We expect incoming chat messages to be <code>PublishMsg</code> type.</li> <li>If a <code>PublishMsg</code> is received (<code>msg != null</code>), the <code>Controller</code> extracts the user and the actual message content.</li> <li>It formats this information into a user-friendly string (e.g., <code>[Alice] Hello Bob!</code>).</li> <li>This string is then returned to the <code>MessageHandler</code>, which appends it to the <code>MessageArea</code>'s <code>TextArea</code>.</li> </ul>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#the-central-hub","title":"The Central Hub","text":"<p>The <code>Controller</code> truly acts as the central hub or coordinator:</p> <ul> <li>It receives requests triggered by user actions in the <code>CommandArea</code>.</li> <li>It validates these requests (e.g., checking <code>isconnected</code>).</li> <li>It translates these requests into calls to the <code>Client</code>'s methods.</li> <li>It receives processed data (incoming messages) from the <code>Client</code>.</li> <li>It formats this data and makes it available for the <code>MessageArea</code> to display.</li> </ul> <p>It ensures that the UI components (Chapter 4) don't need to know about the complexities of network communication (Chapter 2), and the <code>Client</code> doesn't need to know about the specific UI elements like buttons or text areas.</p>"},{"location":"oblig2/05_controller__ui_logic_coordinator__/#conclusion","title":"Conclusion","text":"<p>We've learned that the <code>Controller</code> is the essential UI Logic Coordinator in our chat application. It acts like a director or a switchboard operator, connecting user interface events to the underlying client logic and relaying incoming information back to the UI for display.</p> <p>Key takeaways: *   It decouples the UI (<code>CommandArea</code>, <code>MessageArea</code>) from the network logic (<code>Client</code>). *   It handles UI events by calling appropriate methods on the <code>Client</code>. *   It provides a way (<code>receive()</code>) for the UI to get incoming messages processed by the <code>Client</code>. *   It maintains the application's state, like the connection status (<code>isconnected</code>).</p> <p>Now that we understand how the UI and the <code>Client</code> interact via the <code>Controller</code>, let's look deeper into how messages are prepared for network transmission. How does our <code>PublishMsg</code> object actually get turned into bytes that can be sent over the internet?</p> <p>In the next chapter, we'll explore Chapter 6: TransportMessage (Network Data Framing) to understand how messages are packaged for their journey across the network.</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/","title":"Chapter 6: TransportMessage (Network Data Framing)","text":"<p>In the previous chapter, we saw how the <code>Controller</code> acts as the application's director, taking requests from the UI (like sending a message) and telling the <code>Client</code> (Chapter 2) what to do. The <code>Client</code> then prepares to send a message object (like a <code>PublishMsg</code> from Chapter 1) over the network.</p> <p>But how does that message object actually travel across the internet? Computers connected via a network send data as streams of raw bytes (ones and zeroes). If our <code>Client</code> just dumped all the bytes for <code>ConnectMsg</code>, then <code>PublishMsg</code>, then another <code>PublishMsg</code> into the stream, how would the <code>Server</code> know where one message ends and the next one starts?</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#the-problem-finding-message-boundaries-in-a-stream","title":"The Problem: Finding Message Boundaries in a Stream","text":"<p>Imagine you're receiving a very long letter, but instead of arriving in an envelope, it arrives as one continuous ticker tape of letters with no spaces or punctuation. It would be impossible to read!</p> <pre><code>HELLOWORLDHOWAREYOUIMFINEGOODBYE\n</code></pre> <p>Network communication is similar. Data arrives as a continuous stream of bytes. The receiver needs a way to figure out: \"Okay, these specific bytes make up the first message, and these next bytes make up the second message.\" Without clear boundaries, the data is just a jumbled mess.</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#the-solution-data-framing","title":"The Solution: Data Framing","text":"<p>To solve this, we use Data Framing. Think of it like putting each message into its own standard-sized envelope or small shipping box before sending it. This \"frame\" not only holds the message content (the \"payload\") but also adds some extra information, like a label on the outside.</p> <p>In our chat application, the most important piece of information we add is the length of the payload.</p> <p>Analogy: The Standard Envelope</p> <p>Imagine you have messages of different lengths (a short note, a long letter). 1.  You get a standard-sized envelope (maybe it can hold up to 100 characters). 2.  You write your message (the payload). Let's say it's \"Hi Bob!\" (7 characters). 3.  You put the message inside the envelope. 4.  Crucially, on the outside of the envelope, you write: \"Payload Length: 7\". 5.  You send the envelope.</p> <p>When your friend receives the standard-sized envelope, they don't need to guess where your message ends. They look at the label (\"Payload Length: 7\"), open the envelope, and read exactly the first 7 characters. They know those 7 characters constitute the complete message. Anything else in the envelope is just padding, and the next envelope they receive will contain the next message.</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#our-standard-envelope-transportmessagejava","title":"Our Standard Envelope: <code>TransportMessage.java</code>","text":"<p>In our project, the <code>TransportMessage</code> class acts as this standard envelope or frame. Its main job is to hold the raw data bytes of the actual message we want to send (like the bytes representing a <code>ConnectMsg</code> or <code>PublishMsg</code>) and provide methods to wrap (frame) and unwrap (unframe) this data.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\npublic class TransportMessage {\n\n    // The actual message content (raw bytes)\n    private byte[] payload;\n\n    // Constructor: Creates a TransportMessage holding the payload\n    public TransportMessage(byte[] payload) {\n        // We need to make sure the payload isn't too big for our 'envelope'\n        if (payload == null || (payload.length + 1 &gt; MessageConfig.SEGMENTSIZE)) {\n            // (+1 because we need space for the length byte itself)\n            throw new RuntimeException(\"Payload too large for segment!\");\n        }\n        this.payload = payload;\n    }\n\n    // Method to get the payload data back out\n    public byte[] getData() {\n        return this.payload;\n    }\n\n    // ... (encapsulate and decapsulate methods coming next) ...\n}\n</code></pre> <ul> <li><code>private byte[] payload;</code>: This is where the raw data of the original message (e.g., the serialized <code>PublishMsg</code>) is stored. How we get these bytes from a <code>PublishMsg</code> object is the job of Chapter 8: MessageUtils (Serialization/Deserialization). For now, just know that <code>payload</code> holds the core message content as bytes.</li> <li><code>TransportMessage(byte[] payload)</code>: The constructor takes these payload bytes and stores them. It also checks if the payload, plus the one extra byte we need for the length, will fit into our standard network packet size (<code>MessageConfig.SEGMENTSIZE</code>).</li> </ul>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#fixed-packet-size-messageconfigsegmentsize","title":"Fixed Packet Size: <code>MessageConfig.SEGMENTSIZE</code>","text":"<p>Our network communication uses fixed-size packets, like using only one size of shipping box. This size is defined in <code>MessageConfig.java</code>.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/MessageConfig.java\n\npublic class MessageConfig {\n\n    // All our network 'envelopes' will be exactly 128 bytes long\n    public static final int SEGMENTSIZE = 128;\n\n    // Other network config (ignore for now)\n    public static final int MESSAGINGPORT = 8080;\n    public static final String MESSAGINGHOST = \"localhost\";\n}\n</code></pre> <ul> <li><code>SEGMENTSIZE = 128</code>: This means every chunk of data sent or received over the network using our <code>TransportMessage</code> framing will be exactly 128 bytes.</li> </ul>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#packing-the-envelope-encapsulate","title":"Packing the Envelope: <code>encapsulate()</code>","text":"<p>How do we take our <code>payload</code> and put it into the standard 128-byte frame, adding the length information? This process is called encapsulation.</p> <p>The <code>encapsulate()</code> method in <code>TransportMessage</code> does this:</p> <ol> <li>Creates a new, empty byte array of exactly <code>SEGMENTSIZE</code> (128 bytes).</li> <li>Calculates the length of the <code>payload</code>.</li> <li>Writes this length value into the very first byte (index 0) of the 128-byte array.</li> <li>Copies the actual <code>payload</code> bytes into the array, starting right after the length byte (at index 1).</li> <li>Returns the filled 128-byte array. The rest of the array (after the payload) is just padding and doesn't matter.</li> </ol> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\npublic byte[] encapsulate() {\n\n    byte[] encoded; // This will be our 128-byte framed message\n\n    // Create the empty 128-byte array\n    encoded = new byte[MessageConfig.SEGMENTSIZE];\n\n    // --- The Framing Magic ---\n    // 1. Put the length of the payload into the first byte\n    encoded[0] = (byte) (payload.length);\n\n    // 2. Copy the payload bytes starting from the second byte (index 1)\n    for (int i = 0; i &lt; payload.length; i++) {\n        encoded[i + 1] = payload[i];\n    }\n    // --- End of Framing ---\n\n    // Return the fully prepared 128-byte segment\n    return encoded;\n}\n</code></pre> <ul> <li><code>encoded = new byte[MessageConfig.SEGMENTSIZE];</code>: Makes the 128-byte \"envelope\".</li> <li><code>encoded[0] = (byte) (payload.length);</code>: Writes the payload length into the first byte. We cast to <code>byte</code> because the length must fit in a single byte (0-255), which is why <code>SEGMENTSIZE</code> (128) limits the maximum payload size (to 127 bytes + 1 length byte).</li> <li><code>encoded[i + 1] = payload[i];</code>: Copies the payload bytes one by one into the <code>encoded</code> array, starting at index 1.</li> </ul> <p>Visual Example: If our payload is <code>[72, 101, 108, 108, 111]</code> (bytes for \"Hello\"), its length is 5. <code>encapsulate()</code> produces a 128-byte array like this:</p> <pre><code>Byte Index:   0    1    2    3    4    5    6   ...   127\nValue:      [ 5 | 72 |101 |108 |108 |111 | 0 | ... |  0 ]\n             \\-/ \\---------------------/ \\-------------/\n            Length    Actual Payload       Padding (unused)\n</code></pre> <p>This 128-byte <code>encoded</code> array is what gets sent over the network by the Connection.</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#opening-the-envelope-decapsulate","title":"Opening the Envelope: <code>decapsulate()</code>","text":"<p>When the receiver gets a 128-byte chunk of data from the network, how does it extract the original <code>payload</code>? This is called decapsulation.</p> <p>The <code>decapsulate()</code> method does the reverse of <code>encapsulate()</code>:</p> <ol> <li>Takes the received 128-byte array (<code>received</code>) as input.</li> <li>Reads the first byte (index 0) to find out the <code>length</code> of the original payload.</li> <li>Uses this <code>length</code> to know exactly which bytes in the <code>received</code> array constitute the payload (from index 1 up to index <code>length</code>).</li> <li>Copies only these payload bytes into the <code>TransportMessage</code> object's own <code>payload</code> field.</li> </ol> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/TransportMessage.java\n\nimport java.util.Arrays; // Needed for Arrays.copyOfRange\n\npublic void decapsulate(byte[] received) { // 'received' is the 128-byte array from network\n\n    // --- The Un-Framing Magic ---\n    // 1. Read the payload length from the first byte\n    int len = received[0];\n\n    // 2. Extract the payload bytes from the received array\n    //    Starts at index 1, and copies 'len' bytes.\n    payload = Arrays.copyOfRange(received, 1, len + 1);\n    // --- End of Un-Framing ---\n\n    // Now, 'this.payload' holds the original message bytes again!\n}\n</code></pre> <ul> <li><code>int len = received[0];</code>: Gets the length stored in the first byte.</li> <li><code>payload = Arrays.copyOfRange(received, 1, len + 1);</code>: This is a handy Java utility. It copies a portion of the <code>received</code> array.<ul> <li><code>1</code>: Start copying from index 1 (where the payload begins).</li> <li><code>len + 1</code>: Copy up to (but not including) this index. Since we start at 1 and want <code>len</code> bytes, the end index is <code>1 + len</code>.</li> </ul> </li> <li>After this, the <code>payload</code> field of the <code>TransportMessage</code> object holds the extracted data.</li> </ul>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#how-it-fits-together","title":"How It Fits Together","text":"<p>Here's a simplified view of how <code>TransportMessage</code> is used when sending a message:</p> <pre><code>sequenceDiagram\n    participant Ctrl as Controller\n    participant Cl as Client\n    participant MU as MessageUtils\n    participant TM as TransportMessage\n    participant Conn as Connection\n    participant Net as Network\n\n    Note over Ctrl, Cl: User wants to publish \"Hello\" to \"general\"\n    Ctrl-&gt;&gt;Cl: client.publish(\"general\", \"Hello\")\n    Cl-&gt;&gt;Cl: Create PublishMsg(user, \"general\", \"Hello\")\n    Cl-&gt;&gt;MU: MessageUtils.toTransportMessage(publishMsg)\n    MU-&gt;&gt;MU: Serialize PublishMsg into byte[] payload (e.g., [72, 101, ...])\n    MU-&gt;&gt;TM: new TransportMessage(payload)\n    TM--&gt;&gt;MU: TransportMessage object created (holds payload)\n    MU--&gt;&gt;Cl: Return TransportMessage object\n    Cl-&gt;&gt;Conn: connection.send(transportMessage)\n    Conn-&gt;&gt;TM: transportMessage.encapsulate()\n    TM-&gt;&gt;TM: Create 128-byte array: [length | payload | padding]\n    TM--&gt;&gt;Conn: Return 128-byte encoded array\n    Conn-&gt;&gt;Net: Send 128 bytes over TCP stream\n</code></pre> <ol> <li>The <code>Client</code> gets a <code>Message</code> object (like <code>PublishMsg</code>).</li> <li>It asks <code>MessageUtils</code> (Chapter 8) to convert this object into a <code>TransportMessage</code>.</li> <li><code>MessageUtils</code> first turns the <code>PublishMsg</code> into its raw byte <code>payload</code>.</li> <li><code>MessageUtils</code> creates a <code>TransportMessage</code> containing this <code>payload</code>.</li> <li>The <code>Client</code> tells the <code>Connection</code> (Chapter 7) to send this <code>TransportMessage</code>.</li> <li>The <code>Connection</code> calls <code>transportMessage.encapsulate()</code> to get the framed 128-byte array.</li> <li>The <code>Connection</code> sends these 128 bytes over the network.</li> </ol> <p>Receiving works in reverse, with the <code>Connection</code> reading 128 bytes, creating an empty <code>TransportMessage</code>, calling <code>decapsulate()</code> on it, and then passing the <code>TransportMessage</code> (now containing the extracted payload) to <code>MessageUtils</code> to turn it back into a <code>PublishMsg</code>.</p>"},{"location":"oblig2/06_transportmessage__network_data_framing__/#conclusion","title":"Conclusion","text":"<p>We've learned that sending raw data over a network stream is problematic because the receiver doesn't know where messages start and end. Data Framing solves this by wrapping the message data (payload) in a structure that includes metadata, like the payload's length.</p> <p>The <code>TransportMessage</code> class implements this framing in our project: *   It holds the raw message <code>payload</code> (as bytes). *   It uses a fixed <code>SEGMENTSIZE</code> (128 bytes) for all network transmissions. *   The <code>encapsulate()</code> method creates the 128-byte frame by writing the <code>payload</code> length in the first byte, followed by the <code>payload</code> itself. *   The <code>decapsulate()</code> method extracts the original <code>payload</code> from a received 128-byte frame by reading the length from the first byte.</p> <p>This framing ensures that the receiver can reliably reconstruct messages even when they arrive as part of a continuous byte stream.</p> <p>Now that we understand how a single message is packaged into a <code>TransportMessage</code> frame, how are these frames actually sent and received over the network connection itself? In the next chapter, we'll explore Chapter 7: Connection (Network Stream Handling) to see how the application manages the input and output streams for network communication.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/","title":"Chapter 7: Connection (Network Stream Handling)","text":"<p>In Chapter 6: TransportMessage (Network Data Framing), we learned how to package our messages (like <code>PublishMsg</code>) into standard-sized 128-byte \"envelopes\" called <code>TransportMessage</code>s. We know how to put the message length and the message data inside this envelope using <code>encapsulate()</code>.</p> <p>But how does this digital envelope actually get sent across the internet wires? And how do we receive similar envelopes coming back from the server? Simply creating the <code>TransportMessage</code> frame isn't enough; we need something to handle the actual pickup and delivery over the network.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#the-delivery-truck-handling-network-streams","title":"The Delivery Truck: Handling Network Streams","text":"<p>Think back to our analogy: *   Your application wants to send a message (<code>PublishMsg</code>). *   <code>MessageUtils</code> (Chapter 8) turns it into raw bytes (the package content). *   <code>TransportMessage</code> (Chapter 6) puts these bytes into a standard 128-byte frame (the shipping box with a length label).</p> <p>Now we need the delivery truck and driver. This is the part that knows the network \"roads\" (the underlying TCP/IP connection) and how to physically load the box (<code>TransportMessage</code> bytes) onto the truck, drive it to the destination (server), and unload incoming boxes.</p> <p>In our project, the <code>Connection</code> class (<code>Connection.java</code>) is this delivery truck and driver. It manages the low-level details of sending and receiving streams of bytes over an established network connection. It doesn't need to understand what is inside the <code>TransportMessage</code> box; it just needs to know how to send the box reliably and receive incoming boxes.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#key-parts-of-the-delivery-system","title":"Key Parts of the Delivery System","text":"<p>Before we look at the <code>Connection</code> class itself, let's understand two key concepts it uses:</p> <ol> <li> <p>Socket: When the <code>Client</code> (Chapter 2) connects to the server, it establishes a TCP Socket connection. Think of the socket as a specific, numbered docking bay at the post office dedicated to communication between your application and the server. It's the endpoint of the network link.</p> </li> <li> <p>Input/Output Streams: How does Java code actually put data onto the socket (send) or get data from the socket (receive)? It uses Streams. Imagine these as conveyor belts attached to the docking bay:</p> <ul> <li><code>OutputStream</code> (specifically <code>DataOutputStream</code>): This is the \"outgoing\" conveyor belt. You put bytes onto it, and they get sent out through the socket. <code>DataOutputStream</code> is helpful because it has methods designed for sending primitive Java data types, like raw bytes.</li> <li><code>InputStream</code> (specifically <code>DataInputStream</code>): This is the \"incoming\" conveyor belt. Bytes arriving at the socket come in on this stream, and you can read them. <code>DataInputStream</code> helps read primitive data, including raw bytes.</li> </ul> </li> </ol> <p>The <code>Connection</code> class manages the <code>Socket</code> and these two streams.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#creating-a-connection","title":"Creating a <code>Connection</code>","text":"<p>We don't usually create the <code>Connection</code> object directly in our main application logic. Remember from Chapter 2, the <code>Client</code> uses a helper called <code>MessagingClient</code> to establish the initial network connection. This helper creates the <code>Socket</code> and then immediately wraps it in a <code>Connection</code> object.</p> <p>Here's the constructor of the <code>Connection</code> class:</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class Connection {\n\n    private DataOutputStream outStream; // Outgoing conveyor belt\n    private DataInputStream inStream;   // Incoming conveyor belt\n    private Socket socket;              // The docking bay\n\n    public Connection(Socket socket) { // Takes the established connection point\n\n        try {\n            this.socket = socket; // Store the socket\n\n            // Attach the outgoing stream to the socket\n            outStream = new DataOutputStream(socket.getOutputStream());\n\n            // Attach the incoming stream to the socket\n            inStream = new DataInputStream(socket.getInputStream());\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Error: \" + ex.getMessage());\n            // In a real app, handle this error more gracefully\n        }\n    }\n\n    // ... methods for sending, receiving, closing ...\n}\n</code></pre> <ul> <li>The constructor receives an already connected <code>Socket</code>.</li> <li>It creates a <code>DataOutputStream</code> linked to the socket's output, storing it in <code>outStream</code>.</li> <li>It creates a <code>DataInputStream</code> linked to the socket's input, storing it in <code>inStream</code>.</li> <li>Now the <code>Connection</code> object is ready to send and receive data using these streams.</li> </ul>"},{"location":"oblig2/07_connection__network_stream_handling__/#sending-a-package-connectionsend","title":"Sending a Package: <code>Connection.send()</code>","text":"<p>How does the <code>Client</code> tell the <code>Connection</code> to send one of our prepared <code>TransportMessage</code> boxes? It calls the <code>send()</code> method.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    public void send(TransportMessage message) {\n\n        try {\n            // 1. Get the 128-byte framed data from the TransportMessage\n            //    (This uses the encapsulate() method from Chapter 6)\n            byte[] sendbuf = message.encapsulate();\n\n            // 2. Write the entire 128-byte buffer to the output stream\n            outStream.write(sendbuf);\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Send Error: \" + ex.getMessage());\n            // Handle errors\n        }\n    }\n</code></pre> <ul> <li>The method takes a <code>TransportMessage</code> object as input (this object already contains the payload bytes).</li> <li>Step 1: It calls <code>message.encapsulate()</code>. As we learned in Chapter 6, this creates the standard 128-byte array with the length byte followed by the payload bytes.</li> <li>Step 2: It uses <code>outStream.write(sendbuf)</code> to put the entire 128-byte array onto the outgoing conveyor belt (the <code>DataOutputStream</code>). The underlying network system takes care of sending these bytes through the <code>Socket</code> to the server.</li> </ul> <p>Simple! The <code>Connection</code> doesn't need to know what's inside <code>message</code>, only how to get the framed bytes from it and write them to the stream.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#receiving-a-package-connectionreceive","title":"Receiving a Package: <code>Connection.receive()</code>","text":"<p>When data arrives from the server, how does the <code>Client</code> get it? It asks the <code>Connection</code> object by calling the <code>receive()</code> method. Since we know (from Chapter 6) that all data is sent in 128-byte frames, the <code>receive()</code> method expects to read exactly 128 bytes.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    public TransportMessage receive() {\n\n        TransportMessage message = null; // Where we'll store the result\n        byte[] recvbuf; // A temporary buffer to hold the incoming 128 bytes\n\n        try {\n            // 1. Create an empty byte array exactly 128 bytes long\n            recvbuf = new byte[MessageConfig.SEGMENTSIZE];\n\n            // 2. Read exactly 128 bytes from the input stream into the buffer\n            //    This will wait ('block') if data isn't available yet.\n            int read = inStream.read(recvbuf, 0, MessageConfig.SEGMENTSIZE);\n\n            // Basic check if we actually read the expected amount\n            if (read != MessageConfig.SEGMENTSIZE) {\n                throw new IOException(\"Receive - did not read full segment\");\n            }\n\n            // 3. Create a new, empty TransportMessage object\n            message = new TransportMessage();\n\n            // 4. Tell the TransportMessage to extract the payload\n            //    from the received 128 bytes using decapsulate() (Chapter 6)\n            message.decapsulate(recvbuf);\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Receive Error: \" + ex.getMessage());\n            // Handle errors (e.g., connection closed)\n            // Returning null indicates failure\n            message = null;\n        }\n\n        // 5. Return the TransportMessage, now containing the extracted payload\n        return message;\n    }\n</code></pre> <ul> <li>Step 1: An empty byte array <code>recvbuf</code> of size 128 is created. This is where the incoming data will be temporarily stored.</li> <li>Step 2: <code>inStream.read(recvbuf, 0, MessageConfig.SEGMENTSIZE)</code> is the crucial part. This command tells the <code>DataInputStream</code> to read bytes from the network and fill the <code>recvbuf</code>. It will wait until exactly 128 bytes have been received.</li> <li>Step 3: A new, empty <code>TransportMessage</code> object is created.</li> <li>Step 4: <code>message.decapsulate(recvbuf)</code> is called. As we saw in Chapter 6, this method looks at the first byte of <code>recvbuf</code> to find the length, then copies the actual payload bytes from <code>recvbuf</code> into the <code>message</code> object's internal <code>payload</code> field.</li> <li>Step 5: The <code>message</code> object, now containing the extracted payload bytes, is returned. The caller (usually the <code>Client</code>) now has the raw data of the message that was sent by the server.</li> </ul>"},{"location":"oblig2/07_connection__network_stream_handling__/#how-sending-works-under-the-hood","title":"How Sending Works: Under the Hood","text":"<p>Let's visualize the <code>send()</code> process:</p> <pre><code>sequenceDiagram\n    participant Cl as Client\n    participant Conn as Connection\n    participant TM as TransportMessage\n    participant DOS as DataOutputStream\n    participant Sock as Socket\n\n    Cl-&gt;&gt;Conn: connection.send(myTransportMessage)\n    Conn-&gt;&gt;TM: myTransportMessage.encapsulate()\n    TM--&gt;&gt;Conn: Return 128-byte framedData\n    Conn-&gt;&gt;DOS: outStream.write(framedData)\n    DOS-&gt;&gt;Sock: Write bytes to Socket\n    Sock-&gt;&gt;Sock: Send bytes over Network</code></pre> <p>The <code>Client</code> asks the <code>Connection</code> to send. The <code>Connection</code> gets the framed bytes from the <code>TransportMessage</code> and writes them to the <code>DataOutputStream</code>, which sends them through the <code>Socket</code>.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#closing-the-docking-bay-connectionclose","title":"Closing the Docking Bay: <code>Connection.close()</code>","text":"<p>When the user disconnects or the application shuts down, it's important to clean up the network resources. This means closing the streams and the socket.</p> <pre><code>// File: src/main/java/no/hvl/dat110/messagetransport/Connection.java\n\n    // Close the connection by closing streams and the underlying socket\n    public void close() {\n        try {\n            // Close the outgoing stream\n            outStream.close();\n            // Close the incoming stream\n            inStream.close();\n            // Close the network socket itself\n            socket.close();\n\n        } catch (IOException ex) {\n            System.out.println(\"Connection Close Error: \" + ex.getMessage());\n            // Handle errors\n        }\n    }\n</code></pre> <p>This method simply calls <code>close()</code> on both streams and the socket to release the network connection gracefully.</p>"},{"location":"oblig2/07_connection__network_stream_handling__/#conclusion","title":"Conclusion","text":"<p>The <code>Connection</code> class is our application's \"delivery truck,\" responsible for the low-level task of sending and receiving byte streams over the network.</p> <ul> <li>It wraps a <code>Socket</code> (the connection endpoint) and manages <code>DataInputStream</code> and <code>DataOutputStream</code> (the conveyor belts).</li> <li><code>send(TransportMessage message)</code> uses <code>message.encapsulate()</code> to get the 128-byte frame and writes it to the <code>DataOutputStream</code>.</li> <li><code>receive()</code> reads exactly 128 bytes from the <code>DataInputStream</code>, creates a <code>TransportMessage</code>, and uses <code>message.decapsulate()</code> to extract the payload.</li> <li>It relies on the framing strategy defined in <code>TransportMessage</code> (Chapter 6) to know how much data to read and how to extract the payload.</li> <li><code>close()</code> cleans up the network resources.</li> </ul> <p>The <code>Connection</code> deals only with the framed bytes. It successfully delivers the <code>TransportMessage</code> box, but the box still contains raw payload bytes. How do we turn those bytes back into the meaningful <code>Message</code> objects (like <code>PublishMsg</code> or <code>ConnectMsg</code>) that our application logic understands?</p> <p>That's the final piece of the puzzle! In the next chapter, we'll explore Chapter 8: MessageUtils (Serialization/Deserialization), the utility that converts our Java message objects to bytes (for sending) and converts received bytes back into objects.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/","title":"Chapter 8: MessageUtils (Serialization/Deserialization)","text":"<p>Welcome to the final chapter of our core tutorial! In Chapter 7: Connection (Network Stream Handling), we saw how the <code>Connection</code> class acts like a delivery truck, sending and receiving standard-sized 128-byte packages (<code>TransportMessage</code> from Chapter 6) over the network.</p> <p>However, there's a crucial step we haven't fully explored. Inside those 128-byte packages are the raw payload bytes. When we send a message, how do we convert our meaningful Java <code>Message</code> objects (like <code>PublishMsg</code> from Chapter 1) into those raw bytes? And when we receive a package, how do we turn the payload bytes back into a usable <code>Message</code> object that our application logic (Chapter 5: Controller) can understand?</p> <p>This conversion process is like translating between languages \u2013 the language of our Java application (objects) and the language of the network (bytes).</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#the-translator-and-packager-messageutils","title":"The Translator and Packager: <code>MessageUtils</code>","text":"<p>Imagine you want to send a detailed instruction manual (our <code>Message</code> object) to someone overseas. You can't just beam the manual directly! 1.  Translate: You might first translate it into a universally understood format, like simple English or maybe a standard code (like JSON). 2.  Package: Then, you need to write this translated version down onto paper (convert to bytes) and put it in a standard shipping box (<code>TransportMessage</code>).</p> <p>When the person receives the box, they do the reverse: 1.  Unpack: They take the paper out of the box. 2.  Translate Back: They read the standard format and reconstruct the original instruction manual in their own language.</p> <p>The <code>MessageUtils</code> class (<code>MessageUtils.java</code>) acts as our application's translator and packager. It's a collection of helper tools (static methods) specifically designed to:</p> <ul> <li>Serialize: Convert a <code>Message</code> object into a standard format (JSON string) and then into raw bytes, ready to be put into a <code>TransportMessage</code> for sending.</li> <li>Deserialize: Take raw bytes received from a <code>TransportMessage</code>, convert them back into the standard format (JSON string), and then reconstruct the original <code>Message</code> object.</li> </ul>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#why-json-a-universal-language","title":"Why JSON? A Universal Language","text":"<p>Instead of inventing our own complex way to represent message objects as bytes, we use a popular, standard format called JSON (JavaScript Object Notation).</p> <p>JSON is human-readable text that uses key-value pairs. A <code>PublishMsg</code> object might look like this in JSON:</p> <pre><code>{\n  \"type\": \"PUBLISH\",\n  \"user\": \"Alice\",\n  \"topic\": \"general\",\n  \"message\": \"Hello there!\"\n}\n</code></pre> <p>Why use JSON? *   Readable: Humans can easily read and understand it (great for debugging!). *   Standard: Many programming languages and systems understand JSON, making it great for communication. *   Simple: It's relatively easy to convert Java objects to and from JSON.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#using-gson-our-json-translator-tool","title":"Using GSON: Our JSON Translator Tool","text":"<p>To handle the conversion between our Java <code>Message</code> objects and JSON strings, we use a popular Java library called GSON (from Google). Think of GSON as a specialized translator that knows how to read Java object fields (like <code>user</code>, <code>topic</code>) and write them into JSON format, and vice-versa.</p> <p>You'll notice <code>import com.google.gson.*;</code> at the top of <code>MessageUtils.java</code> - that's us bringing in the GSON library.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#serialization-object-json-bytes","title":"Serialization: Object -&gt; JSON -&gt; Bytes","text":"<p>Let's see how <code>MessageUtils</code> handles serialization when we want to send a message.</p> <p>Step 1: Object to JSON String (<code>toJson</code>)</p> <p>This method takes any <code>Message</code> object and uses GSON to turn it into a JSON string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport com.google.gson.Gson; // Import the GSON library\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    public static String toJson(Message msg) {\n        // Create a GSON translator instance\n        Gson gson = new Gson();\n        // Tell GSON to convert the Message object into a JSON string\n        String json = gson.toJson(msg);\n        // Return the resulting JSON string\n        return json;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object (e.g., <code>new PublishMsg(\"Alice\", \"general\", \"Hello!\")</code>). *   Output: A JSON string (e.g., <code>{\"type\":\"PUBLISH\",\"user\":\"Alice\",\"topic\":\"general\",\"message\":\"Hello there!\"}</code>). *   How: It simply uses <code>gson.toJson(msg)</code>. GSON automatically looks at the fields in the <code>msg</code> object and creates the corresponding JSON structure.</p> <p>Step 2: JSON String to Bytes (<code>getBytes</code>)</p> <p>Now that we have the JSON string, we need to convert it into the raw bytes that can be sent over the network. Java strings have a built-in method for this.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... toJson method ...\n\n    public static byte[] getBytes(Message msg) {\n        // First, convert the Message object to a JSON string\n        String jsonString = toJson(msg);\n        // Then, convert the string into an array of bytes\n        // using the default character encoding (usually UTF-8)\n        byte[] bytes = jsonString.getBytes();\n        // Return the byte array\n        return bytes;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object. *   Output: A <code>byte[]</code> array representing the JSON string. *   How: It calls <code>toJson()</code> first, then calls the standard Java <code>.getBytes()</code> method on the resulting string.</p> <p>Step 3: Bytes into a TransportMessage (<code>toTransportMessage</code>)</p> <p>Finally, we take these bytes and put them into the <code>TransportMessage</code> frame we learned about in Chapter 6.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport no.hvl.dat110.messagetransport.TransportMessage; // Import TransportMessage\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... toJson, getBytes methods ...\n\n    public static TransportMessage toTransportMessage(Message msg) {\n        // 1. Convert the Message object to bytes (via JSON)\n        byte[] payloadBytes = getBytes(msg);\n        // 2. Create a new TransportMessage containing these bytes as payload\n        TransportMessage transportMsg = new TransportMessage(payloadBytes);\n        // Return the prepared TransportMessage\n        return transportMsg;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>Message</code> object. *   Output: A <code>TransportMessage</code> object ready to be sent by the <code>Connection</code>. *   How: It calls <code>getBytes()</code> to get the payload, then creates a <code>new TransportMessage()</code> using those bytes.</p> <p>This <code>toTransportMessage</code> method is the primary serialization helper used by the <code>Client</code> before sending.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#deserialization-bytes-json-object","title":"Deserialization: Bytes -&gt; JSON -&gt; Object","text":"<p>Now let's look at the reverse process when we receive data. The <code>Connection</code> gives us a <code>TransportMessage</code> containing payload bytes.</p> <p>Step 1: Extract Bytes from TransportMessage (<code>fromTransportMessage</code>)</p> <p>This method takes the received <code>TransportMessage</code> and extracts the raw payload bytes.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... serialization methods ...\n\n    public static Message fromTransportMessage(TransportMessage msg) {\n        // 1. Get the raw payload bytes from the TransportMessage\n        byte[] payloadBytes = msg.getData();\n        // 2. Convert these bytes back into a Message object\n        Message originalMessage = fromBytes(payloadBytes);\n        // Return the reconstructed Message object\n        return originalMessage;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A <code>TransportMessage</code> received from the <code>Connection</code>. *   Output: The reconstructed <code>Message</code> object. *   How: It calls <code>msg.getData()</code> to get the payload bytes, then passes these bytes to the <code>fromBytes</code> method (explained next).</p> <p>Step 2: Bytes to JSON String (<code>fromBytes</code>)</p> <p>This method takes the raw bytes and converts them back into a JSON string.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\npublic class MessageUtils {\n\n    // ... fromTransportMessage method ...\n\n    public static Message fromBytes(byte[] payload) {\n        // Convert the byte array back into a String\n        String jsonString = new String(payload);\n        // Convert the JSON string into a Message object\n        Message message = fromJson(jsonString);\n        // Return the reconstructed object\n        return message;\n    }\n\n    // ... fromJson method ...\n}\n</code></pre> *   Input: A <code>byte[]</code> array (the payload). *   Output: A <code>Message</code> object. *   How: It uses <code>new String(payload)</code> to turn the bytes back into a string (assuming the same character encoding, usually UTF-8). Then, it calls <code>fromJson()</code> (explained next) to parse this string.</p> <p>Step 3: JSON String to Object (<code>fromJson</code>)</p> <p>This is the core of deserialization where GSON reconstructs the specific <code>Message</code> object. Since the JSON only tells us the <code>type</code> (like \"PUBLISH\"), we need to help GSON figure out which Java class to create (<code>PublishMsg</code>, <code>ConnectMsg</code>, etc.).</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport com.google.gson.*; // Need more GSON classes here\nimport no.hvl.dat110.messages.MessageType; // Need the enum\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... fromBytes method ...\n\n    public static Message fromJson(String msgJson) {\n\n        // 1. Parse the raw JSON string into a generic JSON object structure\n        JsonParser jsonParser = new JsonParser();\n        JsonObject json = jsonParser.parse(msgJson).getAsJsonObject();\n\n        // 2. Look inside the JSON to find the \"type\" field's value\n        String typestr = json.get(\"type\").getAsString(); // e.g., \"PUBLISH\"\n\n        // 3. Convert the type string into our MessageType enum\n        MessageType type = MessageType.valueOf(typestr); // e.g., MessageType.PUBLISH\n\n        // 4. Create a GSON instance\n        Gson gson = new Gson();\n        Message message = null; // Variable to hold the final object\n\n        // 5. Use a switch based on the type to tell GSON which class to build\n        switch (type) {\n            case CONNECT:\n                message = gson.fromJson(json, ConnectMsg.class);\n                break;\n            case PUBLISH:\n                message = gson.fromJson(json, PublishMsg.class);\n                break;\n            case SUBSCRIBE:\n                message = gson.fromJson(json, SubscribeMsg.class);\n                break;\n            // ... cases for all other MessageTypes ...\n            default:\n                System.out.println(\"fromJson - unknown message type: \" + typestr);\n                break;\n        }\n\n        // Return the specific Message object (e.g., a PublishMsg instance)\n        return message;\n    }\n\n    // ... other methods ...\n}\n</code></pre> *   Input: A JSON string (e.g., <code>{\"type\":\"PUBLISH\",\"user\":\"Alice\",...}</code>). *   Output: A specific <code>Message</code> object (e.g., a <code>PublishMsg</code> instance). *   How:     *   It first parses the string into a general <code>JsonObject</code>.     *   It extracts the value of the <code>\"type\"</code> field.     *   It uses a <code>switch</code> statement based on this type.     *   Inside the correct <code>case</code>, it calls <code>gson.fromJson(json, SpecificMsgClass.class)</code>. This tells GSON: \"Take the data from this <code>json</code> object and use it to create an instance of this specific class (e.g., <code>PublishMsg.class</code>)\". GSON automatically matches JSON fields to the Java class fields.</p> <p>This <code>fromTransportMessage</code> (which uses <code>fromBytes</code> and <code>fromJson</code>) is the primary deserialization helper used by the <code>Client</code> after receiving data.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#convenience-methods-send-and-receive","title":"Convenience Methods: <code>send</code> and <code>receive</code>","text":"<p><code>MessageUtils</code> also provides two high-level convenience methods that combine the translation step with the actual network sending/receiving.</p> <p><pre><code>// File: src/main/java/no/hvl/dat110/messages/MessageUtils.java\n\nimport no.hvl.dat110.messagetransport.Connection; // Need Connection\n\n// ... other imports ...\n\npublic class MessageUtils {\n\n    // ... all the conversion methods ...\n\n    // Sends a Message object over a Connection\n    public static void send (Connection connection, Message message) {\n        // 1. Convert the Message object to a TransportMessage\n        TransportMessage transportMsg = toTransportMessage(message);\n        // 2. Tell the connection to send it\n        connection.send(transportMsg);\n    }\n\n    // Receives the next Message object from a Connection\n    public static Message receive (Connection connection) {\n        // 1. Tell the connection to receive the next 128-byte frame\n        TransportMessage transportMsg = connection.receive();\n        // 2. If successful, convert the TransportMessage back to a Message object\n        Message message = null;\n        if (transportMsg != null) {\n            message = fromTransportMessage(transportMsg);\n        }\n        // Return the reconstructed Message object (or null if receive failed)\n        return message;\n    }\n}\n</code></pre> *   <code>send(connection, message)</code>: A shortcut that takes your <code>Message</code> object, serializes it into a <code>TransportMessage</code> using <code>toTransportMessage</code>, and then calls <code>connection.send()</code> to send it over the network. *   <code>receive(connection)</code>: A shortcut that calls <code>connection.receive()</code> to get the next <code>TransportMessage</code>, and if successful, deserializes it back into the original <code>Message</code> object using <code>fromTransportMessage</code>.</p> <p>The <code>Client</code> primarily uses these <code>send</code> and <code>receive</code> methods for cleaner code.</p>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#under-the-hood-gson-at-work","title":"Under the Hood: GSON at Work","text":"<p>Let's visualize the core GSON translation steps.</p> <p>Serialization (<code>toJson</code>):</p> <pre><code>sequenceDiagram\n    participant Client as Client Code\n    participant MU as MessageUtils\n    participant GSON as GSON Library\n    participant PubMsg as PublishMsg Object\n\n    Client-&gt;&gt;MU: toJson(myPublishMsg)\n    Note right of Client: myPublishMsg has user=\"Alice\", topic=\"news\", ...\n    MU-&gt;&gt;GSON: gson.toJson(myPublishMsg)\n    GSON-&gt;&gt;PubMsg: Read field 'type' (PUBLISH)\n    GSON-&gt;&gt;PubMsg: Read field 'user' (\"Alice\")\n    GSON-&gt;&gt;PubMsg: Read field 'topic' (\"news\")\n    GSON-&gt;&gt;PubMsg: Read field 'message' (\"Hello\")\n    GSON--&gt;&gt;MU: Return JSON String: \"{\\\"type\\\":\\\"PUBLISH\\\",\\\"user\\\":\\\"Alice\\\",...}\"\n    MU--&gt;&gt;Client: Return JSON String</code></pre> <p>Deserialization (<code>fromJson</code> for a PublishMsg):</p> <pre><code>sequenceDiagram\n    participant Client as Client Code\n    participant MU as MessageUtils\n    participant Parser as JsonParser\n    participant GSON as GSON Library\n\n    Client-&gt;&gt;MU: fromJson(\"{\\\"type\\\":\\\"PUBLISH\\\",\\\"user\\\":\\\"Alice\\\",...}\")\n    MU-&gt;&gt;Parser: parser.parse(jsonString)\n    Parser--&gt;&gt;MU: Return JsonObject 'json'\n    MU-&gt;&gt;MU: Get type from json (\"PUBLISH\")\n    MU-&gt;&gt;MU: Switch -&gt; case PUBLISH:\n    MU-&gt;&gt;GSON: gson.fromJson(json, PublishMsg.class)\n    GSON-&gt;&gt;GSON: Create new empty PublishMsg object\n    GSON-&gt;&gt;GSON: Find \"user\" in json, set object.user = \"Alice\"\n    GSON-&gt;&gt;GSON: Find \"topic\" in json, set object.topic = \"news\"\n    GSON-&gt;&gt;GSON: Find \"message\" in json, set object.message = \"Hello\"\n    GSON--&gt;&gt;MU: Return populated PublishMsg object\n    MU--&gt;&gt;Client: Return Message object (as PublishMsg)</code></pre>"},{"location":"oblig2/08_messageutils__serialization_deserialization__/#conclusion","title":"Conclusion","text":"<p>The <code>MessageUtils</code> class is the essential translator between our application's Java <code>Message</code> objects and the raw bytes needed for network transmission.</p> <ul> <li>It uses the JSON format as a standard, readable intermediate representation.</li> <li>It relies on the GSON library to perform the actual conversion between Java objects and JSON strings.</li> <li>Serialization (<code>toTransportMessage</code>): Converts <code>Message</code> -&gt; JSON String -&gt; <code>byte[]</code> -&gt; <code>TransportMessage</code>.</li> <li>Deserialization (<code>fromTransportMessage</code>): Converts <code>TransportMessage</code> -&gt; <code>byte[]</code> -&gt; JSON String -&gt; <code>Message</code>.</li> <li>The <code>fromJson</code> method uses the <code>\"type\"</code> field within the JSON to determine which specific <code>Message</code> subclass to create.</li> <li>Helper methods <code>send</code> and <code>receive</code> simplify the process for the <code>Client</code>.</li> </ul> <p>With <code>MessageUtils</code>, we complete the communication pipeline. We can now create message objects, translate and package them, send them over the network using the connection, receive packages, and translate them back into objects the application can understand.</p> <p>This concludes our tour of the core components of the <code>dat110-project2-javafx-chatapp</code> client! We've covered the message structure, client logic, application entry point, UI areas, controller, network framing, connection handling, and finally, the serialization/deserialization mechanism. You now have a foundational understanding of how these pieces work together to create a functional chat client.</p>"},{"location":"oblig2/oblig2_index/","title":"Tutorial: dat110-project2-javafx-chatapp","text":"<p>This project is a simple JavaFX Chat Application (ChApp). It allows users to connect to a central message broker (server), subscribe to chat topics, and publish/receive messages on those topics. The application has a graphical user interface (GUI) for interaction and handles the underlying network communication and message formatting.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Chapp (Application Entry Point)\n\"]\n    A1[\"Controller (UI Logic Coordinator)\n\"]\n    A2[\"Client (Network Interaction Logic)\n\"]\n    A3[\"Message Hierarchy (Communication Protocol)\n\"]\n    A4[\"MessageUtils (Serialization/Deserialization)\n\"]\n    A5[\"Connection (Network Stream Handling)\n\"]\n    A6[\"TransportMessage (Network Data Framing)\n\"]\n    A7[\"UI Areas (CommandArea &amp; MessageArea)\n\"]\n    A0 -- \"Creates and configures\" --&gt; A1\n    A0 -- \"Sets up GUI\" --&gt; A7\n    A7 -- \"Forwards user actions\" --&gt; A1\n    A1 -- \"Delegates network tasks\" --&gt; A2\n    A1 -- \"Updates display\" --&gt; A7\n    A2 -- \"Uses for message conversion\" --&gt; A4\n    A2 -- \"Establishes network connection\" --&gt; A5\n    A4 -- \"Serializes/Deserializes\" --&gt; A3\n    A4 -- \"Uses for framing/unframing\" --&gt; A6\n    A4 -- \"Sends/Receives via\" --&gt; A5\n    A5 -- \"Sends/Receives\" --&gt; A6</code></pre>"},{"location":"oblig2/oblig2_index/#chapters","title":"Chapters","text":"<ol> <li>Message Hierarchy (Communication Protocol) </li> <li>Client (Network Interaction Logic) </li> <li>Chapp (Application Entry Point) </li> <li>UI Areas (CommandArea &amp; MessageArea) </li> <li>Controller (UI Logic Coordinator) </li> <li>TransportMessage (Network Data Framing) </li> <li>Connection (Network Stream Handling) </li> <li>MessageUtils (Serialization/Deserialization) </li> </ol>"}]}